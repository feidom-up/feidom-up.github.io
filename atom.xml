<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>feidom up up up</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feidom-up.github.io/"/>
  <updated>2024-08-22T02:37:50.882Z</updated>
  <id>https://feidom-up.github.io/</id>
  
  <author>
    <name>乔文飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hhkb快捷键备忘</title>
    <link href="https://feidom-up.github.io/2024/08/22/hhkb%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/"/>
    <id>https://feidom-up.github.io/2024/08/22/hhkb%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/</id>
    <published>2024-08-22T01:36:22.000Z</published>
    <updated>2024-08-22T02:37:50.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换连接方式："><a href="#切换连接方式：" class="headerlink" title="切换连接方式："></a>切换连接方式：</h3><ul><li>fn+ctrl+0 有线</li><li>fn+ctrl+1~4 蓝牙设备</li></ul><h3 id="蓝牙配对信息注册："><a href="#蓝牙配对信息注册：" class="headerlink" title="蓝牙配对信息注册："></a>蓝牙配对信息注册：</h3><ul><li>fn+q 进入等待配对模式</li><li>fn+ctrl+1<del>4 将即将要配对的设备存放到 1</del>4 位置。</li></ul><h3 id="删除所有配对信息："><a href="#删除所有配对信息：" class="headerlink" title="删除所有配对信息："></a>删除所有配对信息：</h3><ul><li>fn+q 进入等待配对模式</li><li>fn+z+delete</li></ul><h3 id="删除个别配对信息："><a href="#删除个别配对信息：" class="headerlink" title="删除个别配对信息："></a>删除个别配对信息：</h3><ul><li>fn+q 进入等待配对模式</li><li>fn+ctrl+delete+1~4</li></ul><h3 id="配对中途取消配对："><a href="#配对中途取消配对：" class="headerlink" title="配对中途取消配对："></a>配对中途取消配对：</h3><ul><li>fn+q 进入等待配对模式</li><li>fn+x</li></ul><h3 id="软改切换模式（非-DIP，仅在无线状态下有效）"><a href="#软改切换模式（非-DIP，仅在无线状态下有效）" class="headerlink" title="软改切换模式（非 DIP，仅在无线状态下有效）"></a>软改切换模式（非 DIP，仅在无线状态下有效）</h3><ul><li>切换为 win 模式：fn+ctrl+w</li><li>切换为 mac 模式：fn+ctrl+m</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;切换连接方式：&quot;&gt;&lt;a href=&quot;#切换连接方式：&quot; class=&quot;headerlink&quot; title=&quot;切换连接方式：&quot;&gt;&lt;/a&gt;切换连接方式：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;fn+ctrl+0 有线&lt;/li&gt;
&lt;li&gt;fn+ctrl+1~4 蓝牙设备&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="工具" scheme="https://feidom-up.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://feidom-up.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-in-V8</title>
    <link href="https://feidom-up.github.io/2021/12/30/Javascript-in-V8/"/>
    <id>https://feidom-up.github.io/2021/12/30/Javascript-in-V8/</id>
    <published>2021-12-30T03:05:49.000Z</published>
    <updated>2024-08-22T02:26:03.658Z</updated>
    
    <content type="html"><![CDATA[<p>之前对<a class="link"   href="http://www.feidom.com/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/"  target="_blank" rel="noopener">js对象你不知道的那些特点<i class="fas fa-external-link-alt"></i></a> 有一些粗浅的认识，这个笔记写的很无理取闹。现在研究清楚以后，重新补一篇笔记来完善知识。之前的这篇就留着吧，也是学习和思考中一个必有的认知阶段。</p><h4 id="JS-Object-中的常规属性和排序属性"><a href="#JS-Object-中的常规属性和排序属性" class="headerlink" title="JS Object 中的常规属性和排序属性"></a>JS Object 中的常规属性和排序属性</h4><ul><li><p>常规属性(V8:properties)<br>在properties对象中，会按照创建时的顺序保存常规属性。</p></li><li><p>排序属性(V8:elements)<br>当key为数字时，会将这类属性存储在elements对象中，将其作为一块连续的内存以Array的形式进行存储。在elements对象中，会按照数字大小的顺序来存放排序属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'100'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'B1'</span>] = <span class="string">'B'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'50'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'3'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'A2'</span>] = <span class="string">'A'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'C'</span>] = <span class="string">'C'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ClassA();</span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;a[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">a.qwf = <span class="string">'qwf'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = <span class="string">`eeeeee_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="string">`p_<span class="subst">$&#123;i&#125;</span>`</span>] = <span class="string">`pppppp_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ClassB(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><p>作为两个属性，为啥在console的控制台打印的结果中没有发现呢。其实console的控制台打印的没那么深，那怎么能找到他们呢。在Memory控制台录制快照，就能很明显的看到他们。</p></li></ul><h4 id="V8引擎对Object做了什么残忍的事"><a href="#V8引擎对Object做了什么残忍的事" class="headerlink" title="V8引擎对Object做了什么残忍的事"></a>V8引擎对Object做了什么残忍的事</h4><ul><li><p>Hidden Class 隐藏类</p></li><li><p>Properties pointer 常规属性指针</p></li><li><p>Elements pointer 排序元素指针</p><p>为什么要这样分开呢？？？<br>首先我们需要聊一下公认最快的C语言，它的快很大程度上归功于它严格的类型约束。也就是说大型的面向对象系统都有严格的数据结构，这对快速的属性查询很关键。<br>所以，Js中的Object的定义非常差,因为它太灵活了，没有类型的概念。而且存在可以任性修改的原型链，它没有限制。<br>所以在V8对JS Object进行处理时，为了快速的属性查询，有一个内部的类型系统：对具有相同结构的对象进行分组；各个对象之间可以共享；生成的成本很高，但是之后的成本很低。</p></li></ul><h4 id="V8对Object做的优化"><a href="#V8对Object做的优化" class="headerlink" title="V8对Object做的优化"></a>V8对Object做的优化</h4><p>  属性内联缓存<br>  在属性查询中检查隐藏类</p><ol><li>在第一次时完全通用查询</li><li>然后记住你在哪个地方找到的这个属性<br>生成新的优化代码</li><li>下次使用，直接访问</li></ol><h4 id="Object-属性的存储"><a href="#Object-属性的存储" class="headerlink" title="Object 属性的存储"></a>Object 属性的存储</h4><ul><li>直接在object上，即默认状态，这个很快</li><li>array形式存储，也很快</li><li>哈希表结构（字典模式），这个的交互会慢很多<br>字典模式相比于其他模式，运行速度降低。触发字典模式的行为如下：</li><li>非常多的属性，他们没有办法被放在默认状态的内存中，这个数字可能是10 ？30？</li><li>改变属性</li><li>删除属性</li></ul><h4 id="JS-Array-字典模式"><a href="#JS-Array-字典模式" class="headerlink" title="JS Array 字典模式"></a>JS Array 字典模式</h4><p>  同样对比C，Js中的Array也因为没有类型约束给了用户很大的自由，也挺样带来了不可控的性能问题。<br>  连续内存的存储和hash表（字典模式）不同的存储方式，不一样的性能体验。<br>  触发字典模式的行为如下：</p><ol><li><p>非常多的属性，大于1024？ 10000？</p></li><li><p>动态扩容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>);</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'nihao'</span>;</span><br><span class="line">a[<span class="number">100</span>] = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="结合以上特点，我们应该做什么"><a href="#结合以上特点，我们应该做什么" class="headerlink" title="结合以上特点，我们应该做什么"></a>结合以上特点，我们应该做什么</h4><p>  Js给我们很高的灵活度让我们随心所欲，但是我们不应该为所欲为，自由度高，带来的就是性能的不友好。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'100'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ClassA();</span><br><span class="line">a.qwf = <span class="string">'qwf'</span>;  <span class="comment">// 这样直接添加属性，改变了隐藏类</span></span><br></pre></td></tr></table></figure><br>  所以尽量定义好默认属性，不要在构造函数之外做大量的动态属性添加和删除，尽量共享隐藏类。</p><h4 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h4><p>  <a class="link"   href="https://v8.dev/"  target="_blank" rel="noopener">V8<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">The first type of attry to talk about in javascript is the TypedArray</span><br><span class="line"></span><br><span class="line">So TypedArrays are going to make a lot of aense to you if</span><br><span class="line">you are coming from a C background</span><br><span class="line"></span><br><span class="line">They are contiguous blocks of memory that are specified for a particylar data type.</span><br><span class="line"></span><br><span class="line">So you have Uint32Array, Float64Array, Unit8Array, and so on, and so forth, which actually, if you are familiar with Javascript,is sort of unusual. Because most things in Javascript have no type. </span><br><span class="line"></span><br><span class="line">So this idea that we are specifying a very specific size for our numbers id actually like pretty unique. And that&#39;s because the TypedArray specification grew up alongside the WebGL specification.</span><br><span class="line"></span><br><span class="line">And you can inagine how you need that level of specificity if you are doing graphics programming.</span><br><span class="line"></span><br><span class="line">So that&#39;s sort of where the TypedArray specification came from.</span><br><span class="line"></span><br><span class="line">But it&#39;s been adopted into other things now that it&#39;s there.</span><br><span class="line"></span><br><span class="line">So agein, they&#39;re memory efficient. You don&#39;t have to box them.</span><br><span class="line"></span><br><span class="line">They behave as you&#39;d expect.</span><br><span class="line"></span><br><span class="line">They&#39;re a very nice option for arrays.</span><br><span class="line"></span><br><span class="line">But if you can&#39;t use TypedArrays for whatever reason, you need to use Javascript Arrays.</span><br><span class="line"></span><br><span class="line">SO Javascript Array object --Array with a captital A-- has an API which is going to look a little weird to you if you are used to C-style arrays.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have operations that are different.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have like push and pop.</span><br><span class="line"></span><br><span class="line">It&#39;s going to allow you to index out of bounds.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have just sort of odd behavior to me as somebody coming from C.</span><br><span class="line"></span><br><span class="line">So as you can imagine, because the API allows all these non-C array-like things, the backing storage in V8 is not always somethings that looks like array. There are actually two diffent types of backing storage for arrays. Thewe are sparse arrays and dense arrays, which map to either something tach looks like a C-style array. like you&#39;d expect, or a hash table. And if you array is backed by a V8 hash table, that&#39;s called being in dictionary mode, and it&#39;s considerably less efficient. It&#39;s case that you want to avoid.</span><br><span class="line"></span><br><span class="line">There are many factors in V8 that causes you to be kicked into dictionary mode or not. </span><br><span class="line"></span><br><span class="line">So it&#39;s kind of complicated to define them all. </span><br><span class="line"></span><br><span class="line">But one of them, for instance, is space efficiency.</span><br><span class="line"></span><br><span class="line">So is the codes you wrote will be three times more effcient, use three times less space if it was backed by a hash table than an array, then it&#39;ll be a hsah table on back end. So there are criteria like that. </span><br><span class="line"></span><br><span class="line">js allows you to create a new uninitialized array and then just suddenly index into it at whatever index.</span><br><span class="line"></span><br><span class="line">This, doesn&#39;t make any sense in C. It&#39;s not something you&#39;d actually do. And in V8, it will immediately trigger dictionary mode. So this, you will now have a nice, slow array to waok with, not something you want.</span><br><span class="line"></span><br><span class="line">So real simple change.</span><br><span class="line"></span><br><span class="line">All you have to do is declare how much storage you want up font.Now you have declared to V8 that you actually want an array of a certain size. V8 will back your array by a contigous array of that size, and you can go from there.</span><br><span class="line"></span><br><span class="line">Veay sensible, kind of no-brainerish, but again, Javascript allows you to do it in a way that ends up being very inefficient, so it&#39;s important to know.</span><br><span class="line"></span><br><span class="line">So that is the numeric representation and the immediate representation of objects.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">Object in V8 </span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">So objects in JavaScript are there very poorly defined things.</span><br><span class="line"></span><br><span class="line">They are associative arrays.</span><br><span class="line"></span><br><span class="line">They&#39;re just bundles of key value pairs of properties.</span><br><span class="line"></span><br><span class="line">So you have string balue for key, property value.</span><br><span class="line"></span><br><span class="line">And all property values are these undefined whatevers, because Javascript doesn&#39;t have a notion of type.</span><br><span class="line"></span><br><span class="line">Object have prototype chains. You can add and remove properties anywhere at the prototype chain and on the object inself at any point. </span><br><span class="line"></span><br><span class="line">Javascript doesn&#39;t enforce any specificity or structure in your code.</span><br><span class="line"></span><br><span class="line">So if you wanted to, you could make every single object in your whole program absolutely a unique set of properties.</span><br><span class="line"></span><br><span class="line">Nothing in Javascript will enforce structure or self-similarity.</span><br><span class="line"></span><br><span class="line">But just because JavaScript allows you to do that, you really,really shouldn&#39;t.</span><br><span class="line"></span><br><span class="line">That&#39;s actually a terrible thing to do for performance.</span><br><span class="line"></span><br><span class="line">And I&#39;ll explain why in a minute.</span><br><span class="line"></span><br><span class="line">So in V8,the V8 team looked at trying to write a large-scale application in JavaScript and thought, hey, you know what&#39;s important in large-scale systems is object-orientenness.</span><br><span class="line"></span><br><span class="line">And if you have object-orientenness in your system, then now, property access is one of the key things that you need to make fast. </span><br><span class="line"></span><br><span class="line">So V8 designed its structure to make property access on objects as efficient as it could be.</span><br><span class="line"></span><br><span class="line">So the internal representation of an object in V8 is three words.</span><br><span class="line"></span><br><span class="line">So first, we have a hidden class pointer, which is an internal notion of type, which I&#39;ll explain in a second.</span><br><span class="line"></span><br><span class="line">And then we have two pointers to different kinds of properties.</span><br><span class="line"></span><br><span class="line">We have properties that have string names and then properties that have int names. </span><br><span class="line"></span><br><span class="line">But really, the only thing that&#39;s important is your have a type, and then you have property storage.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So waht&#39;s this hidden class thing?</span><br><span class="line"></span><br><span class="line">So hidden classes, again, ther&#39;re V8&#39;s interbal notion of type.</span><br><span class="line"></span><br><span class="line">JavaScript itself isn&#39;t going to enforce any kind of notionof type on you.</span><br><span class="line"></span><br><span class="line">BUt in order to make things effcient, V8itself need to have some sort of structure in whst it things you&#39;re doing. </span><br><span class="line"></span><br><span class="line">So it introduces a type system.</span><br><span class="line"></span><br><span class="line">And that type system froups objects with the same structure.</span><br><span class="line"></span><br><span class="line">So as you&#39;re adding properties to objects, which you can do in JavaScript, V8 will be looking at the properties on each object and mapping ta&#x3D;hat bundle of properties to a hidden class, which defines an object with exactly those properties.</span><br><span class="line"></span><br><span class="line">So, dor instance, if I have this constructor in JavaScript where I have a point, and it has an x and y, and the way those values are added by first adding x to the object and then adding y, thay&#39;s going to generate a hidden class that backs objects that are created from this function that has exactle the properties x and y.</span><br><span class="line"></span><br><span class="line">And that really seems sort of obvious.</span><br><span class="line"></span><br><span class="line">But then, the first time this function is run, that hidden class is going to be built for the first time. And then, all subsequent times this dunction is run, those new objects can share the same hidden class.So you only pay the price for building it the very first time.</span><br><span class="line"></span><br><span class="line">After that, you can just use the same object.</span><br><span class="line"></span><br><span class="line">So we went through all this trouble of building up a notion of type.</span><br><span class="line"></span><br><span class="line">So now, we have types that correspond to specifically what exact </span><br><span class="line">properties are on an object.</span><br><span class="line"></span><br><span class="line">We can use taht notion of type to make property access quick using something called inline caching.</span><br><span class="line"></span><br><span class="line">So if yoiu want to look up a property on an object in Javascript, you&#39;re going to say, I am looking for property with name x on object y.</span><br><span class="line"></span><br><span class="line">The first thing you do whrn you&#39;re trying to look up a property is check the hidden class of the object.</span><br><span class="line"></span><br><span class="line">If you&#39;re never tried to look up that property on an object of that type before, then what you&#39;re going to have to do is a fully generic search for that property.</span><br><span class="line"></span><br><span class="line">So again, we just have a bundle of properties somewhere.</span><br><span class="line"></span><br><span class="line">They all have string names.</span><br><span class="line"></span><br><span class="line">You have a string of the property you&#39;re looking for.</span><br><span class="line"></span><br><span class="line">And you&#39;re going to have to look through taht list for the property that has a matching name.</span><br><span class="line"></span><br><span class="line">That&#39;s a pretty slow operation.</span><br><span class="line"></span><br><span class="line">But once you found thst property once, you can remember the offset to it. you can remember where you found that property and use it later, which means that you can use that to generate new optimized code which specifies how you look up that particular property on that particular object.</span><br><span class="line"></span><br><span class="line">And next time you want to look up property with that name on an object of that type, you can have direct access You know exactly where to go in an object of that type.</span><br><span class="line"></span><br><span class="line">And it&#39;s much much much faster.</span><br><span class="line"></span><br><span class="line">So thst&#39;s really what the notion of having hidden class is getting us, is now we can make property access really fast through inline caching.</span><br><span class="line"></span><br><span class="line">So this is a classic example of bad idea. </span><br><span class="line"></span><br><span class="line">function Vec2(x,y)&#123;</span><br><span class="line">this.x &#x3D; x;</span><br><span class="line">this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">var v0 &#x3D; new  Vec2(5,8);</span><br><span class="line">v0.z &#x3D; 34;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So I have another constructor. It&#39;s creating a vector object. </span><br><span class="line"></span><br><span class="line">But then, after I go through the trouble of doing that, I decide that I now wanted property z on this object.</span><br><span class="line"></span><br><span class="line">The problem with that is that if you add a property z to that object at some future point, if you just dynamically do that, you&#39;re going to change the hidden class of the object, which means that all this nice caching you&#39;re done and building up a notion of where the properties are, that&#39;s just blown away because now you have a new hidden class. </span><br><span class="line"></span><br><span class="line">You have to pay to build the new hidden class, and now you have to deal with a new hidden class.</span><br><span class="line"></span><br><span class="line">So one of the best things you can do to make you code efficient is to create a few well-defined types.</span><br><span class="line"></span><br><span class="line">Don&#39;t do alot of dynamic property adding and removing outside of constructors.</span><br><span class="line"></span><br><span class="line">Pretty much set things up once, have them look alike so that they can share the same hidden class, and don&#39;t mess with the properties they have.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">Object properties storage</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">So now we know an object has properties.</span><br><span class="line"></span><br><span class="line">those properties can be in different storage states.</span><br><span class="line"></span><br><span class="line">So the first state ,the default, is that they can be stored directly in an array on the object.</span><br><span class="line"></span><br><span class="line">that great, that&#39;s fast. that&#39;s where you want to be. </span><br><span class="line"></span><br><span class="line">A second state they can be in is being stored in array off the objects. still great. No problem.</span><br><span class="line"></span><br><span class="line">The third case, which is the one you really have to look out for, is when they&#39;re stored in a hash table.</span><br><span class="line"></span><br><span class="line">So mush like just the array case in general where arrays can have different types of backing storage, properties can have different types of backing storage too.</span><br><span class="line"></span><br><span class="line">So properties can either be in normal mode where they&#39;re stored as an array or a dictionary mode where they&#39;re stored as a hash table. </span><br><span class="line"></span><br><span class="line">And if you have an object in dictionary mode, it&#39;s going to be mush slower to interact with.</span><br><span class="line"></span><br><span class="line">So you don&#39;t want that.</span><br><span class="line"></span><br><span class="line">So what triggers dictionary mode ,and how do you avoid it? Well, one thing that triggers itis toomany properties.</span><br><span class="line"></span><br><span class="line">So if you have so many properties that they won&#39;t fit into the internal storage for properties, then you have to have a hash table elsewhere. And that number of too many properties is somewhere around 30. It&#39;s quite generous, but you mighe hit it in some cases.</span><br><span class="line"></span><br><span class="line">The other things you can do to confuse your object and kick it into dictionary mode are to change the properties on the object.</span><br><span class="line"></span><br><span class="line">You can change the attribute, you can delete properties, that kind of thing. Those things are all going to kick you straight to dictionary mode.</span><br><span class="line"></span><br><span class="line">Again, and now you&#39;re going to make your object mush slower to interact with.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前对&lt;a class=&quot;link&quot;   href=&quot;http://www.feidom.com/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4
      
    
    </summary>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>js对象你不知道的那些特点</title>
    <link href="https://feidom-up.github.io/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/"/>
    <id>https://feidom-up.github.io/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/</id>
    <published>2021-08-09T01:36:22.000Z</published>
    <updated>2024-08-22T02:26:03.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="js对象的“快-慢”属性"><a href="#js对象的“快-慢”属性" class="headerlink" title="js对象的“快/慢”属性"></a>js对象的“快/慢”属性</h4><p>定义一个obj，它是下面这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">5</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">'2'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'6'</span>,</span><br><span class="line">  <span class="string">'qwf'</span>: <span class="string">'乔文飞'</span>,</span><br><span class="line">  <span class="string">'yy'</span>: <span class="string">'qwf'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init初始化时，属性会尽量归为“快”属性，同时也会存在“慢”属性。<br>那么它在js中，为了有效的提升存储和访问属性的性能，js对慢属性的存储是下图这样的。<br><img src="http://i.feidom.com/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" alt="对象属性"></p><ul><li>快属性：直接加在对象内属性上，方便读取。</li><li>慢属性：加载排序或常规属性上，方便操作。（在对象设置属性时，会加到慢属性）</li></ul><p>Q：为啥慢？<br>A：多了一层深度，影响数据操作，多了Element层和Properties层。</p><p>Q：为啥不直接都存在内属性上？<br>A：在内属性中，obj越来越大，影响存储。（以前内属性只能动态设置10个，现在不止-硬件加强等原因）</p><h4 id="js数组的“快-慢”数组"><a href="#js数组的“快-慢”数组" class="headerlink" title="js数组的“快/慢”数组"></a>js数组的“快/慢”数组</h4><ul><li>快数组：线性结构，连续内存（动态扩容），当定义初始化长度小于1024时，属于快数组</li><li>慢数组：定义长度大于1024时，需要维护额外的哈希米表。</li></ul><p>由快到慢：</p><ol><li>定义长度大于1024时。动态扩容时，length*1.5+16以上。</li><li>快数组的新容量时扩容容量的3倍以上时。</li></ol><p>由慢到快：</p><ol><li>数量在1024内</li><li>容量一下缩减50%。<br>减容时，新数组长度是原来长度的1/2，就计算需要释放的空间，做好标记，等待GC回收。<br>如果1/2 &lt; length &lt; 1,用holes对象填充，holes太多也是慢数组。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;js对象的“快-慢”属性&quot;&gt;&lt;a href=&quot;#js对象的“快-慢”属性&quot; class=&quot;headerlink&quot; title=&quot;js对象的“快/慢”属性&quot;&gt;&lt;/a&gt;js对象的“快/慢”属性&lt;/h4&gt;&lt;p&gt;定义一个obj，它是下面这样的&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>js上下文执行机制</title>
    <link href="https://feidom-up.github.io/2021/08/09/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://feidom-up.github.io/2021/08/09/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-09T00:28:01.000Z</published>
    <updated>2024-08-22T02:26:03.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><ul><li>ECS(Execute Context Stack): js函数执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。</li><li>GC(Global Context): 全局上下文。</li><li>GO(Global Context): 全局上下文生成的对象。</li><li>VO(Var Object): 声明时对象。</li><li>AO(Action Object): 执行时对象。</li></ul><p><img src="http://i.feidom.com/%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="看下这张图"></p><p>在AO执行时，分为两个阶段：</p><ul><li>变量定义：AO的准备阶段，es6之前的<strong>变量提升</strong>就在这个阶段</li><li>变量赋值。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">GC:&#123;</span><br><span class="line">  lexicalEnvironment: &#123; <span class="comment">// 词法环境</span></span><br><span class="line">    EnvironmentRecord: &#123; <span class="comment">// 环境记录</span></span><br><span class="line">      Type: <span class="string">"Object"</span>,</span><br><span class="line">      &#123;...&#125;, <span class="comment">// 标识符什么的其他信息</span></span><br><span class="line">      outer: <span class="literal">null</span>, <span class="comment">// 全局上下文没有引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  variablesEnvironment:&#123; <span class="comment">// 变量环境</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行上下文 Function Exection Context</span></span><br><span class="line">EC:&#123;</span><br><span class="line">  lexicalEnvironment: &#123; <span class="comment">// 词法环境</span></span><br><span class="line">    EnvironmentRecord: &#123; <span class="comment">// 环境记录</span></span><br><span class="line">      Type: <span class="string">"Declarative"</span>, <span class="comment">//函数环境</span></span><br><span class="line">      &#123;...&#125;, <span class="comment">// 标识符什么的其他信息</span></span><br><span class="line">      outer: <span class="string">'&lt;Global outer&gt;, &lt;function enviroment reference&gt;,'</span>, <span class="comment">// 对全局环境或外部函数环境的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  variablesEnvironment:&#123; <span class="comment">// 变量环境</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了适配早起的ES5的var等，增加了变量环境。变量环境也是一个词法环境，其环境记录其包含了由变量声明语句。<br>在ES6中，词法环境记录器和变量环境记录器的区别在于：</p><ul><li>词法环境：用于存储函数声明和变量（let，const）的绑定。</li><li>变量环境：仅用于存储变量（var）的绑定</li></ul><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul><li>scope chain：作用域链<br>其实就是在 [AO,GC,VO] 时。</li><li><em>闭包原理*</em> 在作用域scope堆空间中存储closore(fn)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;执行上下文&quot;&gt;&lt;a href=&quot;#执行上下文&quot; class=&quot;headerlink&quot; title=&quot;执行上下文&quot;&gt;&lt;/a&gt;执行上下文&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ECS(Execute Context Stack): js函数执行上下文从逻辑上形成一个栈。栈底总是全
      
    
    </summary>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="js原理" scheme="https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OT在线协作</title>
    <link href="https://feidom-up.github.io/2021/08/05/ot%E5%8D%8F%E4%BD%9C/"/>
    <id>https://feidom-up.github.io/2021/08/05/ot%E5%8D%8F%E4%BD%9C/</id>
    <published>2021-08-05T01:57:07.000Z</published>
    <updated>2024-08-22T02:26:03.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OT协作思想"><a href="#OT协作思想" class="headerlink" title="OT协作思想"></a>OT协作思想</h4><p><strong>解决冲突</strong></p><p>A, B两个用户在协作同一段初始文本：’aaab’。<br>冲突操作：<br>  A在第3个字符后面插入了一个<code>c</code>(‘aaacb’)。<br>  B在第3个字符后面插入了一个<code>d</code>(‘aaadb’)。</p><p>若A先提交，ot后正确结果：’aaacdb’。<br>？为什么不是按顺序的’aaadcb’。因为不是顺序执行，产生冲突时，为保证双方操作最大程度得到保存，ot协作后，B的操作实际变为在第4个子都后插入。<br>A视角：A的结果’aaacb’被B拿去操作，结果’aaadcb’。<br>B视角：B的结果’aaadb’被A拿去操作，结果’aaacdb’。可见这个结果是正确结果。</p><p>后台聪明的ot转发功能就是把每个人提交的行为转变一下再告诉别人，两方的结果就一致了。其实这个技术就是 OT 算法：<br>A接收到的B操作：’在第3个字符后面插入了一个<code>d</code>‘  ==ot==&gt; ‘aaacb在第4个字符后面插入了一个<code>d</code>‘(aaacdb)<br>B接收到的A操作：’在第3个字符后面插入了一个<code>c</code>‘  ==ot==&gt; ‘aaadb在第3个字符后面插入了一个<code>c</code>‘(aaacdb)</p><p>OT 算法全名叫 Operation Transformation，你看从名字就对应了上面我说的转变算法。<br>假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A’,B’。<br>也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A’行为告诉 B，把 B’行为告诉 A，这样大家再应用就相安无事了。</p><p>核心公式：apply(apply(S,A),B) = apply(apply(S,B),A)<br>S:开始状态<br>A：A的操作A<br>B：B的操作B<br>冲突时，A执行完自己的操作后，再执行经OT转换的B操作。与B执行完自己的操作，再执行经OT转换的A操作，双方的结果是一致的。<br>图示：<br><img src="http://www.alloyteam.com/wp-content/uploads/2019/07/0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png" alt="ot"></p><p><a class="link"   href="http://operational-transformation.github.io/"  target="_blank" rel="noopener">一个演示OT的小网站<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>参考:<a class="link"   href="http://www.alloyteam.com/2019/07/13659/"  target="_blank" rel="noopener">揭开在线协作的神秘面纱-OT算法<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OT协作思想&quot;&gt;&lt;a href=&quot;#OT协作思想&quot; class=&quot;headerlink&quot; title=&quot;OT协作思想&quot;&gt;&lt;/a&gt;OT协作思想&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;解决冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A, B两个用户在协作同一段初始文本：’aaab’
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://feidom-up.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://feidom-up.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="OT" scheme="https://feidom-up.github.io/tags/OT/"/>
    
  </entry>
  
  <entry>
    <title>从props的children中获取ref</title>
    <link href="https://feidom-up.github.io/2021/07/12/%E4%BB%8Eprops%E7%9A%84children%E4%B8%AD%E8%8E%B7%E5%8F%96ref/"/>
    <id>https://feidom-up.github.io/2021/07/12/%E4%BB%8Eprops%E7%9A%84children%E4%B8%AD%E8%8E%B7%E5%8F%96ref/</id>
    <published>2021-07-12T09:46:29.000Z</published>
    <updated>2024-08-22T02:26:03.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从props-children中处理ref"><a href="#从props-children中处理ref" class="headerlink" title="从props.children中处理ref"></a>从<code>props.children</code>中处理ref</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetRef</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ref);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> childElement = React.Children.only(<span class="keyword">this</span>.props.children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">      childElement, </span><br><span class="line">      &#123; <span class="attr">ref</span>: <span class="function"><span class="params">el</span> =&gt;</span> <span class="keyword">this</span>.ref = el &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GetRef</span>&gt;</span><span class="tag">&lt;<span class="name">Child</span>/&gt;</span><span class="tag">&lt;/<span class="name">GetRef</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结合转发ref将ref绑定到children组件中的div中"><a href="#结合转发ref将ref绑定到children组件中的div中" class="headerlink" title="结合转发ref将ref绑定到children组件中的div中"></a>结合转发ref将ref绑定到children组件中的div中</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Com组件</span></span><br><span class="line">interface Props &#123;</span><br><span class="line">  forwardedRef: ref | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;forwardedRef&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div ref=&#123;forwardedRef&#125;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">  &#125; </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const forwardRefCom =  React.forwardRef((props, ref) =&gt; (</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Com</span> <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">  ));</span></span><br><span class="line"><span class="xml">return forwardRefCom;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从props-children中处理ref&quot;&gt;&lt;a href=&quot;#从props-children中处理ref&quot; class=&quot;headerlink&quot; title=&quot;从props.children中处理ref&quot;&gt;&lt;/a&gt;从&lt;code&gt;props.children&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react的转发ref</title>
    <link href="https://feidom-up.github.io/2021/07/12/react%E7%9A%84%E8%BD%AC%E5%8F%91ref/"/>
    <id>https://feidom-up.github.io/2021/07/12/react%E7%9A%84%E8%BD%AC%E5%8F%91ref/</id>
    <published>2021-07-12T09:18:41.000Z</published>
    <updated>2024-08-22T02:26:03.660Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h4><p>使用通用的高阶组件时，外层组件ref控制高阶组件中包裹的子组件中的元素，此时外层组件传入的ref并不作用于高阶上，这个时候，高阶组件就要用到<code>React.forwardRef</code>进行ref转发。</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a class="link"   href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"  target="_blank" rel="noopener">React.forwardRef<i class="fas fa-external-link-alt"></i></a></p><h4 id="简单举栗🌰"><a href="#简单举栗🌰" class="headerlink" title="简单举栗🌰"></a>简单举栗🌰</h4><p>🌰栗子 来自<a class="link"   href="https://www.jianshu.com/p/ea89610dbbfd"  target="_blank" rel="noopener">JamesSawyer—-React 中的转发ref<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'先前的属性：'</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'当前属性：'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 使用forwardedRef作为一个ref属性传入组件中</span></span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用React.forwardRef对LogProps组件进行转发</span></span><br><span class="line">  <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    &#123;<span class="string">' 上面定义的LogProps组件接受一个forwarded属性 '</span>&#125;</span><br><span class="line">    &lt;LogProps forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FancyButton.js 子组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> logProps <span class="keyword">from</span> <span class="string">'./logProps'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受props和ref作为参数</span></span><br><span class="line"><span class="comment">// 返回一个React 组件</span></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"fancybutton"</span> ref=&#123;ref&#125;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用高阶组件对其进行封装</span></span><br><span class="line"><span class="regexp">export default logProps(FancyButton);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父组件</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ app.js</span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 创建一个ref 名字随意</span></span><br><span class="line"><span class="regexp">    this.ref = React.createRef();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('ref', this.ref);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ this.ref.current 表示获取ref指向的DOM元素</span></span><br><span class="line"><span class="regexp">    this.ref.current.classList.add('primary'); /</span><span class="regexp">/ 给FancyButton中的button添加一个class</span></span><br><span class="line"><span class="regexp">    this.ref.current.focus(); /</span><span class="regexp">/ focus到button元素上</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 直接使用ref=&#123;this.fancyButtonRef&#125;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;FancyButton ref=&#123;this.fancyButtonRef&#125;&gt;子组件&lt;/</span>FancyButton&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简单理解&quot;&gt;&lt;a href=&quot;#简单理解&quot; class=&quot;headerlink&quot; title=&quot;简单理解&quot;&gt;&lt;/a&gt;简单理解&lt;/h4&gt;&lt;p&gt;使用通用的高阶组件时，外层组件ref控制高阶组件中包裹的子组件中的元素，此时外层组件传入的ref并不作用于高阶上，这个时候，
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React-防止内存泄漏处理</title>
    <link href="https://feidom-up.github.io/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/"/>
    <id>https://feidom-up.github.io/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/</id>
    <published>2021-06-18T05:40:49.000Z</published>
    <updated>2024-08-22T02:26:03.658Z</updated>
    
    <content type="html"><![CDATA[<p>用React写了一段代码，浏览器的控制台<font color=red size=5>Error </font>如下：<br><font color=red>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</font></p><p>啥意思呢：不能在未挂载的组件上执行React状态更新。这是一个无用功，但它表明你的应用程序中存在内存泄漏。要解决这个问题，在useEffect清理函数中取消所有的订阅和异步任务。</p><p>以下是这段问题代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; itemId &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [ isRemoveing, setIsRemoveing ] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> handlerRemove = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(isRemoveing) <span class="keyword">return</span>;</span><br><span class="line">    setIsRemoveing(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">await</span> removeItem(itemId); <span class="comment">// 删除当前这个组件的数据，这个组件卸载</span></span><br><span class="line">    setIsRemoveing(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div class_name=&#123; !isRemoveing ? <span class="string">'class1'</span> : <span class="string">'class2'</span> &#125; onClick=&#123;handlerRemove&#125; &gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因是啥呢</strong>：await等待一个异步请求的返回再<code>setIsRemoveing</code>。假如这个组件unmounted之后，请求还没回来，你还在这setState，不就炸了。</p><p>好吧，那解决方式是不是在<code>useEffect</code>中定义一个卸载时的变量<code>unmounted</code>，然后在setIsRemoveing时判断卸载状态？</p><p>嗯，基本是这个思路。那这个<code>unmounted</code>该怎么定义，是直接<code>const unmounted = false;</code>, 还是<code>const [ unmounted, setUnmounted ] = useState(false);</code>？<br>以下是Stack Overflow里一个帖子的回复：</p><ul><li>方式一：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> unmounted = <span class="literal">false</span>;</span><br><span class="line">  setPageLoading(<span class="literal">true</span>);</span><br><span class="line">  props</span><br><span class="line">    .dispatch(fetchCourses())</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        toast.error(error);</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted = <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li>方式二：useRef<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> unmounted = useRef(<span class="literal">false</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted.current = <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setFilter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    props.dispatch(fetchCourses()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted.current) &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ReactTable onFetchData=&#123;setFilter&#125; <span class="comment">/* other props omitted */</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>方式二中如果不用ref，用state或者直接定义变量的话，都实现不了。<br>好吧，是我不熟悉的<a class="link"   href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref"  target="_blank" rel="noopener">useRef<i class="fas fa-external-link-alt"></i></a>,这个链接是官方文档，可以先看下。<br>然后为了研究它，我找到一篇来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<a href="/2021/06/18/useEffect-useRef/">这里</a>是我对这篇文章的翻译，仅供参考。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a class="link"   href="https://daviseford.com/blog/2019/07/11/react-hooks-check-if-mounted.html"  target="_blank" rel="noopener">React Hooks - Check If A Component Is Mounted<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/58038008/how-to-stop-memory-leak-in-useeffect-hook-react/58038029"  target="_blank" rel="noopener">how-to-stop-memory-leak-in-useeffect-hook-react<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用React写了一段代码，浏览器的控制台&lt;font color=red size=5&gt;Error &lt;/font&gt;如下：&lt;br&gt;&lt;font color=red&gt;Warning: Can’t perform a React state update on an unmounte
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>useEffect &amp; useRef</title>
    <link href="https://feidom-up.github.io/2021/06/18/useEffect-useRef/"/>
    <id>https://feidom-up.github.io/2021/06/18/useEffect-useRef/</id>
    <published>2021-06-18T01:58:48.000Z</published>
    <updated>2024-08-22T02:26:03.661Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>本文是一片翻译，原文来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<br>为啥翻译并记录这篇文章呢，因为看了以后觉得通俗易懂的为凡人解释了<code>useEffect</code>和<code>useRef</code>。<br>在此记录，方便以后回头复习。</p><h4 id="通俗的解释React的-useEffect-和-useRef"><a href="#通俗的解释React的-useEffect-和-useRef" class="headerlink" title="通俗的解释React的 useEffect 和 useRef"></a>通俗的解释React的 useEffect 和 useRef</h4><p><img src="https://leewarrick.com/blog/static/fdb92914fc9093dee6a2c20dad8fbd50/c35de/acropolis.jpg" alt="原文中过的图"><br>&emsp;&emsp;如果React文档让你一筹莫展，或者Dan Abramov的博客让你觉得你在阅读从奥林匹斯山流传下来的古希腊文卷轴，你并不孤单,不是只有你这样认为。<br>&emsp;&emsp;有时，React神殿的众神们很难将他们的智慧转化为我们其他人可以理解的语言。事情通常是这样的。你在使用React时遇到困难，用谷歌搜索你的问题，然后读到一个博客或Stack Overflow的帖子，其中的一些建议让你感到比开始时更迷茫。<br>&emsp;&emsp;我当然也曾多次成为这种情况的受害者。特别是useEffect。在我们深入研究这个特殊的钩子之前，让我说我喜欢用hooks来写React，而且不想再回到类中去。这就是说，useEffect是一个很大的痛点。</p><h6 id="到底什么是“effect副作用”"><a href="#到底什么是“effect副作用”" class="headerlink" title="到底什么是“effect副作用”"></a>到底什么是“effect副作用”</h6><p>&emsp;&emsp;为了让你真正理解useEffect，让我们退后一点，谈谈编程和JavaScript。<br>&emsp;&emsp;useEffect的名字就是我们亲切地称为 “副作用 “的效果。<br>&emsp;&emsp;那么什么是副作用呢？它是一段代码，它伸出手来……做别的事情。这是一个抽象的概念，所以让我们用例子来说明。<br>&emsp;&emsp;这里有一个没有副作用的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数add除了接受一个输入并返回一个输出外，什么也没做。它并没有伸手到自身以外的地方去捣乱!<br>&emsp;&emsp;我们来介绍一个副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="built_in">document</span>.getElementById(<span class="string">'add-example'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = a + b</span><br><span class="line">  resultDiv.textContent = <span class="string">`The Result is <span class="subst">$&#123;result&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;add-example&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在，我们的函数伸到了自身之外来更新DOM（Document Object Model的缩写），并显示了结果。这个额外的行为是一个副作用。</p><h6 id="React中的副作用"><a href="#React中的副作用" class="headerlink" title="React中的副作用"></a>React中的副作用</h6><p>&emsp;&emsp;那么React呢？它是一个几乎只更新DOM的库。一个视图库，如果你愿意的话。那么在React中，你会把什么叫做副作用呢？<br>&emsp;&emsp;任何在更新页面之外的东西。如果你不使用React来更新状态或渲染HTML，那就是一个副作用。它是任何非React的东西。<br>&emsp;&emsp;这意味着任何时候你调用API，使用setInterval/setTimeout，添加键盘监听器，或者真的任何时候你搞乱窗口对象，你都在引入副作用。<br>&emsp;&emsp;hooks很神奇，让你写出真正可读、可重用的代码……除了当你处理副作用的时候。这很不幸，因为当你仔细想想，作为网络开发者，我们所做的大多数有趣的事情都是围绕着副作用展开的。<br>&emsp;&emsp;让我们从钩子上退一步，看看我们如何在基于类的组件中处理副作用。</p><h6 id="类组件和副作用"><a href="#类组件和副作用" class="headerlink" title="类组件和副作用"></a>类组件和副作用</h6><p>&emsp;&emsp;在基于类的组件中，我们会使用生命周期方法来执行侧面效果。例如，在componentDidMount上，我们会调用API来获取渲染的数据。<br>&emsp;&emsp;”为什么不在构造函数中调用API？”你可能会问。好吧，因为React说我们用于渲染的东西都在 “状态 “中，在我们的组件被加载到页面上之前，我们不能乱用状态。如果我们试图在组件加载之前更新状态，就会出现错误。<br>&emsp;&emsp;下面是一个典型的基于类的组件的情况,这是一个小精灵的例子（后面会用hooks改写）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> pokemon = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &#123; pokemon</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">          &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">            Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        : <span class="string">'Loading...'</span></span><br><span class="line">      &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样做很好，除了不这样做的时候。当我们想再次点击API来抓取不同的小精灵时会发生什么？如果这个组件被连接到我们的应用程序中的某个路由上，而这个路由发生了变化，但这个组件并没有卸载/重装。如果用户进入了不同的页面，而组件在API调用结束前就卸载了怎么办？<br>&emsp;&emsp;答案是增加更多的生命周期方法，如<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以执行更多的API调用，防止奇怪的卸载错误。所以我们添加了这些生命周期方法来处理我们所有的边缘情况。当我们完成后，我们发现我们的大部分组件都是由生命周期代码组成的。</p><h5 id="然后来试一下Hooks"><a href="#然后来试一下Hooks" class="headerlink" title="然后来试一下Hooks"></a>然后来试一下Hooks</h5><p>&emsp;&emsp;React团队意识到，类的API有点笨重，难以推理。人们正在制作生命周期流程图，试图了解React的内部运作……这是一个混乱。<br>&emsp;&emsp;因此，在2018年10月的ReactConf上，在Sophie Alpert概述了类的使用有多么糟糕之后，Dan Abramov上台介绍了钩子（你可以在这里观看视频）。<br>&emsp;&emsp;钩子在功能组件中引入了状态性，以及处理副作用的新方法。钩子使React的代码更容易重复使用，而且代码量更少–这是一个巨大的胜利！但是有一个小问题。<br>&emsp;&emsp;除了一个小问题。<strong>每次渲染，整个组件/功能都要重新运行</strong>。<br>&emsp;&emsp;让我们看一个基于Hooks开发的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RerenderExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [bool, setBool] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> randomNum = <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;This number will be different each time you click the button:&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setBool(!bool)&#125;&gt;Trigger a render&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在渲染的JSX中甚至没有使用bool，但每次状态改变时，整个函数都会运行。每次渲染，组件内的所有东西都会重新运行：函数定义、变量创建/分配等等。<br>&emsp;&emsp;如果你在想 “如果我必须在组件中做一些计算量大的事情怎么办？这不可能是高性能的……”，这是个敏锐的观察。在一个功能性组件中进行昂贵的操作是不可能有性能的。事实上，useCallback和useMemo的存在正是为了解决这个问题而设置的避难所。Kent C Dodds在这里对这些问题有一个挑战性的解读，但总结起来，根据Kent的说法，在你看到性能影响之前，你不应该担心重读的问题。</p><blockquote><p>注意：如果你对钩子不熟悉，请把这篇文章收藏起来，等你准备好了再来看看。除非你必须要担心记忆化的问题<br>&emsp;&emsp;像useState这样的钩子采用了一些内在的魔法来避免重现的问题。这很好，而且使用useState似乎很简单，但是<strong>当你需要做设置状态以外的事情时，怎么办？</strong><br>&emsp;&emsp;使用useEffect。那些讨厌的生命周期方法没有了，万岁！然而，这个钩子也有它自己的奇怪之处。首先让我们来看看语法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//accepts two arguments: a function, and dependency array</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; <span class="comment">//function to undo our stuff from above when component unmounts</span></span><br><span class="line">&#125;, []) <span class="comment">//dependency array of things to watch for changes on</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以你给useEffect传递一个要运行的回调函数，其中包含你的副作用，然后是一个要观察的事物的数组。如果被监视的事物发生变化，useEffect将重新运行我们的回调函数。如果你需要在卸载时清理你的副作用，返回一个包含该代码的函数。<br>&emsp;&emsp;让我们看看我们的小精灵的例子，用钩子和useEffect。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, []) <span class="comment">// empty array means nothing to watch, so run once and no more</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果你盯着那个空的依赖性数组，你已经注意到了第一个useEffect的怪癖。通过传递一个空数组，我们在说 “只做这一次”。React万神殿告诉我们，在极少数情况下这是可以的，但大多数时候你都希望里面有东西。原因是，通常你想与你的代码中的东西同步，而不是只执行一次效果。例如，如果我们的小精灵组件依赖于一个路由参数或道具，任何可以说 “去获得一个新的小精灵 “而不需要挂载/卸载的东西呢？<br>&emsp;&emsp;比方说，我们的组件依赖于一个道具pokemonToGet，它是一个参数，告诉它要从API中获得哪些小精灵。让我们也为测试目的添加一个小小的表单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params">&#123;pokemonToGet&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">`https://pokeapi.co/api/v2/pokemon/<span class="subst">$&#123;pokemonToGet&#125;</span>/`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [pokemonToGet]) <span class="comment">// get a new pokemon with the pokemonToGet prop changes</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">          alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function PokemonForm() &#123;</span></span><br><span class="line"><span class="regexp">  const [inputValue, setInputValue] = React.useState("rowlet")</span></span><br><span class="line"><span class="regexp">  const [pokemonToGet, setPokemonToGet] = React.useState("gengar")</span></span><br><span class="line"><span class="regexp">  function getPokemon() &#123;</span></span><br><span class="line"><span class="regexp">    setPokemonToGet(inputValue.trim().toLowerCase())</span></span><br><span class="line"><span class="regexp">    setInputValue("")</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input onChange=&#123;(e) =&gt; setInputValue(e.target.value)&#125;</span></span><br><span class="line"><span class="regexp">        value=&#123;inputValue&#125; type="text"/</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;getPokemon&#125;&gt;</span><br><span class="line">        Get Pokemon</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Pokemon pokemonToGet=&#123;pokemonToGet&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">render(&lt;PokemonForm /</span>&gt;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很好，现在我们的组件根据我们的道具变化获取了一个新的小精灵。如果使用类，我们就必须使用<code>componentDidUpdate</code>之类的东西来达到类似的效果。<br>&emsp;&emsp;Ryan Florence在推特上对useEffect的用法做了很好的总结。</p><blockquote><p>The question is not “when does this effect run” the question is “with which state does this effect synchronize with”<br>  useEffect(fn) // all state<br>  useEffect(fn, []) // no state<br>  useEffect(fn, [these, states])</p></blockquote><p>&emsp;&emsp;他提到的 “所有状态 “的情况，即你没有传入任何依赖关系的情况是一个奇怪的情况。我个人从未发现它的用途。我们知道整个组件在每次渲染时都会运行，所以我想知道是否有一些奇怪的边缘情况需要你使用<code>useEffect(fn)</code>而不使用任何依赖阵列。在任何情况下，大多数时候你都会用这个方法：<code>useEffect(fn, [these, states])</code>。</p><h5 id="UseEffect和Previous-State-事情败露的地方。"><a href="#UseEffect和Previous-State-事情败露的地方。" class="headerlink" title="UseEffect和Previous State: 事情败露的地方。"></a>UseEffect和Previous State: 事情败露的地方。</h5><p>&emsp;&emsp;到目前为止，useEffect的心理模型似乎很简单：将它与你选择的某些状态变化同步。问题是，当你需要在一个效果中引用该状态，而不仅仅是知道它是否发生了变化。<br>&emsp;&emsp;在useEffect中，你无法获得对当前状态的访问。<br>&emsp;&emsp;在我们的API调用例子中，我们没有看到这一点，因为我们只是覆盖了之前的状态。<br>&emsp;&emsp;让我们看一个简单的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;似乎我们做了所有正确的事情（甚至清理了卸载时的副作用），但我们的计数器没有递增。这是一个问题吗？我们是否无法访问setInterval所属的窗口对象？<br>&emsp;&emsp;不是，也不是。如果你把console.log添加到那个间隔中，你会看到它每秒钟都在跳动。<br>&emsp;&emsp;我可以证明给你看:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [randomNum, setRandomNum] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">      setRandomNum(<span class="built_in">Math</span>.random())</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;RandomNum is &#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，我们每秒钟都会得到一个新的随机数。我们的时间间隔代码是好的。<br>&emsp;&emsp;我们能够设置新的状态，但无法访问当前状态。<br>&emsp;&emsp;这就是一个 “陈旧的闭包”。我不会去讨论闭包，但只需知道，由于React/hooks的实现，在我们的间隔函数中，count变量总是会是0。这是一个旧的参考。<br>&emsp;&emsp;事实证明，像上面这样的简单例子有一个解决方案，正如John Tucker所指出的（谢谢John！）。和基于类的组件中的setState一样，useState也可以接受一个回调函数，接收之前的状态作为一个参数。React文档也注意到了这一点。<br>&emsp;&emsp;下面是一个快速修复的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//let's pass a function instead</span></span><br><span class="line">      <span class="comment">//the argument is the current state</span></span><br><span class="line">      setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过，这仍然不能解决我们所有的问题。如果你需要在useEffect中访问最新的状态，但不更新它，你将不得不开始用setState回调来包装你的useEffect代码，然后在最后返回未改变的状态。这很快就会变成一个绝对的混乱，特别是当你在处理多个状态值的时候。<br>&emsp;&emsp;另一个可能的解决方案是只使用useReducer，因为它可以接收之前的状态，但是用副作用填充你的reducer也显得非常混乱，而且我不建议任何人完全停止使用useState。<br>&emsp;&emsp;无论如何，在写钩子的时候，我已经陷入了陈旧的闭包陷阱很多很多次。我甚至不知道它有个名字，直到我在Svelte背后的人Rich Harris的演讲中看到它<br>&emsp;&emsp;显然，我也不是唯一一个在钩子上被它们绊倒的人。<br><img src="https://leewarrick.com/blog/static/5a5dbcc6667a5da9eeabc5cbe90a1427/ed46b/staleclosures.png" alt="Rich Harris的"><br>&emsp;&emsp; <strong>React甚至在他们的文档中提到了这一点。</strong></p><blockquote><p>“Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in.”<br>  译：组件内的任何功能，包括事件处理程序和效果，都能 “看到 “它所创建的渲染中的道具和状态。<br>&emsp;&emsp;我之前读过这个，在真正深入了解这个问题之前，我觉得没什么意义。我想象这可能是React的一个不好的点，所以也许他们不希望太大声地叫出来。<br>&emsp;&emsp;然而，Dan Abramov在他的博客中更好地描述了这个问题，甚至提供了一个解决方案。<br>“Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref.”<br>  译：效果总是 “看到 “它们所定义的渲染中的道具和状态。这有助于防止bug，但在某些情况下会很烦人。对于这些情况，你可以明确地在一个可变的上下文中保存一些值。</p></blockquote><p>&emsp;&emsp;这很有帮助，因为它以useRef的形式提供了一个解决方案（感谢Dan！），但它让我对如何帮助避免这个问题一无所知（主要是因为我不了解useRef）。</p><h5 id="什么是“ref”，你会怎么使用它"><a href="#什么是“ref”，你会怎么使用它" class="headerlink" title="什么是“ref”，你会怎么使用它"></a>什么是“ref”，你会怎么使用它</h5><p>&emsp;&emsp;传统上，引用的目的是让你直接访问一个html元素。例如，假设你需要关注一个输入字段。你必须跳出React，使用常规的JavaScript来调用.focus()。钩子实际上让这一切变得相当简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = React.useRef()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;</span><br><span class="line">        Click to Focus the input</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很好! 当我们需要的时候，Refs是访问本地DOM APIs的一个简单的逃生通道。<br>&emsp;&emsp;…但这如何帮助我们解决我们陈旧的关闭计数器的例子呢？</p><h5 id="使用“Refs”来避免陈旧的闭包"><a href="#使用“Refs”来避免陈旧的闭包" class="headerlink" title="使用“Refs”来避免陈旧的闭包"></a>使用“Refs”来避免陈旧的闭包</h5><p>&emsp;&emsp;React文档将“Refs”比作 “实例变量”。我不知道那是什么意思（谢谢维基百科），所以我觉得那没什么用。<br>&emsp;&emsp;我设法通过这样思考来理解Refs的含义。<br>&emsp;&emsp;<strong>Refs存在于重新渲染周期之外。</strong><br>&emsp;&emsp;<strong>把Refs看作是你设置在一边的一个变量。当你的组件重新运行时，它会很高兴地跳过这个反射，直到你用<code>.current</code>调用它。</strong><br>&emsp;&emsp;让我们看看对我们的定时器例子的修正。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们想把计时器停在比如说10的位置，我们可以很容易地用refs来做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (countRef.current === <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId)</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了便于比较，这里是使用setState回调方法的替代方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count === <span class="number">10</span>) &#123;</span><br><span class="line">            clearInterval(intervalId)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这很快就会接近回调地狱，所以如果你在做更复杂的事情，我会提醒你不要使用回调方法。</p><h5 id="State-Versus-Refs"><a href="#State-Versus-Refs" class="headerlink" title="State Versus Refs"></a>State Versus Refs</h5><p>&emsp;&emsp;是否有可能完全抛弃状态而只使用refs？<br>&emsp;&emsp;你可能倾向于认为你可以用 refs 来代替你的组件的状态，从而避开所有这些奇怪的行为。<br>&emsp;&emsp;你不能这样做。refs不是反应性的。当你改变一个 ref 时，它不会导致重新渲染。记住，<strong>它们存在于重新渲染周期之外</strong>。<br>&emsp;&emsp;以下是不可能的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      count.current = count.current + <span class="number">1</span></span><br><span class="line">      <span class="comment">//console.log('Ref example count: ' + count.current)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count.current&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那个组件实际上是在内部进行计数，但它并没有导致HTML的更新。你需要useState来实现这一点。如果你不相信我的话，请继续取消对console.log的注释）。<br>&emsp;&emsp;这里有一个例子来证明Refs与state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;State Count: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment State Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;p&gt;Ref Count: &#123;countRef.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; countRef.current = countRef.current + 1&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment Ref Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(&lt;Counter/</span>&gt;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在你通过设置状态触发重新渲染之前，你不会看到Ref计数的变化。</p><h5 id="离别感言"><a href="#离别感言" class="headerlink" title="离别感言"></a>离别感言</h5><p>&emsp;&emsp;我喜欢React中的钩子和功能组件，但我所概述的怪异现象让我暂停了。我不喜欢被要求对React的内部工作了解这么多才能使用它。我认为这给学习React的人带来了障碍，我希望将来React团队能想出一些更好的方法来处理这些问题。</p><h4 id="翻译结束"><a href="#翻译结束" class="headerlink" title="翻译结束"></a>翻译结束</h4><p>很棒的文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h4&gt;&lt;p&gt;本文是一片翻译，原文来自&lt;a class=&quot;link&quot;   href=&quot;https://leewarrick.com/&quot;  target=&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Touch和Mouse事件</title>
    <link href="https://feidom-up.github.io/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-06-07T00:28:00.000Z</published>
    <updated>2024-08-22T02:26:03.660Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h4><p>移动端的一个页面，猜测哈，hover事件&amp;mouseover事件都被监听时，mouse应该失效吧。因为移动端只有点触，没有mouse。<br>事实：出现mouseover（定义了这个时候的样式）状态，就很奇怪。<br>然后，本以为mouse和touch在浏览器中是这样的：</p><ul><li>pc端：mouse事件生效，touch事件<del>失效</del></li><li>移动端：mouse事件<del>失效</del>，touch事件生效</li><li><strong>但是</strong>，结果是这样的：<br>同时监听了mouse和touch两种事件，在ios移动设备中的safari浏览器中，点击触发touch事件之后，定义的mouseover事件也触发了，产生了bug。</li></ul><h4 id="研究它"><a href="#研究它" class="headerlink" title="研究它"></a>研究它</h4><p>敲黑板：</p><ul><li>pc端：onTouch事件会被屏蔽。</li><li>移动端：两种事件都会被触发。且顺序是这样的：<ol><li>touchstart</li><li>touchmove</li><li>touchend</li><li>mouseover</li><li>mousemove</li><li>mousedown</li><li>mouseup</li><li>click</li></ol></li></ul><p>好吧，这是这一切出现的原因。<br>在适配多种设备的项目中，怎么区分这两种事件，让mouse事件在移动端失效呢。</p><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul><li>设置一个flag，mouse事件时判断touchFlag决定return或者执行。</li><li>分开写，判断设备后需要mouse的写mouse，需要touch的写touch。</li><li>最好的方法：preventDefault()<blockquote><p><strong>Use preventDefault() inside touch event handlers, so the default mouse-emulation handling doesn’t occur.</strong></p></blockquote></li></ul><h4 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault()"></a>preventDefault()</h4><p>专门挑出来说一下这个：preventDefault()【该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。】<br>于是，在<code>touchstart</code>方法中使用<code>e.preventDefault()</code>去阻止之后的mouseover事件。<br><font color='red'>报错了</font>：Unable to preventDefault inside passive event listener due to target being treated as passive.</p><blockquote><p>翻译： 由于目标被视为被动，无法在被动事件监听器内防止。</p></blockquote><h5 id="passive-的事件监听器"><a href="#passive-的事件监听器" class="headerlink" title="passive 的事件监听器"></a>passive 的事件监听器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(type, listener, &#123;</span><br><span class="line">    capture: <span class="literal">false</span>,</span><br><span class="line">    passive: <span class="literal">true</span>,</span><br><span class="line">    once: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>三个属性都是布尔类型的开关。其中 capture 属性等价于以前的 useCapture 参数；once 属性就是表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它；passive 属性在 Firefox 和 Chrome 已经实现。<br>很多移动端的页面都会监听 touchstart 等 touch 事件，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ... <span class="comment">// 浏览器不知道这里会不会有 e.preventDefault()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。</p><p>Passive Event Listeners：就是告诉前页面内的事件监听器内部是否会调用<code>preventDefault</code>函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，代表该监听器内部不会调用<code>preventDefault</code>函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性当前仅支持mousewheel/touch相关事件。</p><p><strong>耗时是什么</strong><br>当用户在移动设备上点击网页中的某个元素时，没有为移动交互设计的网页在触摸开始事件和处理鼠标事件（mousedown）之间至少有300毫秒的延迟。如果你有触摸设备，你可以看看这个例子。或者，使用Chrome浏览器，你可以在Chrome开发者工具中打开 “模拟触摸事件”，以帮助你在非触摸系统上测试触摸界面!</p><p>这个延迟是为了让浏览器有时间判断用户是否在做其他手势–特别是双击缩放。很明显，在你想对手指触摸做出即时反应的情况下，这可能是个问题。目前正在进行的工作是试图限制这种延迟自动发生的情况。</p><table><thead><tr><th align="left"></th><th align="left">Chrome for Android</th><th align="left">Android Browser</th><th align="left">Opera Mobile for Android</th><th align="left">Firefox for Android</th><th align="left">Safari iOS</th></tr></thead><tbody><tr><td align="left">Non-scalable viewport</td><td align="left">No delay</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">No delay</td><td align="left">300ms</td></tr><tr><td align="left">No Viewport</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td></tr></tbody></table><p>避免这种问题的一个简单方法，就是直接告诉浏览器，我这个页面不需要滚动：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt;</code>，一般在移动端这样写可以。</p><p><strong>综上</strong>：<br>  事件监听时，设置第三个参数中：passive为false，告诉浏览器我要自己控制<code>preventDefault</code>函数来阻止事件的默认行为。</p><p><strong>如下</strong>：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private onTouchStart(e:MouseEvent) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onTouchStart'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">private onMouseOver(e:MouseEvent) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onMouseOver'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.touchElement) &#123;</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.onTouchStart, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'mouseover'</span>, <span class="keyword">this</span>.onMouseOver, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div styleName=&#123;<span class="string">'btn-start-wrap'</span>&#125; ref=&#123;</span><br><span class="line">  (ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      <span class="keyword">this</span>.touchElement = ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><br>  以上的代码touchstart后不会触发mouseover。实现了阻止移动端也触发mouse事件的逻辑。</p><h4 id="参见："><a href="#参见：" class="headerlink" title="参见："></a>参见：</h4><p>  <a class="link"   href="https://www.jianshu.com/p/5bae6433025f"  target="_blank" rel="noopener">Passive Event Listeners——让页面滑动更加流畅的新特性<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.cnblogs.com/ziyunfei/p/5545439.html"  target="_blank" rel="noopener">紫云飞 – passive 的事件监听器<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.html5rocks.com/en/mobile/touchandmouse/"  target="_blank" rel="noopener">touch&amp;mouse<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一个问题引发的思考&quot;&gt;&lt;a href=&quot;#一个问题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的思考&quot;&gt;&lt;/a&gt;一个问题引发的思考&lt;/h4&gt;&lt;p&gt;移动端的一个页面，猜测哈，hover事件&amp;amp;mouseover事件都被监听时，
      
    
    </summary>
    
    
      <category term="移动端" scheme="https://feidom-up.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://feidom-up.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpackPlugins</title>
    <link href="https://feidom-up.github.io/2021/05/28/webpackPlugins/"/>
    <id>https://feidom-up.github.io/2021/05/28/webpackPlugins/</id>
    <published>2021-05-28T02:07:55.000Z</published>
    <updated>2024-08-22T02:26:03.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h4><ul><li>简介<br>在编译时创建一个可以配置的全局变量，在区分开发模式｜生产模式的不同时十分有用。</li><li>使用：<ul><li>在webpack的plugins中，增加<code>webpack.DefinePlugin(Object)</code>的实例</li><li>方法中传入的Object的key值，可以在项目所有import的文件中使用。</li><li>使用时得到的是key对应额value，这里在编译时，并不是变量的引用，而是<strong>编译时直接替换</strong><blockquote><p>因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p></blockquote></li></ul></li><li>文档地址<ul><li><a class="link"   href="https://v4.webpack.docschina.org/plugins/define-plugin/"  target="_blank" rel="noopener">webpack.DefinePlugin<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;webpack-DefinePlugin&quot;&gt;&lt;a href=&quot;#webpack-DefinePlugin&quot; class=&quot;headerlink&quot; title=&quot;webpack.DefinePlugin&quot;&gt;&lt;/a&gt;webpack.DefinePlugin&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue3的数据响应式系统</title>
    <link href="https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-19T07:54:57.000Z</published>
    <updated>2024-08-22T02:26:03.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue2-0的数据监听"><a href="#Vue2-0的数据监听" class="headerlink" title="Vue2.0的数据监听"></a>Vue2.0的数据监听</h3><p><strong>Object.defineProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123; bValue = newValue; &#125;,</span><br><span class="line">    enumerable : <span class="literal">true</span>,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-0的数据响应式系统"><a href="#Vue3-0的数据响应式系统" class="headerlink" title="Vue3.0的数据响应式系统"></a>Vue3.0的数据响应式系统</h3><p><strong>proxy</strong> get\set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用vue-next(3)源码中'packages/reactivity/dist/reactivity.global.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;reactive, effect&#125; = VueObserver;</span><br><span class="line"><span class="comment">//  reactive: 把数据处理成为响应式数据</span></span><br><span class="line"><span class="comment">//  effect: </span></span><br><span class="line"><span class="comment">//      1.首先会执行一次对应的监听函数</span></span><br><span class="line"><span class="comment">//      2.修改对应监听函数内使用的响应式数据，对应的监听函数就会立即执行，重新执行的过程就会获取新的数据</span></span><br><span class="line"><span class="keyword">const</span> yideng = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> state = reactive(yideng);</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = state.count;</span><br><span class="line">    <span class="keyword">const</span>.log(<span class="string">'当前的count'</span>, count)</span><br><span class="line">    <span class="comment">//render(count)  如果在这触发render渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">effect(fn)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue2-0的数据监听&quot;&gt;&lt;a href=&quot;#Vue2-0的数据监听&quot; class=&quot;headerlink&quot; title=&quot;Vue2.0的数据监听&quot;&gt;&lt;/a&gt;Vue2.0的数据监听&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Object.defineProperty&lt;/str
      
    
    </summary>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之队列</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/</id>
    <published>2021-03-17T10:44:26.000Z</published>
    <updated>2024-08-22T02:26:03.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>特性：先进先出</li><li>解题法则：<ul><li>题目具备<strong>广度遍历（分层遍历）</strong>和<strong>顺序输出</strong>的特点，就应该想到用FIFO 队列来试一试。</li><li><strong>滑动窗口</strong>类型题</li></ul></li><li>模板：<ul><li>分层遍历</li><li>循环队列</li><li>单调队列</li></ul></li></ul><hr><h5 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h5><ul><li>例题1：从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。<br>  输入： <pre><code>   39     8    6   7</code></pre>  输出：<code>[[3], [9, 8], [6, 7]]</code></li></ul><p><strong>二叉树的层次遍历</strong>的解题技巧</p><ul><li>遍历方式的变化：<ul><li>二叉树的锯齿形遍历</li><li>二叉树层次倒序遍历</li></ul></li><li>层的信息变化<ul><li>二叉树的层平均值</li><li>二叉树最深层的叶节点的和</li><li>二叉树的最大宽度</li></ul></li><li>树的变化<ul><li>N叉树的层次遍历</li><li>N叉树的最大深度</li></ul></li></ul><hr><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><ul><li>重点： 循环使用固定空间</li><li>难点： 控制好 front/rear 两个首尾指示器</li><li>空队列和满队列的判断，在于<code>used</code>变量</li><li>例题2：设计一个可以容纳 k 个元素的循环队列。需要实现以下接口：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数k表示这个循环队列最多只能容纳k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="comment">// 将value放到队列中, 成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">// 删除队首元素，成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队首元素，如果为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否已放满k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><ul><li>概念： 要求队列中的元素必须满足单调性，比如<strong>单调递增</strong>，或者<strong>单调递减</strong>。单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：<ul><li>FIFO 队列只能从尾部添加元素，首部弹出元素；</li><li>双端队列可以从首尾两端 push/pop 元素。</li></ul></li><li>注意： 单调队列在入队的时候，需要满足 2 点：<ul><li>入队前队列已经满足单调性；</li><li>入队后队列仍然满足单调性。</li></ul></li><li>例题3：滑动窗口的最大值<br>  输入：nums = [1,3,-1,-3,5,3], k = 3<br>  输出：[3,3,5,5]<blockquote><p>符合<font color=red>单调递减队列！</font></p></blockquote></li><li>例题4： 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？<br>  输入：[1,-1,-100,-1000,100,3], k = 2<br>  输出：4<br>  解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进先出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目具备&lt;strong&gt;广度遍历（分层遍历）&lt;/strong&gt;和&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://feidom-up.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>手写代码系列之New(fn)</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/</id>
    <published>2021-03-17T00:46:47.000Z</published>
    <updated>2024-08-22T02:26:03.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="New操作符做了哪些事"><a href="#New操作符做了哪些事" class="headerlink" title="New操作符做了哪些事"></a>New操作符做了哪些事</h3><ul><li>创建了一个全新的对象。</li><li>会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>使this指向新创建的对象。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>版本一：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，且将其隐式原型指向构造函数原型</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            __proto__: fn.prototype</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行构造函数</span></span><br><span class="line">        fn.call(obj, ...arguments)</span><br><span class="line">        <span class="comment">// 返回该对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = myNew(Person)(<span class="string">'chen'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>版本二：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fn.prototype !==<span class="literal">null</span>)&#123;</span><br><span class="line">        res.__proto__ = fn.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = fn.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;New操作符做了哪些事&quot;&gt;&lt;a href=&quot;#New操作符做了哪些事&quot; class=&quot;headerlink&quot; title=&quot;New操作符做了哪些事&quot;&gt;&lt;/a&gt;New操作符做了哪些事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建了一个全新的对象。&lt;/li&gt;
&lt;li&gt;会被执行[[P
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码系列之防抖与节流</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-03-16T07:26:28.000Z</published>
    <updated>2024-08-22T02:26:03.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>思路</strong>：在规定时间内未触发第二次，则执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 在规定时间内再次触发</span></span><br><span class="line">        <span class="comment">// 会先清除定时器再重设定时器</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, debounce(fn1, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>思路</strong>：在规定时间内只触发一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存时间</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt;= delay)&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, throttle(fn2, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：在规定时间内未触发第二次，则执行&lt;/p&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码咔咔咔</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/</id>
    <published>2021-03-16T07:24:51.000Z</published>
    <updated>2024-08-22T02:26:03.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="咔咔咔"><a href="#咔咔咔" class="headerlink" title="咔咔咔"></a>咔咔咔</h3><ul><li><a href="/2021/03/16/手写代码系列之防抖与节流/">手写代码系列之防抖与节流</a></li><li><a href="/2021/03/17/手写代码系列之New-fn/">手写New</a></li><li><a href="">手写Promise</a></li><li><a href="">手写Promise.all</a></li><li><a href="">二叉树的深及遍历</a></li><li><a href="">version版本对比</a></li><li><a href="">一个字符串最大的回文字符串</a></li><li><a href="">三数之和</a></li><li><a href="">手写indexof</a></li><li><a href="">手写EventEmitter</a></li><li><a href="">手写Redux.createStore</a></li><li><a href="">手写深拷贝、深拷贝函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;咔咔咔&quot;&gt;&lt;a href=&quot;#咔咔咔&quot; class=&quot;headerlink&quot; title=&quot;咔咔咔&quot;&gt;&lt;/a&gt;咔咔咔&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2021/03/16/手写代码系列之防抖与节流/&quot;&gt;手写代码系列之防抖与节流&lt;/a&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之栈结构</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-16T07:15:17.000Z</published>
    <updated>2024-08-22T02:26:03.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>特性：先进后出</li><li>解题法则：<ul><li>题目中有<strong>配对、消除</strong>的题意，优先考虑<strong>栈</strong>结构</li><li>栈中存放的可以是<strong>内容本身</strong>和<strong>内容的索引</strong></li><li>数组中右边<strong>第一个比我小</strong>的元素的位置，求解用<strong>递增栈</strong></li><li>较小的数<strong>消除</strong>掉较大的数的时候，使用<strong>递增栈</strong>。</li><li>根据题意总结<strong>入栈与出栈的时机</strong></li></ul></li></ul><h5 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h5><ul><li>规律性：<font color=red>配对、消除</font></li></ul><hr><ul><li>例题1：字符串中只有字符’(‘和’)’。合法字符串需要括号可以配对。比如：<br>  输入：”()”<br>  输出：true<br>  解释：()，()()，(())是合法的。)(，()(，(()是非法的。<br>  请你实现一个函数<code>isValid(s)</code>，来判断给定的字符串是否合法。<blockquote><p>针对例1这种<font color=green>内容一样</font>时，可以使用<font color=green>计数器优化</font></p></blockquote></li><li>例题拓展： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<br>  左括号必须用相同类型的右括号闭合<br>  左括号必须以正确的顺序闭合<br>  注意空字符串可被认为是有效字符串<br>  请实现<code>isValid(s)</code></li></ul><hr><ul><li>例题2：在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:<br>  所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；<br>  当方向相对时，大鱼会吃掉小鱼；<br>  鱼的大小都不一样。<br>  输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]<br>  输出：3<br>  完成<code>solution(Size, Dir)</code>来计算还剩下几条鱼？</li></ul><hr><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><ul><li>定义：单调栈就是指栈中的元素必须是按照升序排列的栈，或者是降序排列的栈。<br>  升序排列的栈称为<strong>递增栈</strong><br>  降序排列的栈称为<strong>递减栈</strong><br>  特点：任何时候都需要保证栈的有序性</li></ul><hr><ul><li>例题1：一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。（找出数组中右边比我小的元素）<br>  输入：[5, 2]<br>  输出：[1, -1]<br>  解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</li></ul><blockquote><p>类似题：<br>数组中右边第一个比我大的元素的位置<br>数组中元素左边离我最近且比我小的元素的位置<br>数组中元素左边离我最近且比我大的元素的位置</p></blockquote><ul><li>例题2：给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。<br>  输入：nums = [3,5,2,6], k = 2<br>  输出：[2,6]<br>  解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</li></ul><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png" alt="图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进后出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目中有&lt;strong&gt;配对、消除&lt;/strong&gt;的题意，优先考虑&lt;st
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://feidom-up.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-03T01:34:21.000Z</published>
    <updated>2024-08-22T02:26:03.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法四步分析法："><a href="#算法四步分析法：" class="headerlink" title="算法四步分析法："></a>算法四步分析法：</h3><ol><li>模拟：模拟题目的运行。</li><li>规律：尝试总结出题目的一般规律和特点。</li><li>匹配：找到符合这些特点的数据结构与算法。</li><li>边界：考虑特殊情况。</li></ol><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul><li><a href="/2021/03/16/数据结构与算法之栈结构/">栈结构与算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法四步分析法：&quot;&gt;&lt;a href=&quot;#算法四步分析法：&quot; class=&quot;headerlink&quot; title=&quot;算法四步分析法：&quot;&gt;&lt;/a&gt;算法四步分析法：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;模拟：模拟题目的运行。&lt;/li&gt;
&lt;li&gt;规律：尝试总结出题目的一般规律和特点。
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Virtual DOM的工作原理</title>
    <link href="https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2021-01-02T15:22:41.000Z</published>
    <updated>2024-08-22T02:26:03.664Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Virtual-DOM-也被称为虚拟DOM"><a href="#Virtual-DOM-也被称为虚拟DOM" class="headerlink" title="Virtual DOM 也被称为虚拟DOM"></a>Virtual DOM 也被称为虚拟DOM</h4><ul><li>在react中，<code>jsx语法</code>经过<code>babel解析</code>转化为<code>React.createElement()</code>函数调用后生成<code>ast抽象语法树</code>，再通过<code>render</code>函数将<code>ast树</code>转换为<code>fiber 结构</code>，填入许多调度、更新、diff相关数据，并转换<code>ast树</code>为<code>虚拟DOM树</code>，再完成挂载。</li><li>在vue中，模版语法 经过 <code>generate</code>处理(正则匹配 生成 <code>ast抽象语法树</code>)，<code>render</code>中调用<code>_c()/createElement()</code>函数将<code>ast树</code>生成<code>VNode(虚拟DOM)</code>,再完成挂载。</li></ul><h4 id="虚拟DOM的来源"><a href="#虚拟DOM的来源" class="headerlink" title="虚拟DOM的来源"></a>虚拟DOM的来源</h4><p>react的前身是facebook的<code>XHP</code>，在这个框架中，页面都是通过转义的方式生成的，并没有直接的HTML，确保在<code>XHP</code>中写出安全的静态页面。</p><p>初衷是：</p><ul><li>简化前端开发（后端赋能）</li><li>防止xss攻击</li></ul><p>发展是：</p><ul><li>通过虚拟DOM规避风险，不让用户直接的操作DOM了，而是把它封起来自己管理</li></ul><h4 id="虚拟DOM的表现形式"><a href="#虚拟DOM的表现形式" class="headerlink" title="虚拟DOM的表现形式"></a>虚拟DOM的表现形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'input'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    childrean: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React 有两个函数<br>    * diff 函数，去计算状态变更前后的虚拟 DOM 树差异<br>    * 渲染函数，渲染整个虚拟 DOM 树或者处理差异点。<br>    现在是不是有些理解为什么 React 与 ReactDOM 是两个库了？正是由于计算与渲染的分工。<br>    其中 React 的主要工作是组件实现、更新调度；ReactDOM 提供了在 网页上渲染 的基础</p></blockquote><h4 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h4><p>优点</p><ul><li>性能优越</li><li>规避XSS</li><li>可跨平台</li></ul><p>但是不是所有的操作都是虚拟DOM更高效<br>&emsp;&emsp;大量的直接操作DOM容易引起页面性能下降。这时React基于虚拟DOM的diff处理与批处理操作，可降低DOM的操作频次和范围，提升页面性能<br>&emsp;&emsp;但是在首次渲染或者微量dom操作的时候，虚拟DOM的性能就更慢一些。</p><p>那虚拟 DOM 一定可以规避 XSS吗？<br>&emsp;&emsp;虚拟 DOM 内部确保了字符转义，所以确实可以做到这点，但 React 存在风险，因为 React 留有 dangerouslySetInnerHTML API 绕过转义。</p><p>没有虚拟 DOM 不能实现跨平台吗？<br>&emsp;&emsp;比如 NativeScript 没有虚拟 DOM 层 ，它是通过提供兼容原生 API 的 JS API 实现跨平台开发。<br>那虚拟 DOM 的优势在哪里？<br>&emsp;&emsp;实际上它的优势在于跨平台的成本更低。在 React Native 之后，前端社区从虚拟 DOM 中体会到了跨平台的无限前景，<br>所以在后续的发展中，都借鉴了虚拟 DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟 DOM 的结构描述对象，来支撑多端转换。</p><p>缺点</p><ul><li>内存占用较高</li><li>难以进行优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Virtual-DOM-也被称为虚拟DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM-也被称为虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM 也被称为虚拟DOM&quot;&gt;&lt;/a&gt;Virtual DOM 也被称为虚拟DOM&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/react/vue/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Serverless是什么</title>
    <link href="https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-01-01T13:59:56.000Z</published>
    <updated>2024-08-22T02:26:03.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p>广义上来说<br>是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服务器”，但这并不代表着应用运行不需要服务器，而是开发者不需要关心服务器。而基于 Serverless 思想实现的软件架构就是 Serverless 架构。</p></li><li><p>狭义上说<br>  狭义的 Serverless 是 <code>FaaS</code> 和 <code>BaaS</code> 的组合。</p><ul><li>FaaS（Function as a Service）：<ol><li>FaaS本质上是一个函数运行平台，函数运行时，你对底层的服务器是无感知的，FaaS 产品会负责资源的调度和运维，这是它的特点之一，<strong>不用运维</strong>。</li><li>FaaS 中的函数也不是持续运行的，而是通过事件进行触发，比如 HTTP 事件、消息事件等，产生事件的源头叫触发器，FaaS 平台会集成这些触发器，我们直接用就行，这是 FaaS 的第二个特点，<strong>事件驱动</strong>。</li><li>FaaS 的第三个特点是<strong>按量付费</strong>。 FaaS 产品的收费方式，都是按照函数执行次数和执行时消耗的 CPU、内存等资源进行计费的。</li><li>FaaS 在运行函数的时候，会根据并发量自动生成多个函数实例，并且并发理论是没有上限的，这是它的第四个特点，<strong>弹性伸缩</strong>。</li></ol><ul><li>FaaS 每次执行函数时，都会初始化一个新的运行环境，然后从头开始执行整个代码，而不是只执行其中的 handler 方法。执行完毕后，运行环境就会被释放。这样每次函数执行，都是新的运行环境，自然不同函数之间就无法共用 pv 这个变量了。FaaS 的另一个特点，<strong>无状态</strong>。</li></ul></li><li>BaaS（Backend as a Service）<br> 为了解决分布式中的状态共享问题<br> BaaS 本质上就是把后端功能封装起来，以接口的形式提供服务。</li></ul></li><li><p>总<br>基于 FaaS 和 BaaS 的架构，是一种计算和存储分离的架构。 计算由 FaaS 负责，存储由 BaaS 负责，计算和存储也被分开部署和收费。这使应用的存储不再是应用本身的一部分，而是演变成了独立的云服务，降低了数据丢失的风险。而应用本身也变成了无状态的应用，更容易进行调度和扩缩容。</p></li></ul><p>基于 FaaS 和 BaaS ，你的应用就实现了自动弹性伸缩、按量付费、不用关心服务器，这正是 Serverless 架构的必要因素。所以说狭义的 Serverless 是 FaaS 和 BaaS 的组合。</p><h3 id="与其他架构的区别"><a href="#与其他架构的区别" class="headerlink" title="与其他架构的区别"></a>与其他架构的区别</h3><ul><li>PaaS<br>  PaaS （平台即服务）是云计算虚拟机时代的主要形态之一。 它是指云厂商提供开发工具、依赖库、服务和运行平台等能力，开发者可以依赖这些能力将自己的应用直接部署在云平台上，不用关心底层的计算资源、网络、存储等。虽然与Serverless 很类似，但依旧存在一些区别。</li><li>Kubernetes<br>  Kubernetes 是一种容器编排技术。在 Kubernetes 中应用运行的基本单位是 Pod（容器组），Pod 是应用及运行环境的集合，所以你也不用关心服务器了。基于 Kubernetes，你能很方便地进行 Pod 的管理，并且实现应用的弹性伸缩。<br>  所以，Kubernetes 是介于 Serverful 和 Serverless 中间的产物。</li></ul><p><strong>Serverless 是云原生的一种实现，云原生的另一种实现是 Kubernetes。</strong></p><table><thead><tr><th align="left">Serverless</th><th align="left">PaaS （平台即服务）</th><th align="left">Kubernetes</th></tr></thead><tbody><tr><td align="left">按实际使用量付费</td><td align="left">按资源付费</td><td align="left">按照资源数量计费</td></tr></tbody></table><h3 id="Serverless-的优缺点"><a href="#Serverless-的优缺点" class="headerlink" title="Serverless 的优缺点"></a>Serverless 的优缺点</h3><ul><li>优点：不用运维、弹性伸缩、节省成本、开发简单、降低风险、易于扩展。</li><li>缺点：<ol><li>依赖第三方服务：一旦你选择了一个云厂商，要想从一个云移到另一个台，成本很高</li><li>底层硬件的多样性：代码依赖的地层硬件多样性</li><li>应用性能瓶颈：函数运行前需要现初始化函数运行环境，这个过程需要消耗一定时间。因为函数不是持续“在线”的，而是需要运行的时候才启动（不像传统应用，服务是一直启动的）。</li><li>函数通信效率低：在 Serverless 应用中，函数与函数之间就完全独立了。如果两个函数的数据有依赖，需要进行通信、交换数据，就要进行函数与函数之间的调用（调用方式是 HTTP 调用）。相比之前的内存调用，数据交互效率显然低了很多。而这个问题的本质，是 FaaS 还没有比较好的数据通信协议或方案。</li><li>开发调试复杂：Serverless 架构正处于飞速发展的阶段，其开发、调试、部署工具链并不完善（基本是每个云厂商各玩各的）</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广义上来说&lt;br&gt;是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服
      
    
    </summary>
    
    
    
      <category term="serverless" scheme="https://feidom-up.github.io/tags/serverless/"/>
    
  </entry>
  
</feed>
