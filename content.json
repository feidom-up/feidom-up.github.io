{"meta":{"title":"feidom up up up","subtitle":"","description":"","author":"乔文飞","url":"https://feidom-up.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-06-28T01:43:01.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"about/index.html","permalink":"https://feidom-up.github.io/about/index.html","excerpt":"","text":"Mustang参禅之初，看山是山，看水是水。禅有悟时，看山不是山，看水不是水；禅中彻悟，看山任然是山，看水仍然是水。 前端乔文飞的笔记博客。"},{"title":"标签","date":"2020-07-01T01:03:55.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"tags/index.html","permalink":"https://feidom-up.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-01T00:56:35.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"categories/index.html","permalink":"https://feidom-up.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hhkb快捷键备忘","slug":"hhkb快捷键备忘","date":"2024-08-22T01:36:22.000Z","updated":"2024-08-22T02:37:50.882Z","comments":true,"path":"2024/08/22/hhkb快捷键备忘/","link":"","permalink":"https://feidom-up.github.io/2024/08/22/hhkb%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/","excerpt":"","text":"切换连接方式： fn+ctrl+0 有线 fn+ctrl+1~4 蓝牙设备 蓝牙配对信息注册： fn+q 进入等待配对模式 fn+ctrl+14 将即将要配对的设备存放到 14 位置。 删除所有配对信息： fn+q 进入等待配对模式 fn+z+delete 删除个别配对信息： fn+q 进入等待配对模式 fn+ctrl+delete+1~4 配对中途取消配对： fn+q 进入等待配对模式 fn+x 软改切换模式（非 DIP，仅在无线状态下有效） 切换为 win 模式：fn+ctrl+w 切换为 mac 模式：fn+ctrl+m","categories":[{"name":"工具","slug":"工具","permalink":"https://feidom-up.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://feidom-up.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Javascript-in-V8","slug":"Javascript-in-V8","date":"2021-12-30T03:05:49.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2021/12/30/Javascript-in-V8/","link":"","permalink":"https://feidom-up.github.io/2021/12/30/Javascript-in-V8/","excerpt":"","text":"之前对js对象你不知道的那些特点 有一些粗浅的认识，这个笔记写的很无理取闹。现在研究清楚以后，重新补一篇笔记来完善知识。之前的这篇就留着吧，也是学习和思考中一个必有的认知阶段。 JS Object 中的常规属性和排序属性 常规属性(V8:properties)在properties对象中，会按照创建时的顺序保存常规属性。 排序属性(V8:elements)当key为数字时，会将这类属性存储在elements对象中，将其作为一块连续的内存以Array的形式进行存储。在elements对象中，会按照数字大小的顺序来存放排序属性。 12345678910111213141516171819202122232425function ClassA() &#123; this[100] = '100'; this[1] = '1'; this['B1'] = 'B'; this[50] = '50'; this[3] = '3'; this['A2'] = 'A'; this['C'] = 'C';&#125;var a = new ClassA();for(key in a)&#123; console.log(`$&#123;key&#125;: $&#123;a[key]&#125;`)&#125;a.qwf = 'qwf';console.log(a)function ClassB(num)&#123; for(let i=0; i&lt;num; i++)&#123; this[i] = `eeeeee_$&#123;i&#125;` this[`p_$&#123;i&#125;`] = `pppppp_$&#123;i&#125;` &#125;&#125;var b = new ClassB(20);console.log(b) 作为两个属性，为啥在console的控制台打印的结果中没有发现呢。其实console的控制台打印的没那么深，那怎么能找到他们呢。在Memory控制台录制快照，就能很明显的看到他们。 V8引擎对Object做了什么残忍的事 Hidden Class 隐藏类 Properties pointer 常规属性指针 Elements pointer 排序元素指针 为什么要这样分开呢？？？首先我们需要聊一下公认最快的C语言，它的快很大程度上归功于它严格的类型约束。也就是说大型的面向对象系统都有严格的数据结构，这对快速的属性查询很关键。所以，Js中的Object的定义非常差,因为它太灵活了，没有类型的概念。而且存在可以任性修改的原型链，它没有限制。所以在V8对JS Object进行处理时，为了快速的属性查询，有一个内部的类型系统：对具有相同结构的对象进行分组；各个对象之间可以共享；生成的成本很高，但是之后的成本很低。 V8对Object做的优化 属性内联缓存 在属性查询中检查隐藏类 在第一次时完全通用查询 然后记住你在哪个地方找到的这个属性生成新的优化代码 下次使用，直接访问 Object 属性的存储 直接在object上，即默认状态，这个很快 array形式存储，也很快 哈希表结构（字典模式），这个的交互会慢很多字典模式相比于其他模式，运行速度降低。触发字典模式的行为如下： 非常多的属性，他们没有办法被放在默认状态的内存中，这个数字可能是10 ？30？ 改变属性 删除属性 JS Array 字典模式 同样对比C，Js中的Array也因为没有类型约束给了用户很大的自由，也挺样带来了不可控的性能问题。 连续内存的存储和hash表（字典模式）不同的存储方式，不一样的性能体验。 触发字典模式的行为如下： 非常多的属性，大于1024？ 10000？ 动态扩容 1234567// badvar a = new Array();a[1000] = 8;// okvar a = new Array(1000);a[0] = 'nihao';a[100] = 8; 结合以上特点，我们应该做什么 Js给我们很高的灵活度让我们随心所欲，但是我们不应该为所欲为，自由度高，带来的就是性能的不友好。 12345function ClassA() &#123; this[100] = '100';&#125;var a = new ClassA();a.qwf = 'qwf'; // 这样直接添加属性，改变了隐藏类 所以尽量定义好默认属性，不要在构造函数之外做大量的动态属性添加和删除，尽量共享隐藏类。 V8 V8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214The first type of attry to talk about in javascript is the TypedArraySo TypedArrays are going to make a lot of aense to you ifyou are coming from a C backgroundThey are contiguous blocks of memory that are specified for a particylar data type.So you have Uint32Array, Float64Array, Unit8Array, and so on, and so forth, which actually, if you are familiar with Javascript,is sort of unusual. Because most things in Javascript have no type. So this idea that we are specifying a very specific size for our numbers id actually like pretty unique. And that&#39;s because the TypedArray specification grew up alongside the WebGL specification.And you can inagine how you need that level of specificity if you are doing graphics programming.So that&#39;s sort of where the TypedArray specification came from.But it&#39;s been adopted into other things now that it&#39;s there.So agein, they&#39;re memory efficient. You don&#39;t have to box them.They behave as you&#39;d expect.They&#39;re a very nice option for arrays.But if you can&#39;t use TypedArrays for whatever reason, you need to use Javascript Arrays.SO Javascript Array object --Array with a captital A-- has an API which is going to look a little weird to you if you are used to C-style arrays.It&#39;s going to have operations that are different.It&#39;s going to have like push and pop.It&#39;s going to allow you to index out of bounds.It&#39;s going to have just sort of odd behavior to me as somebody coming from C.So as you can imagine, because the API allows all these non-C array-like things, the backing storage in V8 is not always somethings that looks like array. There are actually two diffent types of backing storage for arrays. Thewe are sparse arrays and dense arrays, which map to either something tach looks like a C-style array. like you&#39;d expect, or a hash table. And if you array is backed by a V8 hash table, that&#39;s called being in dictionary mode, and it&#39;s considerably less efficient. It&#39;s case that you want to avoid.There are many factors in V8 that causes you to be kicked into dictionary mode or not. So it&#39;s kind of complicated to define them all. But one of them, for instance, is space efficiency.So is the codes you wrote will be three times more effcient, use three times less space if it was backed by a hash table than an array, then it&#39;ll be a hsah table on back end. So there are criteria like that. js allows you to create a new uninitialized array and then just suddenly index into it at whatever index.This, doesn&#39;t make any sense in C. It&#39;s not something you&#39;d actually do. And in V8, it will immediately trigger dictionary mode. So this, you will now have a nice, slow array to waok with, not something you want.So real simple change.All you have to do is declare how much storage you want up font.Now you have declared to V8 that you actually want an array of a certain size. V8 will back your array by a contigous array of that size, and you can go from there.Veay sensible, kind of no-brainerish, but again, Javascript allows you to do it in a way that ends up being very inefficient, so it&#39;s important to know.So that is the numeric representation and the immediate representation of objects.-------------------------------Object in V8 -------------------------------So objects in JavaScript are there very poorly defined things.They are associative arrays.They&#39;re just bundles of key value pairs of properties.So you have string balue for key, property value.And all property values are these undefined whatevers, because Javascript doesn&#39;t have a notion of type.Object have prototype chains. You can add and remove properties anywhere at the prototype chain and on the object inself at any point. Javascript doesn&#39;t enforce any specificity or structure in your code.So if you wanted to, you could make every single object in your whole program absolutely a unique set of properties.Nothing in Javascript will enforce structure or self-similarity.But just because JavaScript allows you to do that, you really,really shouldn&#39;t.That&#39;s actually a terrible thing to do for performance.And I&#39;ll explain why in a minute.So in V8,the V8 team looked at trying to write a large-scale application in JavaScript and thought, hey, you know what&#39;s important in large-scale systems is object-orientenness.And if you have object-orientenness in your system, then now, property access is one of the key things that you need to make fast. So V8 designed its structure to make property access on objects as efficient as it could be.So the internal representation of an object in V8 is three words.So first, we have a hidden class pointer, which is an internal notion of type, which I&#39;ll explain in a second.And then we have two pointers to different kinds of properties.We have properties that have string names and then properties that have int names. But really, the only thing that&#39;s important is your have a type, and then you have property storage.So waht&#39;s this hidden class thing?So hidden classes, again, ther&#39;re V8&#39;s interbal notion of type.JavaScript itself isn&#39;t going to enforce any kind of notionof type on you.BUt in order to make things effcient, V8itself need to have some sort of structure in whst it things you&#39;re doing. So it introduces a type system.And that type system froups objects with the same structure.So as you&#39;re adding properties to objects, which you can do in JavaScript, V8 will be looking at the properties on each object and mapping ta&#x3D;hat bundle of properties to a hidden class, which defines an object with exactly those properties.So, dor instance, if I have this constructor in JavaScript where I have a point, and it has an x and y, and the way those values are added by first adding x to the object and then adding y, thay&#39;s going to generate a hidden class that backs objects that are created from this function that has exactle the properties x and y.And that really seems sort of obvious.But then, the first time this function is run, that hidden class is going to be built for the first time. And then, all subsequent times this dunction is run, those new objects can share the same hidden class.So you only pay the price for building it the very first time.After that, you can just use the same object.So we went through all this trouble of building up a notion of type.So now, we have types that correspond to specifically what exact properties are on an object.We can use taht notion of type to make property access quick using something called inline caching.So if yoiu want to look up a property on an object in Javascript, you&#39;re going to say, I am looking for property with name x on object y.The first thing you do whrn you&#39;re trying to look up a property is check the hidden class of the object.If you&#39;re never tried to look up that property on an object of that type before, then what you&#39;re going to have to do is a fully generic search for that property.So again, we just have a bundle of properties somewhere.They all have string names.You have a string of the property you&#39;re looking for.And you&#39;re going to have to look through taht list for the property that has a matching name.That&#39;s a pretty slow operation.But once you found thst property once, you can remember the offset to it. you can remember where you found that property and use it later, which means that you can use that to generate new optimized code which specifies how you look up that particular property on that particular object.And next time you want to look up property with that name on an object of that type, you can have direct access You know exactly where to go in an object of that type.And it&#39;s much much much faster.So thst&#39;s really what the notion of having hidden class is getting us, is now we can make property access really fast through inline caching.So this is a classic example of bad idea. function Vec2(x,y)&#123; this.x &#x3D; x; this.y &#x3D; y;&#125;var v0 &#x3D; new Vec2(5,8);v0.z &#x3D; 34;So I have another constructor. It&#39;s creating a vector object. But then, after I go through the trouble of doing that, I decide that I now wanted property z on this object.The problem with that is that if you add a property z to that object at some future point, if you just dynamically do that, you&#39;re going to change the hidden class of the object, which means that all this nice caching you&#39;re done and building up a notion of where the properties are, that&#39;s just blown away because now you have a new hidden class. You have to pay to build the new hidden class, and now you have to deal with a new hidden class.So one of the best things you can do to make you code efficient is to create a few well-defined types.Don&#39;t do alot of dynamic property adding and removing outside of constructors.Pretty much set things up once, have them look alike so that they can share the same hidden class, and don&#39;t mess with the properties they have.-------------------------------Object properties storage-------------------------------So now we know an object has properties.those properties can be in different storage states.So the first state ,the default, is that they can be stored directly in an array on the object.that great, that&#39;s fast. that&#39;s where you want to be. A second state they can be in is being stored in array off the objects. still great. No problem.The third case, which is the one you really have to look out for, is when they&#39;re stored in a hash table.So mush like just the array case in general where arrays can have different types of backing storage, properties can have different types of backing storage too.So properties can either be in normal mode where they&#39;re stored as an array or a dictionary mode where they&#39;re stored as a hash table. And if you have an object in dictionary mode, it&#39;s going to be mush slower to interact with.So you don&#39;t want that.So what triggers dictionary mode ,and how do you avoid it? Well, one thing that triggers itis toomany properties.So if you have so many properties that they won&#39;t fit into the internal storage for properties, then you have to have a hash table elsewhere. And that number of too many properties is somewhere around 30. It&#39;s quite generous, but you mighe hit it in some cases.The other things you can do to confuse your object and kick it into dictionary mode are to change the properties on the object.You can change the attribute, you can delete properties, that kind of thing. Those things are all going to kick you straight to dictionary mode.Again, and now you&#39;re going to make your object mush slower to interact with.","categories":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"}]},{"title":"js对象你不知道的那些特点","slug":"js对象你不知道的那些特点","date":"2021-08-09T01:36:22.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2021/08/09/js对象你不知道的那些特点/","link":"","permalink":"https://feidom-up.github.io/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/","excerpt":"","text":"js对象的“快/慢”属性定义一个obj，它是下面这样的 1234567const obj = &#123; 5: '1', 6: '2', 1: '6', 'qwf': '乔文飞', 'yy': 'qwf',&#125; init初始化时，属性会尽量归为“快”属性，同时也会存在“慢”属性。那么它在js中，为了有效的提升存储和访问属性的性能，js对慢属性的存储是下图这样的。 快属性：直接加在对象内属性上，方便读取。 慢属性：加载排序或常规属性上，方便操作。（在对象设置属性时，会加到慢属性） Q：为啥慢？A：多了一层深度，影响数据操作，多了Element层和Properties层。 Q：为啥不直接都存在内属性上？A：在内属性中，obj越来越大，影响存储。（以前内属性只能动态设置10个，现在不止-硬件加强等原因） js数组的“快/慢”数组 快数组：线性结构，连续内存（动态扩容），当定义初始化长度小于1024时，属于快数组 慢数组：定义长度大于1024时，需要维护额外的哈希米表。 由快到慢： 定义长度大于1024时。动态扩容时，length*1.5+16以上。 快数组的新容量时扩容容量的3倍以上时。 由慢到快： 数量在1024内 容量一下缩减50%。减容时，新数组长度是原来长度的1/2，就计算需要释放的空间，做好标记，等待GC回收。如果1/2 &lt; length &lt; 1,用holes对象填充，holes太多也是慢数组。","categories":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"}]},{"title":"js上下文执行机制","slug":"js函数执行机制","date":"2021-08-09T00:28:01.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2021/08/09/js函数执行机制/","link":"","permalink":"https://feidom-up.github.io/2021/08/09/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"执行上下文 ECS(Execute Context Stack): js函数执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。 GC(Global Context): 全局上下文。 GO(Global Context): 全局上下文生成的对象。 VO(Var Object): 声明时对象。 AO(Action Object): 执行时对象。 在AO执行时，分为两个阶段： 变量定义：AO的准备阶段，es6之前的变量提升就在这个阶段 变量赋值。 数据结构123456789101112131415161718192021222324252627// 全局上下文GC:&#123; lexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Object\", &#123;...&#125;, // 标识符什么的其他信息 outer: null, // 全局上下文没有引用 &#125; &#125;, variablesEnvironment:&#123; // 变量环境 &#125;&#125;// 函数执行上下文 Function Exection ContextEC:&#123; lexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Declarative\", //函数环境 &#123;...&#125;, // 标识符什么的其他信息 outer: '&lt;Global outer&gt;, &lt;function enviroment reference&gt;,', // 对全局环境或外部函数环境的引用 &#125; &#125;, variablesEnvironment:&#123; // 变量环境 &#125;&#125; 为了适配早起的ES5的var等，增加了变量环境。变量环境也是一个词法环境，其环境记录其包含了由变量声明语句。在ES6中，词法环境记录器和变量环境记录器的区别在于： 词法环境：用于存储函数声明和变量（let，const）的绑定。 变量环境：仅用于存储变量（var）的绑定 作用域链 scope chain：作用域链其实就是在 [AO,GC,VO] 时。 闭包原理* 在作用域scope堆空间中存储closore(fn)。","categories":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"}]},{"title":"OT在线协作","slug":"ot协作","date":"2021-08-05T01:57:07.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2021/08/05/ot协作/","link":"","permalink":"https://feidom-up.github.io/2021/08/05/ot%E5%8D%8F%E4%BD%9C/","excerpt":"","text":"OT协作思想解决冲突 A, B两个用户在协作同一段初始文本：’aaab’。冲突操作： A在第3个字符后面插入了一个c(‘aaacb’)。 B在第3个字符后面插入了一个d(‘aaadb’)。 若A先提交，ot后正确结果：’aaacdb’。？为什么不是按顺序的’aaadcb’。因为不是顺序执行，产生冲突时，为保证双方操作最大程度得到保存，ot协作后，B的操作实际变为在第4个子都后插入。A视角：A的结果’aaacb’被B拿去操作，结果’aaadcb’。B视角：B的结果’aaadb’被A拿去操作，结果’aaacdb’。可见这个结果是正确结果。 后台聪明的ot转发功能就是把每个人提交的行为转变一下再告诉别人，两方的结果就一致了。其实这个技术就是 OT 算法：A接收到的B操作：’在第3个字符后面插入了一个d‘ ==ot==&gt; ‘aaacb在第4个字符后面插入了一个d‘(aaacdb)B接收到的A操作：’在第3个字符后面插入了一个c‘ ==ot==&gt; ‘aaadb在第3个字符后面插入了一个c‘(aaacdb) OT 算法全名叫 Operation Transformation，你看从名字就对应了上面我说的转变算法。假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A’,B’。也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A’行为告诉 B，把 B’行为告诉 A，这样大家再应用就相安无事了。 核心公式：apply(apply(S,A),B) = apply(apply(S,B),A)S:开始状态A：A的操作AB：B的操作B冲突时，A执行完自己的操作后，再执行经OT转换的B操作。与B执行完自己的操作，再执行经OT转换的A操作，双方的结果是一致的。图示： 一个演示OT的小网站 参考:揭开在线协作的神秘面纱-OT算法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"OT","slug":"OT","permalink":"https://feidom-up.github.io/tags/OT/"}]},{"title":"从props的children中获取ref","slug":"从props的children中获取ref","date":"2021-07-12T09:46:29.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2021/07/12/从props的children中获取ref/","link":"","permalink":"https://feidom-up.github.io/2021/07/12/%E4%BB%8Eprops%E7%9A%84children%E4%B8%AD%E8%8E%B7%E5%8F%96ref/","excerpt":"","text":"从props.children中处理ref12345678910111213141516171819202122232425262728293031class Child extends React.Component &#123; render() &#123; return &lt;div&gt;Child&lt;/div&gt;; &#125;&#125; class GetRef extends React.Component &#123; componentDidMount() &#123; console.log(this.ref); &#125; render() &#123; const childElement = React.Children.only(this.props.children); return React.cloneElement( childElement, &#123; ref: el =&gt; this.ref = el &#125; ); &#125;&#125;class App extends Component &#123; render() &#123; return &lt;GetRef&gt;&lt;Child/&gt;&lt;/GetRef&gt;; &#125;&#125; 结合转发ref将ref绑定到children组件中的div中1234567891011121314151617181920// Com组件interface Props &#123; forwardedRef: ref | null;&#125;class Com extends React.Component&lt;Props, State&gt; &#123; render() &#123; const &#123;forwardedRef&#125; = this.props; return &lt;&gt; &lt;div&gt; &lt;div&gt; &lt;div ref=&#123;forwardedRef&#125;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;&gt; &#125; &#125;const forwardRefCom = React.forwardRef((props, ref) =&gt; ( &lt;Com forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt; ));return forwardRefCom;","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"react的转发ref","slug":"react的转发ref","date":"2021-07-12T09:18:41.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2021/07/12/react的转发ref/","link":"","permalink":"https://feidom-up.github.io/2021/07/12/react%E7%9A%84%E8%BD%AC%E5%8F%91ref/","excerpt":"","text":"简单理解使用通用的高阶组件时，外层组件ref控制高阶组件中包裹的子组件中的元素，此时外层组件传入的ref并不作用于高阶上，这个时候，高阶组件就要用到React.forwardRef进行ref转发。 官方文档React.forwardRef 简单举栗🌰🌰栗子 来自JamesSawyer—-React 中的转发ref 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 // 高阶组件import React from 'react';function logProps(Component) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('先前的属性：', prevProps); console.log('当前属性：', this.props); &#125; render() &#123; // 使用forwardedRef作为一个ref属性传入组件中 const &#123; forwardedRef, ...rest &#125; = this.props; return ( &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt; ); &#125; &#125; // 使用React.forwardRef对LogProps组件进行转发 return React.forwardRef((props, ref) =&gt; ( &#123;' 上面定义的LogProps组件接受一个forwarded属性 '&#125; &lt;LogProps forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt; ));&#125;// FancyButton.js 子组件import React from 'react';import logProps from './logProps';// 接受props和ref作为参数// 返回一个React 组件const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button class=\"fancybutton\" ref=&#123;ref&#125;&gt; &#123;props.children&#125; &lt;/button&gt;));// 使用高阶组件对其进行封装export default logProps(FancyButton);// 父组件// app.jsclass App extends React.Component &#123; constructor(props) &#123; super(props); // 创建一个ref 名字随意 this.ref = React.createRef(); &#125; componentDidMount() &#123; console.log('ref', this.ref); // this.ref.current 表示获取ref指向的DOM元素 this.ref.current.classList.add('primary'); // 给FancyButton中的button添加一个class this.ref.current.focus(); // focus到button元素上 &#125; render() &#123; // 直接使用ref=&#123;this.fancyButtonRef&#125; return ( &lt;FancyButton ref=&#123;this.fancyButtonRef&#125;&gt;子组件&lt;/FancyButton&gt; ); &#125;&#125;","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"React-防止内存泄漏处理","slug":"React-防止内存泄漏处理","date":"2021-06-18T05:40:49.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2021/06/18/React-防止内存泄漏处理/","link":"","permalink":"https://feidom-up.github.io/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"用React写了一段代码，浏览器的控制台Error 如下：Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function. 啥意思呢：不能在未挂载的组件上执行React状态更新。这是一个无用功，但它表明你的应用程序中存在内存泄漏。要解决这个问题，在useEffect清理函数中取消所有的订阅和异步任务。 以下是这段问题代码： 123456789101112131415const Component = (props) =&gt; &#123; const &#123; itemId &#125; = props; const [ isRemoveing, setIsRemoveing ] = useState(false); const handlerRemove = async() =&gt; &#123; if(isRemoveing) return; setIsRemoveing(true); await removeItem(itemId); // 删除当前这个组件的数据，这个组件卸载 setIsRemoveing(false); &#125; return ( &lt;&gt; &lt;div class_name=&#123; !isRemoveing ? 'class1' : 'class2' &#125; onClick=&#123;handlerRemove&#125; &gt;&lt;/div&gt; &lt;/&gt; )&#125; 原因是啥呢：await等待一个异步请求的返回再setIsRemoveing。假如这个组件unmounted之后，请求还没回来，你还在这setState，不就炸了。 好吧，那解决方式是不是在useEffect中定义一个卸载时的变量unmounted，然后在setIsRemoveing时判断卸载状态？ 嗯，基本是这个思路。那这个unmounted该怎么定义，是直接const unmounted = false;, 还是const [ unmounted, setUnmounted ] = useState(false);？以下是Stack Overflow里一个帖子的回复： 方式一：12345678910111213141516171819useEffect(() =&gt; &#123; let unmounted = false; setPageLoading(true); props .dispatch(fetchCourses()) .then(() =&gt; &#123; if (!unmounted) &#123; setPageLoading(false); &#125; &#125;) .catch((error: string) =&gt; &#123; if (!unmounted) &#123; toast.error(error); setPageLoading(false); &#125; &#125;); return () =&gt; &#123; unmounted = true &#125;;&#125;, []); 方式二：useRef1234567891011121314151617181920const Example = (props) =&gt; &#123; const unmounted = useRef(false); useEffect(() =&gt; &#123; return () =&gt; &#123; unmounted.current = true &#125; &#125;, []); const setFilter = () =&gt; &#123; // ... props.dispatch(fetchCourses()).then(() =&gt; &#123; if (!unmounted.current) &#123; setLoading(false); &#125; &#125;) &#125; // ... return ( &lt;ReactTable onFetchData=&#123;setFilter&#125; /* other props omitted */ /&gt; );&#125; 方式二中如果不用ref，用state或者直接定义变量的话，都实现不了。好吧，是我不熟悉的useRef,这个链接是官方文档，可以先看下。然后为了研究它，我找到一篇来自Lee Warrick的React’s useEffect and useRef Explained for Mortals。这里是我对这篇文章的翻译，仅供参考。 参考React Hooks - Check If A Component Is Mountedhow-to-stop-memory-leak-in-useeffect-hook-react","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"useEffect & useRef","slug":"useEffect-useRef","date":"2021-06-18T01:58:48.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2021/06/18/useEffect-useRef/","link":"","permalink":"https://feidom-up.github.io/2021/06/18/useEffect-useRef/","excerpt":"","text":"注意本文是一片翻译，原文来自Lee Warrick的React’s useEffect and useRef Explained for Mortals。为啥翻译并记录这篇文章呢，因为看了以后觉得通俗易懂的为凡人解释了useEffect和useRef。在此记录，方便以后回头复习。 通俗的解释React的 useEffect 和 useRef&emsp;&emsp;如果React文档让你一筹莫展，或者Dan Abramov的博客让你觉得你在阅读从奥林匹斯山流传下来的古希腊文卷轴，你并不孤单,不是只有你这样认为。&emsp;&emsp;有时，React神殿的众神们很难将他们的智慧转化为我们其他人可以理解的语言。事情通常是这样的。你在使用React时遇到困难，用谷歌搜索你的问题，然后读到一个博客或Stack Overflow的帖子，其中的一些建议让你感到比开始时更迷茫。&emsp;&emsp;我当然也曾多次成为这种情况的受害者。特别是useEffect。在我们深入研究这个特殊的钩子之前，让我说我喜欢用hooks来写React，而且不想再回到类中去。这就是说，useEffect是一个很大的痛点。 到底什么是“effect副作用”&emsp;&emsp;为了让你真正理解useEffect，让我们退后一点，谈谈编程和JavaScript。&emsp;&emsp;useEffect的名字就是我们亲切地称为 “副作用 “的效果。&emsp;&emsp;那么什么是副作用呢？它是一段代码，它伸出手来……做别的事情。这是一个抽象的概念，所以让我们用例子来说明。&emsp;&emsp;这里有一个没有副作用的函数。 123function add(a, b) &#123; return a + b&#125; &emsp;&emsp;函数add除了接受一个输入并返回一个输出外，什么也没做。它并没有伸手到自身以外的地方去捣乱!&emsp;&emsp;我们来介绍一个副作用。 1234567const resultDiv = document.getElementById('add-example')function add(a, b) &#123; const result = a + b resultDiv.textContent = `The Result is $&#123;result&#125;` return a + b&#125;add(3, 4) 1&lt;div id&#x3D;&quot;add-example&quot;&gt;&lt;&#x2F;div&gt; &emsp;&emsp;现在，我们的函数伸到了自身之外来更新DOM（Document Object Model的缩写），并显示了结果。这个额外的行为是一个副作用。 React中的副作用&emsp;&emsp;那么React呢？它是一个几乎只更新DOM的库。一个视图库，如果你愿意的话。那么在React中，你会把什么叫做副作用呢？&emsp;&emsp;任何在更新页面之外的东西。如果你不使用React来更新状态或渲染HTML，那就是一个副作用。它是任何非React的东西。&emsp;&emsp;这意味着任何时候你调用API，使用setInterval/setTimeout，添加键盘监听器，或者真的任何时候你搞乱窗口对象，你都在引入副作用。&emsp;&emsp;hooks很神奇，让你写出真正可读、可重用的代码……除了当你处理副作用的时候。这很不幸，因为当你仔细想想，作为网络开发者，我们所做的大多数有趣的事情都是围绕着副作用展开的。&emsp;&emsp;让我们从钩子上退一步，看看我们如何在基于类的组件中处理副作用。 类组件和副作用&emsp;&emsp;在基于类的组件中，我们会使用生命周期方法来执行侧面效果。例如，在componentDidMount上，我们会调用API来获取渲染的数据。&emsp;&emsp;”为什么不在构造函数中调用API？”你可能会问。好吧，因为React说我们用于渲染的东西都在 “状态 “中，在我们的组件被加载到页面上之前，我们不能乱用状态。如果我们试图在组件加载之前更新状态，就会出现错误。&emsp;&emsp;下面是一个典型的基于类的组件的情况,这是一个小精灵的例子（后面会用hooks改写）。 1234567891011121314151617181920212223242526272829303132class Pokemon extends React.Component &#123; constructor() &#123; super() this.state = null &#125; componentDidMount() &#123; fetch('https://pokeapi.co/api/v2/pokemon/gengar/') .then(res =&gt; res.json()) .then(res =&gt; &#123; this.setState(res) &#125;) &#125; render() &#123; const pokemon = this.state const style = &#123;textTransform: 'capitalize'&#125; return ( &lt;div&gt; &#123; pokemon ? &lt;&gt; &lt;img src=&#123;pokemon.sprites.front_default&#125; alt=&#123;'Image of ' + pokemon.name&#125;/&gt; &lt;p style=&#123;style&#125;&gt;Name: &#123;pokemon.name&#125;&lt;/p&gt; &lt;p style=&#123;style&#125;&gt; Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125; &lt;/p&gt; &lt;/&gt; : 'Loading...' &#125; &lt;/div&gt; ) &#125;&#125; &emsp;&emsp;这样做很好，除了不这样做的时候。当我们想再次点击API来抓取不同的小精灵时会发生什么？如果这个组件被连接到我们的应用程序中的某个路由上，而这个路由发生了变化，但这个组件并没有卸载/重装。如果用户进入了不同的页面，而组件在API调用结束前就卸载了怎么办？&emsp;&emsp;答案是增加更多的生命周期方法，如componentDidUpdate和componentWillUnmount，以执行更多的API调用，防止奇怪的卸载错误。所以我们添加了这些生命周期方法来处理我们所有的边缘情况。当我们完成后，我们发现我们的大部分组件都是由生命周期代码组成的。 然后来试一下Hooks&emsp;&emsp;React团队意识到，类的API有点笨重，难以推理。人们正在制作生命周期流程图，试图了解React的内部运作……这是一个混乱。&emsp;&emsp;因此，在2018年10月的ReactConf上，在Sophie Alpert概述了类的使用有多么糟糕之后，Dan Abramov上台介绍了钩子（你可以在这里观看视频）。&emsp;&emsp;钩子在功能组件中引入了状态性，以及处理副作用的新方法。钩子使React的代码更容易重复使用，而且代码量更少–这是一个巨大的胜利！但是有一个小问题。&emsp;&emsp;除了一个小问题。每次渲染，整个组件/功能都要重新运行。&emsp;&emsp;让我们看一个基于Hooks开发的例子： 1234567891011function RerenderExample() &#123; const [bool, setBool] = React.useState(false) const randomNum = Math.random() return ( &lt;div&gt; &lt;p&gt;This number will be different each time you click the button:&lt;/p&gt; &lt;p&gt;&#123;randomNum&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setBool(!bool)&#125;&gt;Trigger a render&lt;/button&gt; &lt;/div&gt; )&#125; &emsp;&emsp;我们在渲染的JSX中甚至没有使用bool，但每次状态改变时，整个函数都会运行。每次渲染，组件内的所有东西都会重新运行：函数定义、变量创建/分配等等。&emsp;&emsp;如果你在想 “如果我必须在组件中做一些计算量大的事情怎么办？这不可能是高性能的……”，这是个敏锐的观察。在一个功能性组件中进行昂贵的操作是不可能有性能的。事实上，useCallback和useMemo的存在正是为了解决这个问题而设置的避难所。Kent C Dodds在这里对这些问题有一个挑战性的解读，但总结起来，根据Kent的说法，在你看到性能影响之前，你不应该担心重读的问题。 注意：如果你对钩子不熟悉，请把这篇文章收藏起来，等你准备好了再来看看。除非你必须要担心记忆化的问题&emsp;&emsp;像useState这样的钩子采用了一些内在的魔法来避免重现的问题。这很好，而且使用useState似乎很简单，但是当你需要做设置状态以外的事情时，怎么办？&emsp;&emsp;使用useEffect。那些讨厌的生命周期方法没有了，万岁！然而，这个钩子也有它自己的奇怪之处。首先让我们来看看语法。 12345//accepts two arguments: a function, and dependency arrayuseEffect(() =&gt; &#123; // do stuff return () =&gt; &#123;&#125; //function to undo our stuff from above when component unmounts&#125;, []) //dependency array of things to watch for changes on &emsp;&emsp;所以你给useEffect传递一个要运行的回调函数，其中包含你的副作用，然后是一个要观察的事物的数组。如果被监视的事物发生变化，useEffect将重新运行我们的回调函数。如果你需要在卸载时清理你的副作用，返回一个包含该代码的函数。&emsp;&emsp;让我们看看我们的小精灵的例子，用钩子和useEffect。 1234567891011121314151617181920212223242526function Pokemon() &#123; const [pokemon, setPokemon] = React.useState(null) React.useEffect(() =&gt; &#123; fetch('https://pokeapi.co/api/v2/pokemon/gengar/') .then(res =&gt; res.json()) .then(res =&gt; &#123; setPokemon(res) &#125;) &#125;, []) // empty array means nothing to watch, so run once and no more const style = &#123;textTransform: 'capitalize'&#125; return ( &lt;div&gt; &#123; pokemon ? &lt;&gt; &lt;img src=&#123;pokemon.sprites.front_default&#125; alt=&#123;'Image of ' + pokemon.name&#125;/&gt; &lt;p style=&#123;style&#125;&gt;Name: &#123;pokemon.name&#125;&lt;/p&gt; &lt;p style=&#123;style&#125;&gt; Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125; &lt;/p&gt; &lt;/&gt; : 'Loading...' &#125; &lt;/div&gt; )&#125; &emsp;&emsp;如果你盯着那个空的依赖性数组，你已经注意到了第一个useEffect的怪癖。通过传递一个空数组，我们在说 “只做这一次”。React万神殿告诉我们，在极少数情况下这是可以的，但大多数时候你都希望里面有东西。原因是，通常你想与你的代码中的东西同步，而不是只执行一次效果。例如，如果我们的小精灵组件依赖于一个路由参数或道具，任何可以说 “去获得一个新的小精灵 “而不需要挂载/卸载的东西呢？&emsp;&emsp;比方说，我们的组件依赖于一个道具pokemonToGet，它是一个参数，告诉它要从API中获得哪些小精灵。让我们也为测试目的添加一个小小的表单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Pokemon(&#123;pokemonToGet&#125;) &#123; const [pokemon, setPokemon] = React.useState(null) React.useEffect(() =&gt; &#123; fetch(`https://pokeapi.co/api/v2/pokemon/$&#123;pokemonToGet&#125;/`) .then(res =&gt; res.json()) .then(res =&gt; &#123; setPokemon(res) &#125;) &#125;, [pokemonToGet]) // get a new pokemon with the pokemonToGet prop changes const style = &#123;textTransform: 'capitalize'&#125; return ( &lt;div&gt; &#123; pokemon ? &lt;&gt; &lt;img src=&#123;pokemon.sprites.front_default&#125; alt=&#123;'Image of ' + pokemon.name&#125;/&gt; &lt;p style=&#123;style&#125;&gt;Name: &#123;pokemon.name&#125;&lt;/p&gt; &lt;p style=&#123;style&#125;&gt; Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125; &lt;/p&gt; &lt;/&gt; : 'Loading...' &#125; &lt;/div&gt; )&#125;function PokemonForm() &#123; const [inputValue, setInputValue] = React.useState(\"rowlet\") const [pokemonToGet, setPokemonToGet] = React.useState(\"gengar\") function getPokemon() &#123; setPokemonToGet(inputValue.trim().toLowerCase()) setInputValue(\"\") &#125; return ( &lt;div&gt; &lt;input onChange=&#123;(e) =&gt; setInputValue(e.target.value)&#125; value=&#123;inputValue&#125; type=\"text\"/&gt; &lt;button onClick=&#123;getPokemon&#125;&gt; Get Pokemon &lt;/button&gt; &lt;Pokemon pokemonToGet=&#123;pokemonToGet&#125; /&gt; &lt;/div&gt; )&#125;render(&lt;PokemonForm /&gt;) &emsp;&emsp;很好，现在我们的组件根据我们的道具变化获取了一个新的小精灵。如果使用类，我们就必须使用componentDidUpdate之类的东西来达到类似的效果。&emsp;&emsp;Ryan Florence在推特上对useEffect的用法做了很好的总结。 The question is not “when does this effect run” the question is “with which state does this effect synchronize with” useEffect(fn) // all state useEffect(fn, []) // no state useEffect(fn, [these, states]) &emsp;&emsp;他提到的 “所有状态 “的情况，即你没有传入任何依赖关系的情况是一个奇怪的情况。我个人从未发现它的用途。我们知道整个组件在每次渲染时都会运行，所以我想知道是否有一些奇怪的边缘情况需要你使用useEffect(fn)而不使用任何依赖阵列。在任何情况下，大多数时候你都会用这个方法：useEffect(fn, [these, states])。 UseEffect和Previous State: 事情败露的地方。&emsp;&emsp;到目前为止，useEffect的心理模型似乎很简单：将它与你选择的某些状态变化同步。问题是，当你需要在一个效果中引用该状态，而不仅仅是知道它是否发生了变化。&emsp;&emsp;在useEffect中，你无法获得对当前状态的访问。&emsp;&emsp;在我们的API调用例子中，我们没有看到这一点，因为我们只是覆盖了之前的状态。&emsp;&emsp;让我们看一个简单的例子: 12345678910111213function Timer() &#123; const [count, setCount] = React.useState(0); React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; setCount(count + 1) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count&#125;&lt;/div&gt; )&#125; &emsp;&emsp;似乎我们做了所有正确的事情（甚至清理了卸载时的副作用），但我们的计数器没有递增。这是一个问题吗？我们是否无法访问setInterval所属的窗口对象？&emsp;&emsp;不是，也不是。如果你把console.log添加到那个间隔中，你会看到它每秒钟都在跳动。&emsp;&emsp;我可以证明给你看: 12345678910111213141516171819function Timer() &#123; const [count, setCount] = React.useState(0) const [randomNum, setRandomNum] = React.useState(0) React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; setCount(count + 1) setRandomNum(Math.random()) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt; &lt;p&gt;The count is: &#123;count&#125;&lt;/p&gt; &lt;p&gt;RandomNum is &#123;randomNum&#125;&lt;/p&gt; &lt;/div&gt; )&#125; &emsp;&emsp;注意，我们每秒钟都会得到一个新的随机数。我们的时间间隔代码是好的。&emsp;&emsp;我们能够设置新的状态，但无法访问当前状态。&emsp;&emsp;这就是一个 “陈旧的闭包”。我不会去讨论闭包，但只需知道，由于React/hooks的实现，在我们的间隔函数中，count变量总是会是0。这是一个旧的参考。&emsp;&emsp;事实证明，像上面这样的简单例子有一个解决方案，正如John Tucker所指出的（谢谢John！）。和基于类的组件中的setState一样，useState也可以接受一个回调函数，接收之前的状态作为一个参数。React文档也注意到了这一点。&emsp;&emsp;下面是一个快速修复的例子。 123456789101112131415function Timer() &#123; const [count, setCount] = React.useState(0); React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; //let's pass a function instead //the argument is the current state setCount(count =&gt; count + 1) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count&#125;&lt;/div&gt; )&#125; &emsp;&emsp;不过，这仍然不能解决我们所有的问题。如果你需要在useEffect中访问最新的状态，但不更新它，你将不得不开始用setState回调来包装你的useEffect代码，然后在最后返回未改变的状态。这很快就会变成一个绝对的混乱，特别是当你在处理多个状态值的时候。&emsp;&emsp;另一个可能的解决方案是只使用useReducer，因为它可以接收之前的状态，但是用副作用填充你的reducer也显得非常混乱，而且我不建议任何人完全停止使用useState。&emsp;&emsp;无论如何，在写钩子的时候，我已经陷入了陈旧的闭包陷阱很多很多次。我甚至不知道它有个名字，直到我在Svelte背后的人Rich Harris的演讲中看到它&emsp;&emsp;显然，我也不是唯一一个在钩子上被它们绊倒的人。&emsp;&emsp; React甚至在他们的文档中提到了这一点。 “Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in.” 译：组件内的任何功能，包括事件处理程序和效果，都能 “看到 “它所创建的渲染中的道具和状态。&emsp;&emsp;我之前读过这个，在真正深入了解这个问题之前，我觉得没什么意义。我想象这可能是React的一个不好的点，所以也许他们不希望太大声地叫出来。&emsp;&emsp;然而，Dan Abramov在他的博客中更好地描述了这个问题，甚至提供了一个解决方案。“Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref.” 译：效果总是 “看到 “它们所定义的渲染中的道具和状态。这有助于防止bug，但在某些情况下会很烦人。对于这些情况，你可以明确地在一个可变的上下文中保存一些值。 &emsp;&emsp;这很有帮助，因为它以useRef的形式提供了一个解决方案（感谢Dan！），但它让我对如何帮助避免这个问题一无所知（主要是因为我不了解useRef）。 什么是“ref”，你会怎么使用它&emsp;&emsp;传统上，引用的目的是让你直接访问一个html元素。例如，假设你需要关注一个输入字段。你必须跳出React，使用常规的JavaScript来调用.focus()。钩子实际上让这一切变得相当简单。 1234567891011function InputField() &#123; const inputRef = React.useRef() return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;inputRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt; Click to Focus the input &lt;/button&gt; &lt;/div&gt; )&#125; &emsp;&emsp;很好! 当我们需要的时候，Refs是访问本地DOM APIs的一个简单的逃生通道。&emsp;&emsp;…但这如何帮助我们解决我们陈旧的关闭计数器的例子呢？ 使用“Refs”来避免陈旧的闭包&emsp;&emsp;React文档将“Refs”比作 “实例变量”。我不知道那是什么意思（谢谢维基百科），所以我觉得那没什么用。&emsp;&emsp;我设法通过这样思考来理解Refs的含义。&emsp;&emsp;Refs存在于重新渲染周期之外。&emsp;&emsp;把Refs看作是你设置在一边的一个变量。当你的组件重新运行时，它会很高兴地跳过这个反射，直到你用.current调用它。&emsp;&emsp;让我们看看对我们的定时器例子的修正。 12345678910111213141516function Timer() &#123; const [count, setCount] = React.useState(0) const countRef = React.useRef(0) React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; countRef.current = countRef.current + 1 setCount(countRef.current) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count&#125;&lt;/div&gt; )&#125; &emsp;&emsp;如果我们想把计时器停在比如说10的位置，我们可以很容易地用refs来做。 123456789101112131415161718function Timer() &#123; const [count, setCount] = React.useState(0) const countRef = React.useRef(0) React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; if (countRef.current === 10) return clearInterval(intervalId) countRef.current = countRef.current + 1 setCount(countRef.current) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count&#125;&lt;/div&gt; )&#125; &emsp;&emsp;为了便于比较，这里是使用setState回调方法的替代方案。 1234567891011121314151617181920function Timer() &#123; const [count, setCount] = React.useState(0) React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; setCount(count =&gt; &#123; if (count === 10) &#123; clearInterval(intervalId) return count &#125; else return count + 1 &#125;) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count&#125;&lt;/div&gt; )&#125; &emsp;&emsp;可以看到这很快就会接近回调地狱，所以如果你在做更复杂的事情，我会提醒你不要使用回调方法。 State Versus Refs&emsp;&emsp;是否有可能完全抛弃状态而只使用refs？&emsp;&emsp;你可能倾向于认为你可以用 refs 来代替你的组件的状态，从而避开所有这些奇怪的行为。&emsp;&emsp;你不能这样做。refs不是反应性的。当你改变一个 ref 时，它不会导致重新渲染。记住，它们存在于重新渲染周期之外。&emsp;&emsp;以下是不可能的: 123456789101112131415function Timer() &#123; const count = React.useRef(0) React.useEffect(() =&gt; &#123; const intervalId = setInterval(() =&gt; &#123; count.current = count.current + 1 //console.log('Ref example count: ' + count.current) &#125;, 1000) return () =&gt; clearInterval(intervalId) &#125;, []) return ( &lt;div&gt;The count is: &#123;count.current&#125;&lt;/div&gt; )&#125; &emsp;&emsp;那个组件实际上是在内部进行计数，但它并没有导致HTML的更新。你需要useState来实现这一点。如果你不相信我的话，请继续取消对console.log的注释）。&emsp;&emsp;这里有一个例子来证明Refs与state。 12345678910111213141516171819function Counter() &#123; const [count, setCount] = React.useState(0) const countRef = React.useRef(0) return ( &lt;div&gt; &lt;p&gt;State Count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Increment State Count &lt;/button&gt; &lt;p&gt;Ref Count: &#123;countRef.current&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; countRef.current = countRef.current + 1&#125;&gt; Increment Ref Count &lt;/button&gt; &lt;/div&gt; )&#125;render(&lt;Counter/&gt;) &emsp;&emsp;在你通过设置状态触发重新渲染之前，你不会看到Ref计数的变化。 离别感言&emsp;&emsp;我喜欢React中的钩子和功能组件，但我所概述的怪异现象让我暂停了。我不喜欢被要求对React的内部工作了解这么多才能使用它。我认为这给学习React的人带来了障碍，我希望将来React团队能想出一些更好的方法来处理这些问题。 翻译结束很棒的文章。","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"Touch和Mouse事件","slug":"touch和mouse事件","date":"2021-06-07T00:28:00.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2021/06/07/touch和mouse事件/","link":"","permalink":"https://feidom-up.github.io/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"一个问题引发的思考移动端的一个页面，猜测哈，hover事件&amp;mouseover事件都被监听时，mouse应该失效吧。因为移动端只有点触，没有mouse。事实：出现mouseover（定义了这个时候的样式）状态，就很奇怪。然后，本以为mouse和touch在浏览器中是这样的： pc端：mouse事件生效，touch事件失效 移动端：mouse事件失效，touch事件生效 但是，结果是这样的：同时监听了mouse和touch两种事件，在ios移动设备中的safari浏览器中，点击触发touch事件之后，定义的mouseover事件也触发了，产生了bug。 研究它敲黑板： pc端：onTouch事件会被屏蔽。 移动端：两种事件都会被触发。且顺序是这样的： touchstart touchmove touchend mouseover mousemove mousedown mouseup click 好吧，这是这一切出现的原因。在适配多种设备的项目中，怎么区分这两种事件，让mouse事件在移动端失效呢。 方法： 设置一个flag，mouse事件时判断touchFlag决定return或者执行。 分开写，判断设备后需要mouse的写mouse，需要touch的写touch。 最好的方法：preventDefault() Use preventDefault() inside touch event handlers, so the default mouse-emulation handling doesn’t occur. preventDefault()专门挑出来说一下这个：preventDefault()【该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。】于是，在touchstart方法中使用e.preventDefault()去阻止之后的mouseover事件。报错了：Unable to preventDefault inside passive event listener due to target being treated as passive. 翻译： 由于目标被视为被动，无法在被动事件监听器内防止。 passive 的事件监听器12345addEventListener(type, listener, &#123; capture: false, passive: true, once: false&#125;) 三个属性都是布尔类型的开关。其中 capture 属性等价于以前的 useCapture 参数；once 属性就是表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它；passive 属性在 Firefox 和 Chrome 已经实现。很多移动端的页面都会监听 touchstart 等 touch 事件，像这样： 123document.addEventListener(\"touchstart\", function(e)&#123; ... // 浏览器不知道这里会不会有 e.preventDefault()&#125;) 由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。 Passive Event Listeners：就是告诉前页面内的事件监听器内部是否会调用preventDefault函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，代表该监听器内部不会调用preventDefault函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性当前仅支持mousewheel/touch相关事件。 耗时是什么当用户在移动设备上点击网页中的某个元素时，没有为移动交互设计的网页在触摸开始事件和处理鼠标事件（mousedown）之间至少有300毫秒的延迟。如果你有触摸设备，你可以看看这个例子。或者，使用Chrome浏览器，你可以在Chrome开发者工具中打开 “模拟触摸事件”，以帮助你在非触摸系统上测试触摸界面! 这个延迟是为了让浏览器有时间判断用户是否在做其他手势–特别是双击缩放。很明显，在你想对手指触摸做出即时反应的情况下，这可能是个问题。目前正在进行的工作是试图限制这种延迟自动发生的情况。 Chrome for Android Android Browser Opera Mobile for Android Firefox for Android Safari iOS Non-scalable viewport No delay 300ms 300ms No delay 300ms No Viewport 300ms 300ms 300ms 300ms 300ms 避免这种问题的一个简单方法，就是直接告诉浏览器，我这个页面不需要滚动：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt;，一般在移动端这样写可以。 综上： 事件监听时，设置第三个参数中：passive为false，告诉浏览器我要自己控制preventDefault函数来阻止事件的默认行为。 如下： 12345678910111213private onTouchStart(e:MouseEvent) &#123; e.preventDefault(); console.log('onTouchStart', e.cancelable);&#125;private onMouseOver(e:MouseEvent) &#123; console.log('onMouseOver', e.cancelable);&#125;componentDidMount() &#123; if (this.touchElement) &#123; this.touchElement.addEventListener('touchstart', this.onTouchStart, &#123;passive: false&#125;); this.touchElement.addEventListener('mouseover', this.onMouseOver, &#123;passive: false&#125;); &#125;&#125; 123456&lt;div styleName=&#123;'btn-start-wrap'&#125; ref=&#123; (ref) =&gt; &#123; if (ref) &#123; this.touchElement = ref; &#125;&#125;&#125;&gt; 以上的代码touchstart后不会触发mouseover。实现了阻止移动端也触发mouse事件的逻辑。 参见： Passive Event Listeners——让页面滑动更加流畅的新特性 紫云飞 – passive 的事件监听器 touch&amp;mouse","categories":[{"name":"移动端","slug":"移动端","permalink":"https://feidom-up.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://feidom-up.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"webpackPlugins","slug":"webpackPlugins","date":"2021-05-28T02:07:55.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2021/05/28/webpackPlugins/","link":"","permalink":"https://feidom-up.github.io/2021/05/28/webpackPlugins/","excerpt":"","text":"webpack.DefinePlugin 简介在编译时创建一个可以配置的全局变量，在区分开发模式｜生产模式的不同时十分有用。 使用： 在webpack的plugins中，增加webpack.DefinePlugin(Object)的实例 方法中传入的Object的key值，可以在项目所有import的文件中使用。 使用时得到的是key对应额value，这里在编译时，并不是变量的引用，而是编译时直接替换 因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。 文档地址 webpack.DefinePlugin","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"vue3的数据响应式系统","slug":"vue3的数据响应式系统","date":"2021-03-19T07:54:57.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2021/03/19/vue3的数据响应式系统/","link":"","permalink":"https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Vue2.0的数据监听Object.defineProperty 12345678910111213141516const object1 = &#123;&#125;;Object.defineProperty(object1, 'property1', &#123; value: 42, writable: false, get()&#123;&#125;, set(newValue) &#123; bValue = newValue; &#125;, enumerable : true, configurable : true&#125;);object1.property1 = 77;// throws an error in strict modeconsole.log(object1.property1);// expected output: 42 Vue3.0的数据响应式系统proxy get\\set 12345678910111213141516// 引用vue-next(3)源码中'packages/reactivity/dist/reactivity.global.js'const &#123;reactive, effect&#125; = VueObserver;// reactive: 把数据处理成为响应式数据// effect: // 1.首先会执行一次对应的监听函数// 2.修改对应监听函数内使用的响应式数据，对应的监听函数就会立即执行，重新执行的过程就会获取新的数据const yideng = &#123;count: 0&#125;;const state = reactive(yideng);const fn = ()=&gt;&#123; const count = state.count; const.log('当前的count', count) //render(count) 如果在这触发render渲染&#125;effect(fn)","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"vue源码解读","slug":"vue源码解读","permalink":"https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"数据结构与算法之队列","slug":"数据结构与算法之队列","date":"2021-03-17T10:44:26.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2021/03/17/数据结构与算法之队列/","link":"","permalink":"https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/","excerpt":"","text":"队列 特性：先进先出 解题法则： 题目具备广度遍历（分层遍历）和顺序输出的特点，就应该想到用FIFO 队列来试一试。 滑动窗口类型题 模板： 分层遍历 循环队列 单调队列 普通队列 例题1：从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。 输入： 3 9 8 6 7 输出：[[3], [9, 8], [6, 7]] 二叉树的层次遍历的解题技巧 遍历方式的变化： 二叉树的锯齿形遍历 二叉树层次倒序遍历 层的信息变化 二叉树的层平均值 二叉树最深层的叶节点的和 二叉树的最大宽度 树的变化 N叉树的层次遍历 N叉树的最大深度 循环队列 重点： 循环使用固定空间 难点： 控制好 front/rear 两个首尾指示器 空队列和满队列的判断，在于used变量 例题2：设计一个可以容纳 k 个元素的循环队列。需要实现以下接口： 12345678910111213141516class MyCircularQueue &#123; // 参数k表示这个循环队列最多只能容纳k个元素 public MyCircularQueue(int k); // 将value放到队列中, 成功返回true public boolean enQueue(int value); // 删除队首元素，成功返回true public boolean deQueue(); // 得到队首元素，如果为空，返回-1 public int Front(); // 得到队尾元素，如果队列为空，返回-1 public int Rear(); // 看一下循环队列是否为空 public boolean isEmpty(); // 看一下循环队列是否已放满k个元素 public boolean isFull();&#125; 单调队列 概念： 要求队列中的元素必须满足单调性，比如单调递增，或者单调递减。单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于： FIFO 队列只能从尾部添加元素，首部弹出元素； 双端队列可以从首尾两端 push/pop 元素。 注意： 单调队列在入队的时候，需要满足 2 点： 入队前队列已经满足单调性； 入队后队列仍然满足单调性。 例题3：滑动窗口的最大值 输入：nums = [1,3,-1,-3,5,3], k = 3 输出：[3,3,5,5] 符合单调递减队列！ 例题4： 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？ 输入：[1,-1,-100,-1000,100,3], k = 2 输出：4 解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。","categories":[{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://feidom-up.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"手写代码系列之New(fn)","slug":"手写代码系列之New-fn","date":"2021-03-17T00:46:47.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2021/03/17/手写代码系列之New-fn/","link":"","permalink":"https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/","excerpt":"","text":"New操作符做了哪些事 创建了一个全新的对象。 会被执行[[Prototype]]（也就是proto）链接。 使this指向新创建的对象。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 实现 版本一： 12345678910111213141516171819function myNew(fn)&#123; return function()&#123; // 创建一个对象，且将其隐式原型指向构造函数原型 let obj = &#123; __proto__: fn.prototype &#125; // 执行构造函数 fn.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;// 使用示例：function Person(name, age)&#123; this.name = name this.age = age&#125;let obj = myNew(Person)('chen', 18) 版本二： 12345678910111213141516function myNew(fn)&#123; let res = &#123;&#125;; if(fn.prototype !==null)&#123; res.__proto__ = fn.prototype; &#125; let ret = fn.apply(res, Array.prototype.slice.call(arguments, 1)); if(typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null&#123; return ret &#125; return res&#125;// 使用示例：function A() &#123;&#125;var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2);","categories":[{"name":"手写代码系列","slug":"手写代码系列","permalink":"https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"手写代码系列之防抖与节流","slug":"手写代码系列之防抖与节流","date":"2021-03-16T07:26:28.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2021/03/16/手写代码系列之防抖与节流/","link":"","permalink":"https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖思路：在规定时间内未触发第二次，则执行 1234567891011121314151617181920function debounce(fn, delay)&#123; // 利用闭包保存定时器 let timer = null; return function()&#123; let context = this; let args = arguments; // 在规定时间内再次触发 // 会先清除定时器再重设定时器 clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args) &#125;,delay); &#125;&#125;// 使用举例：function fn1()&#123; console.log(\"防抖\")&#125;addEventListener(\"scroll\", debounce(fn1, 1000)) 节流思路：在规定时间内只触发一次 12345678910111213141516171819function throttle(fn, delay)&#123; // 利用闭包保存时间 let prev = Date.now(); return function()&#123; let context = this; let args = arguments; let now = Date.now(); if(now - prev &gt;= delay)&#123; fn.apply(context, args); prev = Date.now(); &#125; &#125;&#125;// 使用举例：function fn2()&#123; console.log(\"节流\")&#125;addEventListener(\"scroll\", throttle(fn2, 1000))","categories":[{"name":"手写代码系列","slug":"手写代码系列","permalink":"https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"手写代码咔咔咔","slug":"手写代码咔咔咔","date":"2021-03-16T07:24:51.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2021/03/16/手写代码咔咔咔/","link":"","permalink":"https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/","excerpt":"","text":"咔咔咔 手写代码系列之防抖与节流 手写New 手写Promise 手写Promise.all 二叉树的深及遍历 version版本对比 一个字符串最大的回文字符串 三数之和 手写indexof 手写EventEmitter 手写Redux.createStore 手写深拷贝、深拷贝函数","categories":[{"name":"手写代码系列","slug":"手写代码系列","permalink":"https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"数据结构与算法之栈结构","slug":"数据结构与算法之栈结构","date":"2021-03-16T07:15:17.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2021/03/16/数据结构与算法之栈结构/","link":"","permalink":"https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/","excerpt":"","text":"栈 特性：先进后出 解题法则： 题目中有配对、消除的题意，优先考虑栈结构 栈中存放的可以是内容本身和内容的索引 数组中右边第一个比我小的元素的位置，求解用递增栈 较小的数消除掉较大的数的时候，使用递增栈。 根据题意总结入栈与出栈的时机 普通栈 规律性：配对、消除 例题1：字符串中只有字符’(‘和’)’。合法字符串需要括号可以配对。比如： 输入：”()” 输出：true 解释：()，()()，(())是合法的。)(，()(，(()是非法的。 请你实现一个函数isValid(s)，来判断给定的字符串是否合法。 针对例1这种内容一样时，可以使用计数器优化 例题拓展： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合 左括号必须以正确的顺序闭合 注意空字符串可被认为是有效字符串 请实现isValid(s) 例题2：在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件: 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离； 当方向相对时，大鱼会吃掉小鱼； 鱼的大小都不一样。 输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0] 输出：3 完成solution(Size, Dir)来计算还剩下几条鱼？ 单调栈 定义：单调栈就是指栈中的元素必须是按照升序排列的栈，或者是降序排列的栈。 升序排列的栈称为递增栈 降序排列的栈称为递减栈 特点：任何时候都需要保证栈的有序性 例题1：一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。（找出数组中右边比我小的元素） 输入：[5, 2] 输出：[1, -1] 解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。 类似题：数组中右边第一个比我大的元素的位置数组中元素左边离我最近且比我小的元素的位置数组中元素左边离我最近且比我大的元素的位置 例题2：给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。 输入：nums = [3,5,2,6], k = 2 输出：[2,6] 解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。 解题思路","categories":[{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://feidom-up.github.io/tags/%E6%A0%88/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2021-03-03T01:34:21.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2021/03/03/数据结构与算法/","link":"","permalink":"https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法四步分析法： 模拟：模拟题目的运行。 规律：尝试总结出题目的一般规律和特点。 匹配：找到符合这些特点的数据结构与算法。 边界：考虑特殊情况。 数据结构与算法 栈结构与算法","categories":[{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Virtual DOM的工作原理","slug":"虚拟dom","date":"2021-01-02T15:22:41.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2021/01/02/虚拟dom/","link":"","permalink":"https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"Virtual DOM 也被称为虚拟DOM 在react中，jsx语法经过babel解析转化为React.createElement()函数调用后生成ast抽象语法树，再通过render函数将ast树转换为fiber 结构，填入许多调度、更新、diff相关数据，并转换ast树为虚拟DOM树，再完成挂载。 在vue中，模版语法 经过 generate处理(正则匹配 生成 ast抽象语法树)，render中调用_c()/createElement()函数将ast树生成VNode(虚拟DOM),再完成挂载。 虚拟DOM的来源react的前身是facebook的XHP，在这个框架中，页面都是通过转义的方式生成的，并没有直接的HTML，确保在XHP中写出安全的静态页面。 初衷是： 简化前端开发（后端赋能） 防止xss攻击 发展是： 通过虚拟DOM规避风险，不让用户直接的操作DOM了，而是把它封起来自己管理 虚拟DOM的表现形式12345678&#123; tag: 'input', props: &#123; type: 'button', value: '' &#125;, childrean: []&#125; React 有两个函数 * diff 函数，去计算状态变更前后的虚拟 DOM 树差异 * 渲染函数，渲染整个虚拟 DOM 树或者处理差异点。 现在是不是有些理解为什么 React 与 ReactDOM 是两个库了？正是由于计算与渲染的分工。 其中 React 的主要工作是组件实现、更新调度；ReactDOM 提供了在 网页上渲染 的基础 虚拟DOM的优缺点优点 性能优越 规避XSS 可跨平台 但是不是所有的操作都是虚拟DOM更高效&emsp;&emsp;大量的直接操作DOM容易引起页面性能下降。这时React基于虚拟DOM的diff处理与批处理操作，可降低DOM的操作频次和范围，提升页面性能&emsp;&emsp;但是在首次渲染或者微量dom操作的时候，虚拟DOM的性能就更慢一些。 那虚拟 DOM 一定可以规避 XSS吗？&emsp;&emsp;虚拟 DOM 内部确保了字符转义，所以确实可以做到这点，但 React 存在风险，因为 React 留有 dangerouslySetInnerHTML API 绕过转义。 没有虚拟 DOM 不能实现跨平台吗？&emsp;&emsp;比如 NativeScript 没有虚拟 DOM 层 ，它是通过提供兼容原生 API 的 JS API 实现跨平台开发。那虚拟 DOM 的优势在哪里？&emsp;&emsp;实际上它的优势在于跨平台的成本更低。在 React Native 之后，前端社区从虚拟 DOM 中体会到了跨平台的无限前景，所以在后续的发展中，都借鉴了虚拟 DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟 DOM 的结构描述对象，来支撑多端转换。 缺点 内存占用较高 难以进行优化","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"},{"name":"vue","slug":"react/vue","permalink":"https://feidom-up.github.io/categories/react/vue/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"}]},{"title":"Serverless是什么","slug":"Serverless是什么","date":"2021-01-01T13:59:56.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2021/01/01/Serverless是什么/","link":"","permalink":"https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"是什么 广义上来说是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服务器”，但这并不代表着应用运行不需要服务器，而是开发者不需要关心服务器。而基于 Serverless 思想实现的软件架构就是 Serverless 架构。 狭义上说 狭义的 Serverless 是 FaaS 和 BaaS 的组合。 FaaS（Function as a Service）： FaaS本质上是一个函数运行平台，函数运行时，你对底层的服务器是无感知的，FaaS 产品会负责资源的调度和运维，这是它的特点之一，不用运维。 FaaS 中的函数也不是持续运行的，而是通过事件进行触发，比如 HTTP 事件、消息事件等，产生事件的源头叫触发器，FaaS 平台会集成这些触发器，我们直接用就行，这是 FaaS 的第二个特点，事件驱动。 FaaS 的第三个特点是按量付费。 FaaS 产品的收费方式，都是按照函数执行次数和执行时消耗的 CPU、内存等资源进行计费的。 FaaS 在运行函数的时候，会根据并发量自动生成多个函数实例，并且并发理论是没有上限的，这是它的第四个特点，弹性伸缩。 FaaS 每次执行函数时，都会初始化一个新的运行环境，然后从头开始执行整个代码，而不是只执行其中的 handler 方法。执行完毕后，运行环境就会被释放。这样每次函数执行，都是新的运行环境，自然不同函数之间就无法共用 pv 这个变量了。FaaS 的另一个特点，无状态。 BaaS（Backend as a Service） 为了解决分布式中的状态共享问题 BaaS 本质上就是把后端功能封装起来，以接口的形式提供服务。 总基于 FaaS 和 BaaS 的架构，是一种计算和存储分离的架构。 计算由 FaaS 负责，存储由 BaaS 负责，计算和存储也被分开部署和收费。这使应用的存储不再是应用本身的一部分，而是演变成了独立的云服务，降低了数据丢失的风险。而应用本身也变成了无状态的应用，更容易进行调度和扩缩容。 基于 FaaS 和 BaaS ，你的应用就实现了自动弹性伸缩、按量付费、不用关心服务器，这正是 Serverless 架构的必要因素。所以说狭义的 Serverless 是 FaaS 和 BaaS 的组合。 与其他架构的区别 PaaS PaaS （平台即服务）是云计算虚拟机时代的主要形态之一。 它是指云厂商提供开发工具、依赖库、服务和运行平台等能力，开发者可以依赖这些能力将自己的应用直接部署在云平台上，不用关心底层的计算资源、网络、存储等。虽然与Serverless 很类似，但依旧存在一些区别。 Kubernetes Kubernetes 是一种容器编排技术。在 Kubernetes 中应用运行的基本单位是 Pod（容器组），Pod 是应用及运行环境的集合，所以你也不用关心服务器了。基于 Kubernetes，你能很方便地进行 Pod 的管理，并且实现应用的弹性伸缩。 所以，Kubernetes 是介于 Serverful 和 Serverless 中间的产物。 Serverless 是云原生的一种实现，云原生的另一种实现是 Kubernetes。 Serverless PaaS （平台即服务） Kubernetes 按实际使用量付费 按资源付费 按照资源数量计费 Serverless 的优缺点 优点：不用运维、弹性伸缩、节省成本、开发简单、降低风险、易于扩展。 缺点： 依赖第三方服务：一旦你选择了一个云厂商，要想从一个云移到另一个台，成本很高 底层硬件的多样性：代码依赖的地层硬件多样性 应用性能瓶颈：函数运行前需要现初始化函数运行环境，这个过程需要消耗一定时间。因为函数不是持续“在线”的，而是需要运行的时候才启动（不像传统应用，服务是一直启动的）。 函数通信效率低：在 Serverless 应用中，函数与函数之间就完全独立了。如果两个函数的数据有依赖，需要进行通信、交换数据，就要进行函数与函数之间的调用（调用方式是 HTTP 调用）。相比之前的内存调用，数据交互效率显然低了很多。而这个问题的本质，是 FaaS 还没有比较好的数据通信协议或方案。 开发调试复杂：Serverless 架构正处于飞速发展的阶段，其开发、调试、部署工具链并不完善（基本是每个云厂商各玩各的）","categories":[],"tags":[{"name":"serverless","slug":"serverless","permalink":"https://feidom-up.github.io/tags/serverless/"}]},{"title":"React面向组件跨层级通信","slug":"React面向组件跨层级通信","date":"2020-12-31T09:13:02.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/12/31/React面向组件跨层级通信/","link":"","permalink":"https://feidom-up.github.io/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父与子父组件包裹子组件，父组件向子组件传递数据。123456789101112131415161718192021222324// 子 const Button = (&#123; text &#125;) =&gt; &#123; &lt;button type=\"button\"&gt;&#123;text&#125;&lt;/button&gt;&#125;// 父class HomePage extends React.Component &#123;state = &#123; text: \"默认文案\"&#125;asyc componentDidMount() &#123; const response = await fetch('/api/buttonText') this.setState(&#123; text: response.buttoText &#125;)&#125; render() &#123; const &#123; text &#125; = this.state return ( &lt;Button text=&#123;text&#125; /&gt; ) &#125;&#125; 这样的通信方式非常适用于展示组件。 子与父子组件存在于父组件之中，子组件需要向父组件传递数据。 回调函数（主要方式） 1234567891011121314151617181920212223242526272829303132333435363738// 子class FetchPosts extends React.Component &#123; state = &#123; loading: true, data: [] &#125; async componentDidMount() &#123; const response = await fetch('/api/posts') this.setState(&#123; data: response.data, loading: false, &#125;) &#125; render() &#123; if (this.state.loading) &#123; return &lt;Loading /&gt; &#125; return this.props.renderPosts(this.state.data) &#125;&#125;// 父class HomePage extends React.Component &#123; render() &#123; return ( &lt;FetchPosts renderPosts=&#123;posts =&gt; ( &lt;ul&gt; &#123;posts.map(post =&gt; ( &lt;li key=&#123;post.id&#125;&gt; &lt;h2&gt;&#123;post.title&#125;&lt;/h2&gt; &lt;p&gt;&#123;post.description&#125;&lt;/p&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; /&gt;) &#125;&#125; 实例函数（不符合 React 的设计理念，不被推荐） 1234567891011121314151617181920212223import React from 'react'class HomePage extends React.Component &#123; modalRef = React.createRef() //实例 showModal = () =&#123; this.modalRef.show() &#125; hideModal = () =&gt; &#123; this.modalRef.hide() &#125; render() &#123; const &#123; text &#125; = this.state return ( &lt;&gt; &lt;Button onClick=&#123;this.showModal&#125;&gt;展示 Modal &lt;/Button&gt; &lt;Button onClick=&#123;this.hideModal&#125;&gt;隐藏 Modal &lt;/Button&gt; &lt;Modal ref=&#123;modalRef&#125; /&gt; &lt;/&gt; /&gt; ) &#125;&#125; 兄弟 两个组件并列存在于父组件中，数据需要进行相互传递，往往依赖共同的父组件进行中转。 12345678910111213141516171819202122232425262728293031323334// 子class Input extends React.Component &#123; handleChanged = (e) =&gt; &#123; this.onChangeText(e.target.text) &#125; render() &#123; return &lt;input onChange=&#123;handleTextChanged&#125; /&gt; &#125;&#125;// 子const StaticText = (&#123; children &#125;) =&gt; &#123; return ( &lt;P&gt;&#123;children&#125;&lt;/p&gt; )&#125;// 父class HomePage extends React.Component &#123; state = &#123; text: '默认文案' &#125; handleTextChanged = (text) =&gt; &#123; this.setState(&#123; text, &#125;) &#125; render() &#123; return ( &lt;&gt; &lt;Input onChangeText=&#123;this.handleTextChanged&#125; /&gt; &lt;StaticText&gt;this.state.text&lt;/StaticText&gt; &lt;/&gt; ) &#125;&#125; 无直接关系 两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据。 Context Context 第一个最常见的用途就是做 i18n i18n使用Context I18nContext1234567import &#123; createContext &#125; from 'react';const I18nContext = createContext(&#123; translate: () =&gt; '', getLocale: () =&gt; &#123;&#125;, setLocale: () =&gt; &#123;&#125;,&#125;);export default I18nContext; 用I18nContext封装个组件I18nProvider12345678910111213141516171819202122import React, &#123; useState &#125; from 'react';import I18nContext from './I18nContext';class I18nProvider extends React.Component &#123; state = &#123; locale: '', &#125; render() &#123; const i18n = &#123; translate: key =&gt; this.props.languages[locale][key], getLocale: () =&gt; this.state.locale, setLocale: locale =&gt; this.setState(&#123; loacal, &#125;) &#125; return ( &lt;I18nContext.Provider value=&#123;i18n&#125;&gt; &#123;this.props.children&#125; &lt;/I18nContext.Provider&gt; ) &#125;&#125;export default I18nProvider;\b 用I18nContext实现高阶组件withI18n123456789101112import React from 'react';import I18nContext from './I18nContext';const withI18n = () =&gt; &#123; return WrappedComponent =&gt; &#123; return (props) =&gt; ( &lt;I18nContext.Consumer&gt; &#123;i18n =&gt; &lt;WrappedComponent &#123;...i18n&#125; &#123;...props&#125; /&gt;&#125; &lt;/I18nContext.Consumer&gt; ) &#125;&#125;;export default withI18n; 在最顶层注入 Provider123456789101112131415import React from 'react';import ReactDOM from 'react-dom';import App from './App';import &#123; I18nProvider &#125; from './i18n';const locales = [ 'en-US', 'zh-CN' ];const languages = &#123; 'en-US': require('./locales/en-US'), 'zh-CN': require('./locales/zh-CN'),&#125;ReactDOM.render( &lt;I18nProvider locales=&#123;locales&#125; languages=&#123;languages&#125;&gt; &lt;App /&gt; &lt;/I18nProvider&gt;, document.getElementById('root')); 在需要的地方使用123456789101112const Title = withI18n( (&#123; translate &#125;) =&gt; &#123; return ( &lt;div&gt;&#123;translate('title')&#125;&lt;/div&gt; ) &#125;)const Footer = withI18n( (&#123; setLocale &#125;) =&gt; &#123; return ( &lt;Button onClick=(() =&gt; &#123; setLocale('zh-CN') &#125;) /&gt; ) &#125;) 全局变量 全局变量，顾名思义就是放在 Window 上的变量。但值得注意的是修改 Window 上的变量并不会引起 React 组件重新渲染。 状态管理框架 Flux Redux Mobx","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"如何设计react组件","slug":"如何设计react组件","date":"2020-12-29T11:33:19.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/12/29/如何设计react组件/","link":"","permalink":"https://feidom-up.github.io/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/","excerpt":"","text":"痛定思痛没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。 把一个页面写成一个组件 一个组件有3000行代码 基于场景的设计分类围绕“如何组合”根据不同的场景设计不同模式 组件的类别 无状态组件/哑组件/展示组件： 只做展示、独立运行、不额外增加功能的组件 优点： 展示组件的复用性更强，复用率更高 内部没有任何的state，只受制于外部的props传参 衍生出的其他组件设计 代理组件：基于ui框架的其他组件，外面封装一层，实现代理组件。 更换ui框架时更方便。解决了组件库的强依赖特性，实现无痛切换 都内聚在代理组件中，修改基础组件的属性更方便，不会散落在各处 样式组件：本质上也是一种代理组件，但是又细分了处理样式的领域，将当前的关注点分离在组件内 自身承接业务判断逻辑，封装了ui库中的组件来控制样式，改动会更方便更友好 布局组件： 基本设计与样式组件完全一样，增加了一个小优化 布局组件一般不根据状态改变，所以可以封装布局组件后，可以直接使用shouldComponentUpdate函数阻断渲染，提升性能 有状态组件/灵巧组件： 处理业务逻辑与数据状态的组件 灵巧组件更专注于业务本身；灵巧组件一定要至少包含一个灵巧组件或展示组件。功能更丰富，但复用率低 衍生出的其他组件设计 容器组件：几乎没有复用性，主要功能在拉取数据和组合组件 高阶组件： React中复用组件的高级技术，基于React组合特性形成的设计模式 道理类似函数式编程的高级函数（接收一个函数，返回一个函数），高阶组件接收参数为组件，返回值也是新一个组件。 可抽取公共逻辑 登陆态的判断1234567891011121314151617181920212223242526// 装饰器const checkLogin = () =&gt; &#123; return !!localStorage.getItem('token')&#125;// 装饰器写法@checkLoginclass UserPage extends React.Component &#123; ...&#125;@checkLoginclass OrderPage extends React.Component &#123; ...&#125;// 高阶函数const checkLogin = (WrappedComponent) =&gt; &#123; return (props) =&gt; &#123; return checkLogin() ? &lt;WrappedComponent &#123;...props&#125; /&gt; : &lt;LoginPage /&gt;; &#125;&#125;// 函数写法class RawUserPage extends React.Component &#123; ...&#125;const UserPage = checkLogin(RawUserPage) 页面埋点统计123456789101112131415161718192021222324252627282930const trackPageView = (pageName) = &#123; // 发送埋点信息请求 ... &#125;const PV = (pageName) =&gt; &#123; return (WrappedComponent) =&gt; &#123; return class Wrap extends Component &#123; componentDidMount() &#123; trackPageView(pageName) &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; /&gt; ); &#125; &#125; &#125;;&#125;@PV('用户页面')class UserPage extends React.Component &#123; ...&#125;@PV('购物车页面')class CartPage extends React.Component &#123; ...&#125;@PV('订单页面')class OrderPage extends React.Component &#123; ...&#125; 既要判断登陆态，又要埋点：链式调用 链式调用是函数式编程高级函数的一种使用场景。在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。 12345678910111213// 函数调用方式class RawUserPage extends React.Component &#123; ...&#125;const UserPage = checkLogin(PV('用户页面')(RawUserPage))// 装饰器调用方式@checkLogin@PV('用户页面')class UserPage extends React.Component &#123; ...&#125; 渲染劫持 渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素 1234567891011function withLoading(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if(this.props.isLoading) &#123; return &lt;Loading /&gt;; &#125; else &#123; return super.render(); &#125; &#125; &#125;;&#125; 通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。 高阶组件的缺点 丢失静态函数：由于被包裹了一层，所以静态函数在外层是无法获取的。 12345678910// UserPage.jsx@PV('用户页面')export default class UserPage extends React.Component &#123; static getUser() &#123; ... &#125; &#125;// page.jsimport UserPage from './UserPage'UserPage.checkLogin() // 调用失败，并不存在。 解决方案：在外部函数中把内部函数的方法复制出来：hoist-non-react-statics(现成的库) 1234567891011121314151617import hoistNonReactStatics from 'hoist-non-react-statics';const PV = (pageName) =&gt; &#123; return (WrappedComponent) =&gt; &#123; class Wrap extends Component &#123; componentDidMount() &#123; trackPageView(pageName) &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; /&gt; ); &#125; &#125; hoistNonReactStatics(Wrap, WrappedComponent); return Wrap; &#125;;&#125; refs 属性不能透传: ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例： 1234567891011121314151617181920function withLog(Component) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; // 将自定义的 prop 属性 “forwardedRef” 定义为 ref return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; // 注意 React.forwardRef 回调的第二个参数 “ref”。 // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef” // 然后它就可以被挂载到被 LogProps 包裹的子组件上。 return React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;);&#125;// 这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。 所以：组件的目录结构1234567// 通过目录级别完成切分 src ├── components │ ├── basic // 最基本的展示组件放入 basic 目录中 建议使用类似 Storybook 的工具进行组件管理。 │ ├── container //将容器组件放入 container │ └── hoc //高阶组件放入 hoc 中 └── pages //将页面外层组件放在页面目录中 Storybook官网","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"react的类组件和函数组件","slug":"react的类组件和函数组件","date":"2020-12-29T11:01:39.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2020/12/29/react的类组件和函数组件/","link":"","permalink":"https://feidom-up.github.io/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/","excerpt":"","text":"react的最小单位是组件 相同点 实际用途是一样的，都可作为基础组件展示UI 在现代浏览器中，除极端场景下，类（类组件）和闭包（函数组件）的性能差异不大 区别点 代码实现思想 类组件的根基是OOP，面向对象编程 函数组件的根据是FP，函数式编程 使用场景 类组件使用生命周期 函数组件使用react hooks实现类似生命周期的能力 设计模式 类组件可以实现继承 函数组件缺少继承能力 react前端思想：组合优于继承（继承的灵活性差，细节屏蔽过多） 性能优化 类组件依靠shouldComponentUpdate函数阻断渲染 函数组件依靠React.memo()来优化 React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。 未来趋势 基于hooks的加持，react社区主推函数组件 优劣性 类组件 this的模糊性 业务逻辑散落在生命周期中 类组件缺乏标准的拆分方式 函数组件 基于函数式编程的优点（输入输出恒定，无副作用等），函数组件更纯粹、简单、易测试。 闭包捕获的值优于this的模糊性，捕获的值永远是确定且安全的 更细腻的逻辑组织和复用，更好的作用于时间切片与并发模式 由于函数组件的执行从来都是自顶向下，依赖于dom diff算法不至于频繁渲染","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"react生命周期爬坑","slug":"react生命周期爬坑","date":"2020-12-28T11:43:41.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2020/12/28/react生命周期爬坑/","link":"","permalink":"https://feidom-up.github.io/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/","excerpt":"","text":"由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件 梳理生命周期的时机和职责，建立时机与操作的对应关系 使用方式（时机梳理）： 挂载，更新，卸载 适用范围（职责梳理）：状态变更、错误处理 时机梳理挂载阶段挂载阶段是指组件从初始化到完成加载的过程。 constructor 是类通用的构造函数，常用于初始化。所以在过去，constructor 通常用于初始化 state 与绑定函数。 123456class Com extends React.Component&#123; // constructor react 官方弃用 constructor(props)&#123; super(props) this.state = &#123;count: 0&#125; &#125; getDerivedStateFromProps 当props被传入 state发生变化时 fouceUpdate被调用 最常见的一个错误是认为只有 props 发生变化时，getDerivedStateFromProps 才会被调用，而实际上只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。所以是外部参数，也就是 props 传入时就会发生变化。你可能不需要使用派生 state UNSAFE_componentWillMount(componentWillMount) 用于组件加载前做某些操作 因在React的异步渲染机制下，会被多次调用。react弃用 eg：同构时，在服务器端和客户端同时发起请求拉取数据，会分别被执行一次 render 纯函数 返回jsx解构，描述渲染内容 componentDidMount 组件加载完成时做某些操作，用于发起请求 更新阶段更新阶段是指外部 props 传入，或者 state 发生变化时的阶段。 UNSAFE_componentWillReceiveProps 被标记弃用，因为其功能可被函数 getDerivedStateFromProps 所替代。 getDerivedStateFromProps 同挂载阶段的表现一致。 shouldComponentUpdate 该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。 React 官方提供了一个通用的优化方案，也就是 PureComponent。PureComponent 的核心原理就是默认实现了shouldComponentUpdate函数，在这个函数中对 props 和 state 进行浅比较，用来判断是否触发更新。 UNSAFE_componentWillUpdate 同样已废弃，因为后续的 React 异步渲染设计中，可能会出现组件暂停更新渲染的情况。 render 同挂载阶段的表现一致。 getSnapshotBeforeUpdate getSnapshotBeforeUpdate 方法是配合 React 新的异步渲染的机制，在 DOM 更新发生前被调用，返回值将作为 componentDidUpdate 的第三个参数。 12345678910111213141516171819202122232425262728293031class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125; componentDidUpdate 正如上面的案例，getSnapshotBeforeUpdate 的返回值会作为componentDidUpdate的第三个参数使用。 卸载阶段 componentWillUnmount 卸载阶段唯一的回调函数。 该函数主要用于执行清理工作。一个比较常见的 Bug 就是忘记在 componentWillUnmount 中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以一定要在该阶段解除事件绑定，取消定时器。 职责梳理如果我们的 React 应用足够复杂、渲染层级足够深时，一次重新渲染，将会消耗非常高的性能，导致卡顿等问题。关键点： 什么情况下会触发重新渲染。 渲染中发生报错后会怎样？又该如何处理？ 函数组件 函数组件任何情况下都会重新渲染。官方提供了一种方式优化手段，那就是 React.memo。React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。 123const MyComponent = React.memo(function MyComponent(props) &#123; /* 使用 props 渲染 */&#125;); React.Component 如果不实现 shouldComponentUpdate 函数，那么有两种情况触发重新渲染。 当 state 发生变化时。这个很好理解，是常见的情况。 当父级组件的 Props 传入时。无论 Props 有没有变化，只要传入就会引发重新渲染。 React.PureComponent PureComponent 默认实现了 shouldComponentUpdate 函数。所以仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。 错误边界错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，如下 React 官方所给的示例： 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; static getDerivedStateFromError(error) &#123; // 更新 state 使下一次渲染能够显示降级后的 UI return &#123; hasError: true &#125;; &#125; componentDidCatch(error, errorInfo) &#123; // 你同样可以将错误日志上报给服务器 logErrorToMyService(error, errorInfo); &#125; render() &#123; if (this.state.hasError) &#123; // 你可以自定义降级后的 UI 并渲染 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 无论是 React，还是 React Native，如果没有错误边界，在用户侧看到的现象会是这样的：在执行某个操作时，触发了 Bug，引发了崩溃，页面突然白屏。但渲染时的报错，只能通过 componentDidCatch 捕获。这是在做线上页面报错监控时，极其容易忽略的点儿。 坑 在不恰当的时机调用不合适的代码 在需要调用时，忘记了调用 以下情况容易造成生命周期的坑 getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。 componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。 componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。 shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。 componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。 如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。 如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"你可能不需要使用派生state","slug":"你可能不需要使用派生state","date":"2020-12-28T09:14:17.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/12/28/你可能不需要使用派生state/","link":"","permalink":"https://feidom-up.github.io/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/","excerpt":"","text":"你可能不需要使用派生state 文中列举了两种反模式的使用方式 直接复制prop到state 在props变化后修改state 这两种使用方式除了增加代码的维护成本外，没有任何的好处","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"webpack优化之代码分割splitChunck","slug":"webpack优化之代码分割","date":"2020-12-21T06:06:00.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/21/webpack优化之代码分割/","link":"","permalink":"https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/","excerpt":"","text":"代码分割 splitChunck 动态引用 适用场景：抽离相同代码到一个共享块 脚本懒加载，使得初始下载代码更小 懒加载JS脚本方式 CommonJS: require.ensure ES6: 动态import（需要babel支持，@babel/plugin-syntax-dynamic-import) 1234// 配置.babelrc\"plugins\": [ [\"@babel/plugin-syntax-dynamic-import\"],] dist代码通过window[‘webpackJsonp’]来获取对应脚本","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack优化之Scope Hoisting","slug":"webpack优化之ScopeHoisting","date":"2020-12-21T05:58:20.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/21/webpack优化之ScopeHoisting/","link":"","permalink":"https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/","excerpt":"","text":"webpack打包现象webpack构建后的代码存在大量的闭包代码 大量函数闭包包裹代码，导致体积增大(模块越多越明显) 运行代码时创建的函数作用域变多，内存开销变大 被webpack转换后的模块会带上一层包裹，import会被转换成webpack_require Scope Hoisting原理 将所有模块的代码按照引用顺序放在一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突 对比，通过scope hoisting 可以减少函数声明代码和内存开销 开启scope hoisting webpack4 mode 为 production默认开启，必须是ES6语法，commonJS不支持 webpack3 增加插件 new webpack.optimize.ModuleConcatenationPlugin()","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack优化之tree-shaking","slug":"webpack优化之TreeShaking","date":"2020-12-21T05:57:47.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/21/webpack优化之TreeShaking/","link":"","permalink":"https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BTreeShaking/","excerpt":"","text":"tree-shaking 静态分析，不是动态分析 代码不会被执行到，就不会打包到bound.js 必须使用ES6的语法(import、export)才支持tree-shaking，commonjs方式不支持 webpck默认支持，在.babelrc里面设置 modules: false即可，同时mode=production默认开启 tree-shaking原理 只能作为模块顶层的语句出现 import的模块只能是字符串常量 export function() {} import binding 是 immutable 的 代码擦除: uglify阶段删除无用代码","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack4&&ESlint","slug":"webpack4&&ESlint","date":"2020-12-15T08:23:27.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack4&&ESlint/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack4&&ESlint/","excerpt":"","text":"ESlintESLint是一个用来识别ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//.eslint.js// 区分生产环境、开发环境const _mode = process.env.NODE_ENV || 'production';module.exports = &#123; \"env\": &#123; \"browser\": true, \"es6\": true, \"node\": true, &#125;, \"globals\": &#123; \"$\": true, \"process\": true, \"dirname\": true, &#125;, \"parser\": \"babel-eslint\", \"extends\": \"eslint:recommended\", \"parserOptions\": &#123; \"ecmaFeatures\": &#123; \"jsx\": true, \"legacyDecorators\": true &#125;, \"ecmaVersion\": 2018, \"sourceType\": \"module\" &#125;, \"plugins\": [ \"react\" ], \"rules\": &#123; \"no-console\": \"off\", \"no-debugger\": _mode==='development' ? 0 : 2, \"no-alert\": _mode==='development' ? 0 : 2, // \"no-multi-spaces\": \"error\", \"no-unused-vars\": \"off\", // react中不适用 \"no-constant-condition\": \"off\", \"no-fallthrough\": \"off\", // \"keyword-spacing\": [\"error\", &#123; \"before\": true&#125; ], // 不生效，先注释 // \"indent\": [ // \"error\", // 2 // ], \"linebreak-style\": [ \"error\", \"unix\" ], // \"quotes\": [ // \"error\", // \"single\" // ], \"semi\": [0], \"no-unexpected-multiline\": 0, \"no-class-assign\": 0, &#125;&#125;; 检查eslint 方式一: 安装husky，增加npm script，适合老项目 12345678910111213\"scripts\": &#123; //\"precommit\": \"eslint --ext .js --ext .jsx src/\", \"precommit\": \"eslint lint-staged\", // 增量检查修改的文件 &#125;,\"lint-staged\": &#123; //\"src/**/*.js\": [ // \"eslint --ext .js --ext .jsx\", // \"git add\" //] \"linters\": &#123; \"*.[js,scss]\": [\"eslint --fix\", \"git add\"] &#125;&#125; 方式二：webpack与eslint结合，新项目 1234567rules: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, use: ['babel-loader', 'eslint-loader'] &#125;] 其实新项目中，可以将两种方式同时使用","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack4定位源代码source-map","slug":"webpack4定位源代码source-map","date":"2020-12-15T08:22:25.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack4定位源代码source-map/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack4%E5%AE%9A%E4%BD%8D%E6%BA%90%E4%BB%A3%E7%A0%81source-map/","excerpt":"","text":"定位源代码 通过 source-map 定位到源代码 开发环境：建议使用 首先在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系。因此不管是开发环境还是生产环境，我们都会选择增加cheap基本类型来忽略模块打包前后的列信息关联。 其次，不管在生产环境还是开发环境，我们都需要定位debug到最最原始的资源，比如定位错误到jsx，coffeeScript的原始代码处，而不是编译成js的代码处，因此，不能忽略module属性 再次我们希望通过生成.map文件的形式，因此要增加source-map属性 线上环境关闭 eval：使用eval包裹模块代码 cheap：不包含列信息 inline：将.map作为DataURI嵌入，不单独生成.map文件 module：包含loader的source source-map 类型 devtool 首次构建 二次构建 是否适合生产环境 可以定位的代码 (none) +++ +++ yes 最终输出的代码 eval +++ +++ no webpack生成的代码块（一个个的模块） cheap-eval-source-map + ++ no 经过loader转换后的代码（只能看到行） cheap-module-eval-source-map o ++ no 源代码（只能看到行） eval-source-map – + no 源代码 cheap-source-map + o yes 经过loader转换后的代码（只能看到行） cheap-module-source-map o - yes 源代码（只能看到行） inline-cheap-source-map + o no 经过loader转换后的代码（只能看到行） inline-cheap-module-source-map o - no 源代码（只能看到行） source-map – – yes 源代码 inline-source-map – – no 源代码 hidden-source-map – – yes 源代码 123456module.expors = &#123; // 开发,因为eval的rebuild速度快，因此我们可以在本地环境中增加eval属性 devtool: 'cheap-module-eval-source-map' // 生产 devtool: 'cheap-module-source-map'&#125; 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack4代码拆分","slug":"webpack4代码拆分","date":"2020-12-15T08:17:51.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack4代码拆分/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack4%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86/","excerpt":"","text":"基础库分离将react、react-dom基础包通过cdn引入，不打入到bundle中 externals 配置12345678module.exports = &#123; externals: &#123; react: 'React', 'react-dom': 'ReactDOM', 'react-router-dom': 'ReactRouterDOM', mobx: 'mobx' &#125;,&#125; 在html模版中 script标签引入对应的cdn地址 html-webpack-externals-plugin（推荐使用） 在html模版中 script标签引入对应的cdn地址 在plugins中配置1234567891011121314151617181920212223plugins: [ new HtmlWebpackPlugin(), new htmlWebpackExternalsPlugin(&#123; externals: [ &#123; module: 'react', entry: react的cdn地址, global: 'React' &#125;, &#123; module: 'react-dom', entry: react-dom的cdn地址, global: 'ReactDOM' &#125;, &#123; module: 'react-router-dom', entry: react-router-dom的cdn地址, global: 'ReactRouterDOM' &#125;, // ... ] &#125;)] webpack4 替代 CommonsChunckPlugin插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445module.exports = &#123; optimization: &#123; minimize: true, runtimeChunk: &#123; name: 'manifest' &#125;, splitChunks: &#123; chunks: 'async', // async异步引入库进行分离(默认),initial同步引入库分离，all所有引入库分离 minSize: 30000, // 抽离公共包最小的大小 maxSize: 0, minChunks: 1, // 最小使用的次数 maxAsyncRequests: 5, maxInitialRequests: 3, name: true, cacheGroups: &#123; // 提取基础库，不使用CDN的方式 //commons: &#123; // test: /(react|react-dom|react-router-dom)/, // name: \"vendors\", // chunks: 'all' //&#125;, // 提取公共js commons: &#123; chunks: \"all\", // initial minChunks: 2, maxInitialRequests: 5, minSize: 0, name: \"commons\" &#125;, // vendors: &#123; // test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 // &#125; // 合并所有css // styles: &#123; // name: 'style', // test: /\\.(css|scss)$/, // chunks: 'all', // minChunks: 1, // enforce: true // &#125; &#125; &#125; &#125;,&#125; 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack4多页面应用MPA","slug":"webpack4多页面应用MPA","date":"2020-12-15T08:17:12.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack4多页面应用MPA/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack4%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8MPA/","excerpt":"","text":"多页面应用MPA 每一次页面跳转，后台都会返回一个新的html，多页应用 属于后端渲染，有明显的优势：SEO友好、每个页面是解耦的 缺点：每个页面对应一个entry，一个html-webpack-plugin，（这种太麻烦了，每次新增都需要再配置一次） 针对上述缺点的解决方案123456789101112131415161718192021222324252627282930// 例如 ./src/index/index.js 与 ./src/search/index.js// path: './src/*/index.js'const setMPA = filenames =&gt; &#123; const entry = &#123;&#125;, htmlWebpackPlugins = []; const entryFiles = glob.sync(path.join(__dirname, filenames)) for(let item of entryFiles)&#123; // (/\\/([a-z\\_\\$]+)\\/index.js$/) const match = item.match(/src\\(.*)/index\\.js$/) const pageName = match &amp;&amp; match[1]; entry[pageName] = item htmlWebpackPlugins.push( new HtmlWebpackPlugin(&#123; template: `src/$&#123;pageName&#125;/index.html`, filename: `$&#123;pageName&#125;.html`, chunks: [\"runtime\", \"common\", pageName], minify: &#123; // .. &#125; &#125;) ) &#125; return &#123; entry, htmlWebpackPlugins &#125;&#125;entry: entryplugin: [//.....].concat(htmlWebpackPlugins) 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack4资源内联","slug":"webpack4资源内联","date":"2020-12-15T08:16:48.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack4资源内联/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack4%E8%B5%84%E6%BA%90%E5%86%85%E8%81%94/","excerpt":"","text":"资源内联是干什么资源内联：就是把打包好的css等文件，在html中注入这些文件路径，实现内联 页面框架的初始化，比如flexible 上报相关打点 css内联避免页面闪动（直接将css内联到html文件） 内联html123// raw-loader@0.5.1 内联html片段，在template中弄// 内联html&lt;%= require('raw-loader!./meta.html') %&gt; 内联javascript123// raw-loader内联js// 初始化脚本，例如flexible&lt;script&gt;&lt;%= require('raw-loader!babel-loader!../node_modules/lib-flexible/flexible.js') %&gt;&lt;/script&gt; 内联css 方式一：style-loader 123456789101112131415161718module: &#123; rules: [ &#123; test: /.s?css$/, use: [ &#123; loader: 'style-loader', options: &#123; injectType: 'singletonStyleTag', // 将所有style标签合并成一个 &#125; &#125; 'css-loader' 'postcss-loader', 'sass-loader' ] &#125;, ]&#125;, 方式二： html-inline-css-webpack-plugin首先使用 mini-css-extract-plugin（而非 style-loader）将 css 提取打包成一个独立的 css chunk 文件 然后使用html-webpack-plugin 生成 html 页面 最后使用 html-inline-css-webpack-plugin 读取打包好的 css chunk 内容注入到页面，原本 html-webpack-plugin 只会引入 css 资源地址，现在实现了 css 内联 1234567891011121314151617181920212223const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require('html-webpack-plugin');const HTMLInlineCSSWebpackPlugin = require(\"html-inline-css-webpack-plugin\").default; module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, \"css-loader\" ] &#125;] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;), new HtmlWebpackPlugin(), new HTMLInlineCSSWebpackPlugin(), ],&#125; 方式一style-loader VS 方式二html-inline-css-webpack-plugin style-loader是css-in-js，需要加载js后才能写入到style中，有一定的延迟性 html-inline-css-webpack-plugin是将css提取出来，再写入到html中，html网页源代码中已经内联好css了，没有延迟性了 请求层面：减少HTTP网络请求数 小图片或者字体内联url-loader 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"webpack热更新原理","slug":"webpack热更新原理","date":"2020-12-15T08:01:43.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/12/15/webpack热更新原理/","link":"","permalink":"https://feidom-up.github.io/2020/12/15/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"webpack热更新plugins配置 webpack-dev-server 开启本地服务器，监听文件变化后，热更新页面;不刷新浏览器而是热更新，不输出文件，而是放在内存中;配合 new.webpack.HotModuleReplacementPlugin() 或 react-hot-loader 插件使用 123456789101112131415161718192021222324252627282930313233343536373839404142// package.jsonwebpack-dev-server mode=development -open// configmodule.exports = &#123; devServer: &#123; host: '0.0.0.0', compress: true, port: '3000', contentBase: join(__dirname, '../dist'),//监听的目录，用于刷新浏览器 hot: true, overlay: &#123; errors: true, warnings: true &#125;, disableHostCheck: true, publicPath: '/', // 设置时，要与output.publicPath保持一致 historyApiFallback: true, // historyApiFallback: &#123; // rewrites: [from: /.*/, to: path.posix.join('/', // 'index.html')], //&#125; proxy: &#123; '/api': 'http://localhost:8081', &#125; //proxy: &#123; // '/api/*': &#123; // target: 'https://xxx.com', // changeOrigin: true, // secure: false, // headers: &#123;&#125;, // onProxyReq: function(proxyReq, req, res) &#123; // proxyReq.setHeader('origin', 'xxx.com'); // proxyReq.setHeader('referer', 'xxx.com'); // proxyReq.setHeader('cookie', 'xxxxx'); // &#125;, // onProxyRes: function(proxyRes, req, res) &#123; // const cookies = proxyRes.header['set-cookie']; // cookies &amp;&amp; buildCookie(cookies) // &#125; // &#125; // &#125; &#125;,&#125; 原理 Webpack Compile: 将JS编译为Bundle HMR Server: 将热更新的文件输出给 HMR Runtime Bundle server: 提供文件在浏览器的访问 HMR Runtime: 会被注入到浏览器，更新文件的变化 bundle.js: 构建输出的文件 HMR: Hot Module Replacement 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"react知识Q&A","slug":"react知识Q&A","date":"2020-12-04T03:42:24.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2020/12/04/react知识Q&A/","link":"","permalink":"https://feidom-up.github.io/2020/12/04/react%E7%9F%A5%E8%AF%86Q&A/","excerpt":"","text":"qa的关键在于回答时注意知识可扩展的深度和广度，基本从“是什么”，“为什么”，“怎么做”三个方面来回答 Q:说说什么是react？ 题解：react的诞生背景 2005年 jquery诞生，浏览器兼容是当时最大的问题。不算框架，只算是工具函数合集。仍不能解决代码复用问题和工程化问题。 2009年 angularJs带着后台java开发的思想横空出世，前端项目工程化双向绑定给当时的中台系统带来了巨大的便利，但是angular臃肿，需要学习很多angular概念，成本高。 2010年 backbonejs出现，既兼容jquery，又有很好的mvc工程化管理，在前端风靡一时。 2013年 reactjs诞生，react的虚拟dom，组件式开发，完美的实现了视图开发中组合优于继承的思想，很大程度上解决了开发复用的问题 2014年 vue诞生 A: 是什么：react是一个用于构建用户界面的javascript库； 优点: 声明式、组件化、通用性 声明式：编写代码更直观更简洁 组件化：提高代码复用率，实现高内聚，低耦合的设计原则 通用性：一次学习，随处编写。react实现了虚拟dom层，程序不会直接操作dom，依据domdiff处理视图改变。支持虚拟dom层的技术栈，都能用react进行前端处理。 缺点：react并没有支持前端全部解决方案，而是交给社区来实现，所以react的社区很活跃。但是带来了学习东西多的高学习成本。 Q:说说react为什么选择了jsx语法 题解：也就是在问，为什么没有选择其他方案 其他方案有：vue在用的模板语法，模板字符串，jxon语法 A: 是什么：jsx语法是javacsript的扩展。jsx会被babel编译为React.createElement(),是React.createElement()的语法糖，通过类似XML的描述方式，描写函数对象。 优点：更简洁更直观，更贴近原生html。贴近reac“关注点分离”的思想。 对比其他方案： 模板语法：分离了技术栈，引入了不该称为关注点的模板概念：模板指令，模板语法等。不符合react的设计思想 模板字符串：使代码变得更复杂，字符串编写，不利于语法提示 jxon：类似jsx语法，但是因为大括号的语法提示问题 所以react选择了jsx，因为jsx与其设计理念贴合，不需要引入过多的概念，对代码提示也很友好，最适合react。 Q:React 的请求应该放在哪里，为什么? 对于异步请求，应该放在 componentDidMount 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择： constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了。 componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。 A: 所以React 的请求放在 componentDidMount 里是最好的选择。 Q：社区中去除类组件constructor的原因 constructor之前主要用于初始化组件的一些state状态，现在直接将状态写在顶部state = {count: 0}不再写在constructor中 A: constructor 中不推荐处理处理初始化以外的逻辑 constructor 本身只是class的初始化函数，并不属于react生命周期 移除 constructor 后，代码更简洁 Q:setState是同步更新还是异步更新 题解：是A还是B这种问题，不要想当然的回答，这种问题可能在不同场景中有不同的选择 可能是A 可能是B A和B同时存在 setState用于更新组件状态，触发组件重新渲染，更新视图UI 先了解下合成事件 基于 事件委托 思想, 在React @17.0前 React给document(HTML)挂上事件监听 Dom事件触发后冒泡到document(HTML) React找到对应的组件，造出一个合成事件 按组件树模拟一遍事件冒泡所以一个页面中只能有一个版本的React，多个版本的话，事件就乱套了React@17.0后，事件委托对象由document(HTML)更改为Dom容器(ReactDOM.render()所调用的节点)上 异步场景 一般情况下，setState是异步的。React的setState执行更像一个队列，执行时根据队列一一执行，合并state数据。完成后执行回调，根据结果更新虚拟Dom触发渲染 为什么是异步的？ 官方回复看这里 保持内部的一致性 为后续的架构升级启用并发更新 同步场景 在 addEventListener、 setTimeout、 setInterval这些原生事件中会同步更新 setState的工作原理 A： setState 并非真异步，只是看上去像异步。在源码中，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。 那么什么情况下 isBatchingUpdates 会为 true 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。 但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。 一般认为，做异步设计是为了性能优化、减少渲染次数，React 团队还补充了两点。 保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。 启用并发更新，完成异步渲染。","categories":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"}]},{"title":"webpack4基础","slug":"webpack4基础","date":"2020-11-25T02:16:54.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/11/25/webpack4基础/","link":"","permalink":"https://feidom-up.github.io/2020/11/25/webpack4%E5%9F%BA%E7%A1%80/","excerpt":"","text":"安装yarn add webpack webpack-cli 基础配置 entry 依赖入口 12345entry: '&#123;path&#125;/app.js' //单入口 SPAentry: &#123; app: '&#123;path&#125;/app.js', otherapp: '&#123;path&#125;/otherapp.js'&#125; //多入口 MPA output 指定打包后的输出 123456output: &#123; path: path.resolve(__diranme,'dist') filename: '[name].js' // 单入口可以写死文件名，多入口一定要使用占位符[name]，来自动生成多个文件 // filename: '[name].[chunkhash:5]]js' // filename: '[name].[hash]js'&#125; Loaders 解析器 webpack本身只支持js和json两种文件类型，其他类型的文件需要各种Loaders支持，转化为有效的模块。 本身是一个函数，接受源文件作为参数，返回转换的结果 常用loaders loader 作用 ts-loader 加载解析ts文件 babel-loader 在webpack中使用babel解析ES6 css-loader/less-loader/scss-loader css/less/sass解析器 cstyle-loader 将样式通过 style 标签，插入到 head 中 url-loader/file-loader 处理文件，图片、字体、多媒体 url-loader 实现较小的图片转成base64，插入到代码中，当超过限制的limit后，会自动降级到file-loader raw-loader 将.txt文件以字符串的形式导入 thread-loader 多进程打包js和css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// webpack.configmodule: &#123; rules: [ // 解析ES6,app根目录要配置.babelrc，如下面的.babelrc &#123;test: /.js?x$/, use: 'babel-loader', exclude: /node_modules/&#125; // exclude 除去node_modules里的文件 // 将.txt文件以字符串的形式导入 &#123;test: /.txt$/, use: 'raw-loader'&#125;, // 匹配sass/css文件，用对应的loader处理文件 &#123; test: /.s?css$/, use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader &#123; loader: 'css-loader', options: &#123; importLoaders: 1, // css模块化使用 modules: &#123; localIdentName: '[path][name]__[local]--[hash:base64:5]' &#125; &#125; &#125;, // 预处理器, autoprefixer(需要安装) &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; &#123; require('autoprefixer')(&#123; browsers: ['last 2 version', '&gt;1%', 'ios7'] &#125;) &#125; &#125; &#125;, 'sass-loader', // px自动转rem &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75, // 一个rem等于多少px remPrecision: 8 // px转换成rem的小数位 &#125; &#125; ], include: [], exclude: [ Root('src/components') ] &#125;, // &#123; test: /\\.(png|jpg|jpeg|gif|eot|woff|woff2|ttf|svg|otf)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 10 * 1024, // 10k name: isDev ? 'images/[name].[ext]' : 'images/[name].[hash.[ext]', publicPath: idDev ? '/' : 'cdn地址', &#125;, &#125;, // prduction，用于图片压缩 &#123; loader: 'image-webpack-loader', options: &#123; bypassOnDebug: true &#125; &#125; ] &#125;, ]&#125;// .babelrc&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ], \"plugins\": [ // 各种插件 \"@babel/propsoal-class-properties\" ]&#125; plugins 插件 插件用于bundle文件的优化，资源管理和环境变量注入，作用于整个构建过程 webpack-dev-server 热更新 详情请关注webpack热更新原理 webpack-dev-middleware 将webpack输出文件传输给服务器，适用于灵活的定制场景 123456789101112const express = requrie('express')const webpack = require('webpack')const webpackDevMiddleware = requrie('webpack-dev-middleware')const app = express()const config = require('./webpack.config.js')const compiler = webpack(config)app.use(webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath&#125;))app.listen(3000) mini-css-extract-plugin和optimize-css-assets-webpack-plugin 提取css，建议使用contenthash 1234567891011121314151617181920212223242526272829303132333435363738394041424344module: &#123; rules: [ &#123; test: /.s?css$/, use: [ isDev ? 'style-loader' : iniCssExtractPlugin.loader &#123; loader: 'css-loader', options: &#123; importLoaders: 1, // css模块化使用 modules: &#123; localIdentName: '[path][name]__[local]--[hash:base64:5]' &#125; &#125; &#125;, 'postcss-loader', 'sass-loader' ] &#125;, ] &#125;, plugins: [ // 提取css new MiniCssExtractPlugin(&#123; filename: 'styles/[name].[contenthash:5].css', &#125;), // 压缩css new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(\"cssnano\"),//需要安装cssnano cssProcessorPluginOptions: &#123; preset: [ 'default', &#123; discardComments: &#123; removeAll: true &#125; &#125; ] &#125;, canPrint: true &#125;), ] html-webpack-plugin 123456789101112131415161718192021plugins: [ new HtmlWebpackPlugin(&#123; // 自定义参数title传递到html中 // html中使用&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; // &lt;script&gt;let number = &lt;%= htmlWebpackPlugin.options.number %&gt;&lt;script&gt; number: 1, title: '京程一灯', filename: 'index.html', // chunks: ['index'] //用于多页面，使用哪些chunk template: resolve(__dirname, '/src/index.html'), minify: &#123; minifyJS: true, minifyCSS: true, removeComments: true, collapseWhitespace: true, preserveLineBreak: false, removeAttributeQuotes: true, removeComments: false &#125; &#125;),] clean-webpack-plugin 或者使用 rimraf dist123plugins: [ new CleanWebpackPlugin()] mode 用来指定当前构建环境 development、production 和 none 设置 mode 可以使用 wepack内置函数，内部自动开启一些配置项，默认值为 production 内置功能development：process.env.NODE_ENV为development,开启NamedChunksPlugin 和 NameModulesPlugin这两个插件用于热更新，控制台打印路径prodution：process.env.NODE_ENV为prodution.开启 FlagDependencyUsagePlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin，OccurrentceOrderPlugin、SideEffectsFlagPlugin等none：不开启任何优化选项 watch 文件监听可以在webpack命令后加上 –watch 参数，或在webpack.config中设置watch:true。 原理：轮询判断文件的最后编辑时间是否变化12345678910111213module.exports = &#123; // 默认false，不开启 watch: true, // 只有开启时，watchOptions才有意义 watchOptions: &#123; // 忽略，支持正则 ignored: /node_modules/, // 监听到变化后等300ms再执行，默认300ms aggregateTimeout: 300, // 怕乱文件是否变化是通过不停询问系统指定文件有没变化实现的，默认每秒1000次 poll: 1000 &#125;&#125; 文件指纹 打包后输出文件名后缀，也就是hash值 hash：和整个项目构建相关，只要项目中有一个文件修改，整个项目中的文件hash都会修改成统一的一个 chunkhash：和webpck打包的chunk有关，不同的entry会生成不同的chunkhash值（适用于js文件） contenthash：根据文件内容定义hash，文件内容不变，则contenthash不变，用于批量更新（适用于css文件） 优化命令行日志 统计信息 stats，webpack属性，这种方式不好 error-only：值发生错误时输出 minimal：只在发生错误或有新的编译时输出 none：没有输出 normal：标准输出，默认 verbose：全部输出123456789// developmentdevServer: &#123; // ..... stats: 'errors-only'&#125;// productionmodule.exports = &#123; stats: 'errors-only'&#125; stats结合friendly-errors-webpack-plugin（推荐）1234plugins: [ new FriendlyErrorsPlugin()],stats: 'errors-only' 构建异常和中断处理 wepback4之前的版本构建失败不会跑出错误码 node中的process.exit规范 0 表示成功完成，回调函数中，err 为 null 非0 表示执行失败，回调函数中，err 不为空，err.code就是传给exit的数字 主动捕获错误，并处理构建错误 写个插件，compiler 在每次构建结束后会出发done这个hook 12345678910111213plugins: [ function() &#123; // webpack3 this.plugin('done', (stats) =&gt; &#123;&#125;) // webpack4 this.hooks.done.tap('done', (stats) =&gt; &#123; if (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf('--watch') == -1) &#123; console.log('build error'); // dosomething process.exit(1); &#125; &#125;) &#125; ] 本博客笔记内容主要来自京城一灯公众号 前端先锋","categories":[{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"}]},{"title":"vue定义全局方法","slug":"vue定义全局方法","date":"2020-11-05T00:34:48.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/11/05/vue定义全局方法/","link":"","permalink":"https://feidom-up.github.io/2020/11/05/vue%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、将方法挂在到vue原型(Vue.prototype)上 定义： 1234567// global.jsconst Func = ()=&gt;&#123; console.log('global')&#125;export default &#123; Func&#125; 在main.js中配置 123456// main.jsimport Vue from 'vue'import global from '@/global'object.keys(global).forEach((key)=&gt;&#123; Vue.prototype['$global' + key] = global[key]&#125;) 使用 12345export default &#123; mounted()&#123; this.$globalFunc() &#125;&#125; 缺点，调用的时候，没有方法提示 二、全局混入mixin 定义：12345678910// mixin.jsconst mixin = &#123; methods: &#123; func()&#123; console.log('global') &#125;, ... &#125;&#125;export default mixin 在main.js中配置1234// main.jsimport Vue from 'vue'import mixin from '@/mixin'Vue.mixin(mixin) 在vue文件中使用12345export default &#123; mounted()&#123; this.func() &#125;&#125; mixin里的methods会和创建的每个单文件组件合并，调用方法时有提示 三、使用Plugin Vue.use的实现本身没有挂载功能，只是触发了插件的install方法，本质上还是使用了Vue.prototype 定义： 123456789101112// plugin.jsfunction func()&#123; console.log('global')&#125;const plugin = &#123; // install是plugin中默认的方法 // 当外界在use这个组件或函数的时候，就会调用本身的install方法，同时传入一个Vue这个类的参数 install: function(Vue)&#123; Vue.prototype.$pluginGlobalFunc = func &#125;&#125;export default plugin 在main.js中配置 1234// main.jsimport Vue from 'vue'import plugin from '@/plugin'Vue.use(plugin) 在vue文件中使用 12345export default &#123; mounted()&#123; this.$pluginGlobalFunc() &#125;&#125; mixin里的methods会和创建的每个单文件组件合并，调用方法时有提示 四任意vue文件中写全局函数12345678// 创建全局方法this.$root.$on('func', function()&#123; console.log('global');&#125;);// 销毁全局方法this.$root.$off('func');// 调用全局方法this.$root.$emit('func'); 本章内容主要来自京城一灯","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"}]},{"title":"vue中使用svg图标","slug":"vue中使用svg图标","date":"2020-11-03T00:41:24.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/11/03/vue中使用svg图标/","link":"","permalink":"https://feidom-up.github.io/2020/11/03/vue%E4%B8%AD%E4%BD%BF%E7%94%A8svg%E5%9B%BE%E6%A0%87/","excerpt":"","text":"对svg图标的简单实用和认识svg图标的使用 在Vue项目中写一个svg组件 安装svg-sprite-loader插件对svg文件进行编译解析 yarn add svg-sprite-loader 在src/assets/目录下新建icons目录，存放需要用到的svg图标 在vue-cli4中，对vue.config.js进行配置 123456789101112131415161718192021chainWebpack: config =&gt; &#123; // set svg-sprite-loader // 第一步：让其他svg loader不要对svg进行操作 config.module .rule('svg') .exclude.add(path.join(__dirname, 'src/assets/icons')) .end() // 第二步：使用svg-sprite-loader 对svg进行操作 config.module .rule('icons') .test(/\\.svg$/) .include.add(path.join(__dirname, 'src/assets/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') //定义规则 使用时 &lt;svg class=\"icon\"&gt; &lt;use xlink:href=\"#icon-svg文件名\"&gt;&lt;/use&gt;&lt;/svg&gt; .options(&#123; symbolId: 'icon-[name]' &#125;) .end()&#125; 如果是vue-cli2中，配置build/webpack.base.conf.js 1234567891011121314151617181920212223module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.svg$/, loader: \"svg-sprite-loader\", include: [resolve(\"src/assets/icons\")], options: &#123; symbolId: \"icon-[name]\" &#125; &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \"url-loader\", exclude: [resolve(\"src/assets/icons\")], options: &#123; limit: 10000, name: utils.assetsPath(\"img/[name].[hash:7].[ext]\") &#125; &#125;, ] &#125;&#125; 在icons目录下，新建index.js文件 1234567891011import Vue from 'vue'import SvgIcon from '@/components/common/svgIcon'// 全局注册组件Vue.component('svg-icon', SvgIcon)// 定义一个加载目录的函数const requireAll = requireContext =&gt; &#123; requireContext.keys().map(requireContext)&#125;const req = require.context('@/assets/icons', false, /\\.svg$/)// 加载目录下的所有 svg 文件requireAll(req) 上述index.js中，引用了svgIcon组件，在对应的引用路径下新建svgIcon.vue文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;svg :class&#x3D;&quot;svgClass&quot; aria-hidden&#x3D;&quot;true&quot;&gt; &lt;use :xlink:href&#x3D;&quot;iconName&quot;&gt;&lt;&#x2F;use&gt; &lt;&#x2F;svg&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;svg-icon&#39;, props: &#123; &#x2F;&#x2F; 组件样式，可以控制svg图标 iconClass: &#123; type: String, required: true &#125;, &#x2F;&#x2F; 使用svg文件名的方式使用对应svg图标 className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return &#96;#icon-$&#123;this.iconClass&#125;&#96; &#125;, svgClass() &#123; if (this.className) &#123; return &#39;svg-icon &#39; + this.className &#125; else &#123; return &#39;svg-icon&#39; &#125; &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.svg-icon &#123; float: left; margin: 4px 6px 0 0; width: 13px; height: 13px; vertical-align: 1px; fill: #e1e1e1; overflow: hidden;&#125;&lt;&#x2F;style&gt; 在main.js中引入 import &#39;./assets/icons&#39; 使用svg-icon 1234&lt;svg-icon :iconClass&#x3D;&quot;&#39;download&#39;&quot; &#x2F;&#x2F;覆盖样式类名 className&#x3D;&quot;downloadIcon&quot; &#x2F;&#x2F;文件名&gt;&lt;&#x2F;svg-icon&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://feidom-up.github.io/tags/svg/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"}]},{"title":"前端如何防范xss攻击","slug":"前端如何防范xss攻击","date":"2020-09-10T05:56:05.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/09/10/前端如何防范xss攻击/","link":"","permalink":"https://feidom-up.github.io/2020/09/10/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83xss%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss是什么 Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 怎么办 输入过滤 ​ 输入过滤就在后台接口处理数据时合适，做个数据转义 渲染时处理 ​ 传统前端，拼接 HTML及使用 .innerHTML、.outerHTML、document.write()将数据渲染到页面上时，很容易将不可信的问题数据插到页面上。 ​ Sdk前端项目，使用Vue框架。Vue框架在渲染前，会将template模板编译为虚拟Dom树，减少了 encode 操作，减少了 XSS 隐患。 但是，使用`v-html`时会有问题，这一点在vue官方文档中有提到：![v-html](http://i.feidom.com/Vhtml.jpg) 解决方案： * 尽量使用插值表达式`{{}}`，它会把要显示的内容转为字符串。 * 如果使用v-html，要保证来自服务端的渲染数据都是安全的。 * 在使用第三方UI组件库的的时候，要检查一下它们渲染页面的方式，是否使用了 v-html。 * 有的时候实在绕不开，必须用。那就用[lodash的_.template](https://www.lodashjs.com/docs/lodash.template)做一层字符串逃逸操作，再塞给 v-html 就行。 123var template &#x3D; _.template(&quot;&lt;%- value %&gt;&quot;);template(&#123;value: &#39;&lt;script&gt;&#39;&#125;);输出 &#x3D;&#x3D;&gt; &lt;script&gt; 在项目中使用第三方库xss,中文文档","categories":[{"name":"前端安全","slug":"前端安全","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}]},{"title":"vue使用jest问题解决","slug":"vue使用jest时问题解决","date":"2020-09-03T01:40:51.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/09/03/vue使用jest时问题解决/","link":"","permalink":"https://feidom-up.github.io/2020/09/03/vue%E4%BD%BF%E7%94%A8jest%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"vue项目中用jest测试时，遇到几个问题，在这记录以下踩的坑，以后爬得快。 SecurityError: localStorage is not available for opaque origins详细报错如下： 1234567Test suite failed to runSecurityError: localStorage is not available for opaque originsat Window.get localStorage [as localStorage] (node_modules&#x2F;jsdom&#x2F;lib&#x2F;jsdom&#x2F;browser&#x2F;Window.js:257:15) at Array.forEach (&lt;anonymous&gt;) 解决方法：在jest.conf.js文件中，增加配置testURL: &quot;http://localhost/&quot;，如下: 1234&#123; ..., testURL: &quot;http:&#x2F;&#x2F;localhost&#x2F;&quot;&#125; Handlebars报错导致测试报告没有数据展示，详细报错如下： 123456789101112Handlebars: Access has been denied to resolve the property &quot;statements&quot; because it is not an &quot;own property&quot; of its parent.You can add a runtime option to disable the check or this warning:See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for detailsHandlebars: Access has been denied to resolve the property &quot;branches&quot; because it is not an &quot;own property&quot; of its parent.You can add a runtime option to disable the check or this warning:See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for detailsHandlebars: Access has been denied to resolve the property &quot;functions&quot; because it is not an &quot;own property&quot; of its parent.You can add a runtime option to disable the check or this warning:See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for detailsHandlebars: Access has been denied to resolve the property &quot;lines&quot; because it is not an &quot;own property&quot; of its parent.You can add a runtime option to disable the check or this warning:See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for details 报错原因说的很清楚，是Handlebars版本的问题。解决方法： 移除node_moudules包1rm -rf node_moudules 在package.json文件中，新增&quot;handlebars&quot;: &quot;4.5.0&quot;,这个包,相当于手动添加这个包12345// package.json\"devDependencies\": &#123; ..., \"handlebars\": \"4.5.0\",&#125; yarn.lock这个文件中，修改handlebars的包配置和所有依赖handlebars包的包配置12handlebars@^4.0.3: version &quot;4.7.6&quot; 改为==》12handlebars@4.5.0: version &quot;4.5.0&quot; 修改依赖handlebars的包的配置123456istanbul-reports@^1.5.1: version &quot;1.5.1&quot; resolved &quot;https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;istanbul-reports&#x2F;-&#x2F;istanbul-reports-1.5.1.tgz#97e4dbf3b515e8c484caea15d6524eebd3ff4e1a&quot; integrity sha512-+cfoZ0UXzWjhAdzosCPP3AN8vvef8XDkWtTfgaN+7L3YTpNYITnCaEkceo5SEYy644VkHka&#x2F;P1FvkWvrG&#x2F;rrJw&#x3D;&#x3D; dependencies: handlebars &quot;^4.0.3&quot; 改为==》123456istanbul-reports@^1.5.1: version &quot;1.5.1&quot; resolved &quot;https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;istanbul-reports&#x2F;-&#x2F;istanbul-reports-1.5.1.tgz#97e4dbf3b515e8c484caea15d6524eebd3ff4e1a&quot; integrity sha512-+cfoZ0UXzWjhAdzosCPP3AN8vvef8XDkWtTfgaN+7L3YTpNYITnCaEkceo5SEYy644VkHka&#x2F;P1FvkWvrG&#x2F;rrJw&#x3D;&#x3D; dependencies: handlebars &quot;4.5.0&quot; 警告：mapCoverage这个配置应该被移除，因为计算覆盖率的时间并不长 详细警告如下： 12345678Deprecation Warning: Option &quot;mapCoverage&quot; has been removed, as it&#39;s no longer necessary. Please update your configuration. Configuration Documentation: https:&#x2F;&#x2F;facebook.github.io&#x2F;jest&#x2F;docs&#x2F;configuration.html 这个配置在jest配置文档中的解释如下： If you have transformers configured that emit source maps, Jest will use them to try and map code coverage against the original source code when writing reports and checking thresholds. This is done on a best-effort basis as some compile-to-JavaScript languages may provide more accurate source maps than others. This can also be resource-intensive. If Jest is taking a long time to calculate coverage at the end of a test run, try setting this option to false. Both inline source maps and source maps returned directly from a transformer are supported. Source map URLs are not supported because Jest may not be able to locate them. To return source maps from a transformer, the process function can return an object like the following. The map property may either be the source map object, or the source map object as a JSON string. 大致意思是：*如果您配置了发出源映射的转换器，那么在编写报告和检查阈值时，Jest将使用它们来尝试将代码覆盖率映射到原始源代码上。这样做需要付出最大的努力，因为一些编译到javascript的语言可能比其他语言提供更准确的源映射。这也可以是资源密集型的。如果Jest在测试运行结束时花费很长时间来计算覆盖率，请尝试将此选项设置为false。 支持内联源映射和从转换器直接返回的源映射。不支持源映射url，因为Jest可能无法定位它们。要从转换器返回源映射，process函数可以返回如下所示的对象。map属性可以是源映射对象，也可以是JSON字符串形式的源映射对象。 解决方法：在jest.conf.js文件中，移除mapCoverage:true这个配置。","categories":[],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://feidom-up.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"单元测试","slug":"单元测试","permalink":"https://feidom-up.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"ast抽象语法树","slug":"ast抽象语法树","date":"2020-08-31T01:59:55.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/08/31/ast抽象语法树/","link":"","permalink":"https://feidom-up.github.io/2020/08/31/ast%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/","excerpt":"","text":"尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。— 《你不知道的js(上)》 代码执行前的步骤-编译下图是简易的重点流程，实际js的编译要复杂的多 词法分析（扫描scanner） 这个过程将由字符组成的字符串分解为有意义的代码块，这些代码块叫“词法单元”。 如： let a = 2; 将被分析为[let, a, =, 2]这些词法单元。空格算不算取决于空格在这门语言中是否有意义 grammars-v4中有所有语言的语法规则，也包括js。 语法分析（解析器） 这个过程是将词法单元流（数组，通俗的讲，处理过程就是个for循环）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”Abstract Syntax Tree，AST。 代码生成 将生成的ast转化为可执行代码的过程。 ASTAST Explorer提供了很多不同的ast生成规则可用来学习例如: 编译javascript时的var a = 1;将生成如下抽象语法树 12345678910111213141516171819202122232425262728293031323334&#123; type: \"Program\", // 程序 start: 0, end: 10, body: [ &#123; // VariableDeclaration type: \"VariableDeclaration\", // 变量声明 start: 0, end: 10, declarations: [ &#123; // VariableDeclarator // 变量声明者 type: \"VariableDeclarator\", start: 4, end: 9, id: &#123; // Identifier 声明a type: \"Identifier\", start: 4, end: 5, name: \"a\" &#125;, init:&#123; // 将a的值初始化为 1 type: \"Literal\", start: 8, end: 9, value: 1, raw: \"1\" &#125; &#125; ], kind: \"var\" &#125;, ], sourceType: \"module\"&#125; 实例： bable的编译使用了AST。 在vue3的模板语法编译，定义了自己的一套语法规则，使用AST大大提高了性能 扩展recast是一个ast的工具，使用它可以查看ast，更换语法规则等。","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://feidom-up.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://feidom-up.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"vue中使用vueChartJs","slug":"vue中使用vueChartJs","date":"2020-08-26T07:24:53.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/26/vue中使用vueChartJs/","link":"","permalink":"https://feidom-up.github.io/2020/08/26/vue%E4%B8%AD%E4%BD%BF%E7%94%A8vueChartJs/","excerpt":"","text":"vue-chartJsvue-chartJs是vue对Chart.js的封装,可以很简单的创建可复用的图表组件。由于是对底层的封装，所以许多图表的配置，还是需要看这个Chart.js的文档 先简单封装个组件12345678910111213// vBar.vue&lt;script&gt;import &#123; Bar &#125; from 'vue-chartjs'export default &#123; name: 'vBar', extends: Bar, props: ['chartdata', 'options'], mounted () &#123; this.renderChart(this.chartdata,this.options) &#125;&#125;&lt;/script&gt; 在需要的地方用这个组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// index.vue&lt;template&gt; &lt;div class=\"example-3d\"&gt; &lt;vBar :chartdata=\"vBarData\" :options=\"vOptions\" :styles=\"myStyles\"&gt;&lt;/vBar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; vBar &#125; from '@/components/vCharts/vBar'export default &#123; name: 'barTest', components: &#123; vBar, &#125;, data() &#123; return &#123; vBarData: &#123; labels: ['1', '2', '3', '4', '5', '6'], datasets: [ &#123; data: [1,2,3,4,5,6], backgroundColor: '#ffa200', barPercentage: 1, maxBarThickness: 12, &#125;, ], &#125;, vOptions: &#123; // 自适应必须要加的下面两个配置 responsive: true, maintainAspectRatio: false, layout: &#123; padding: &#123; left: 5, right: 5, top: 5, bottom: 5, &#125;, &#125;, legend: &#123; display: false &#125;, scales: &#123; grid: &#123; x: 10, x2: 20, y: 20, y2: 10, &#125;, xAxes: [ &#123; gridLines: &#123; display: false, &#125;, ticks: &#123; display: false, &#125;, &#125;, ], yAxes: [ &#123; gridLines: &#123; display: false, &#125;, ticks: &#123; display: false, &#125;, &#125;, ], &#125;, &#125;, &#125; &#125;, computed: &#123; myStyles() &#123; return &#123; height: '100px', // 自适应必须要加的position: 'relative', position: 'relative', marginTop: '200px' &#125; &#125;, &#125;, mounted() &#123;&#125;, created() &#123;&#125;, methods: &#123;&#125;,&#125;&lt;/script&gt; vue-chartJs的自适应resize v-chart配置1234Options: &#123; responsive: true, maintainAspectRatio: false,&#125; 组件实例绑定styles属性:styles=&quot;myStyles&quot;123456myStyles() &#123; return &#123; // 自适应必须要加的position: 'relative', position: 'relative', &#125;&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"图表","slug":"图表","permalink":"https://feidom-up.github.io/tags/%E5%9B%BE%E8%A1%A8/"}]},{"title":"vue使用swiper","slug":"vue使用swiper","date":"2020-08-25T06:26:14.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/25/vue使用swiper/","link":"","permalink":"https://feidom-up.github.io/2020/08/25/vue%E4%BD%BF%E7%94%A8swiper/","excerpt":"","text":"在vue项目中使用swiper.js有一个专业vue封装库的vue-awesome-swiper.js,在vue项目中使用时，需要把这个包也装上。 1yarn add swiper@5.3.6 vue-awesome-swiper@4.1.0 上面装包时指定版本，是因为在项目中踩坑了。装了新包不能用。于是查看vue-awesome-swiper在github上的示例代码，发现swiper@5.3.6 vue-awesome-swiper@4.1.0，装包后可以使用 使用demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;template&gt; &lt;div class=\"example-3d\"&gt; &lt;swiper class=\"swiper\" :options=\"swiperOption\"&gt; &lt;swiper-slide v-for=\"(item, index) in colorList\" :key=\"index\" :style=\"'background: '+item\"&gt;Slide &#123;&#123;index&#125;&#125;&lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Swiper, SwiperSlide &#125; from 'vue-awesome-swiper'import 'swiper/css/swiper.css'export default &#123; name: 'swiper-example-3d-coverflow', title: '3D Coverflow effect', components: &#123; Swiper, SwiperSlide, &#125;, data() &#123; return &#123; colorList:['#c82829','#f5871f','#eab700','#718c00','#3e999f'], swiperOption: &#123; initialSlide: 1, virtualTranslate: true, effect: 'coverflow', grabCursor: false, centeredSlides: true, slidesPerView: 'auto', coverflowEffect: &#123; rotate: 10, stretch: 0, depth: 10, modifier: 1, slideShadows: false, &#125;, on: &#123; click: function (swiper, event) &#123; &#125;, &#125;, slideToClickedSlide: true, slidesPerView: 5, &#125;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.example-3d &#123; width: 100%; height: 400px; padding-top: 50px; padding-bottom: 50px;&#125;.swiper &#123; height: 100%; width: 100%; .swiper-slide &#123; display: flex; justify-content: center; align-items: center; width: 300px; height: 300px; text-align: center; font-weight: bold; background-color: #2c8dfb; background-position: center; background-size: cover; &#125;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/tags/css/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"动画","slug":"动画","permalink":"https://feidom-up.github.io/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"vue使用flow静态检查","slug":"vue使用flow静态检查","date":"2020-08-18T03:21:27.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/18/vue使用flow静态检查/","link":"","permalink":"https://feidom-up.github.io/2020/08/18/vue%E4%BD%BF%E7%94%A8flow%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/","excerpt":"","text":"了解下flowjs是一门弱语言，灵活性强。这本来是它的优势。但是在程序运行中，数据类型变幻往往造成程序的不稳定。flow.js是用来为js做静态类型检查的。在使用ts前，flow.js是一个不错的类型检查器。他和ts不是一回事。ts是js的超集，而flow只是一个工具 在vue项目中使用flow 安装flow相关依赖包12345678910111213# yarn$ yarn add babel-plugin-syntax-flow # 添加对Babel中的流语法的支持。 babel-plugin-transform-class-properties # 添加对类属性和静态方法的支持 babel-plugin-transform-flow-strip-types # 在使用Babel转换前从源文件中删除类型注释。 eslint # Eslint。它实际上是JS的linter，集成了各种编辑器和ide。 babel-eslint # 对Eslint进行补丁，以使用Babel的解析器解析源文件。 eslint-plugin-html # 允许Eslint处理HTML文件 (ie. Only lints stuff inside script tags.) eslint-plugin-flowtype-errors # 通过Eslint传递流错误，并传递到编辑器的Eslint插件(如果有的话)。 eslint-plugin-vue # 用于使用Vue的Eslint的插件。 eslint-config-vue # 用于使用Vue的Eslint的配置. flow-bin # flow 类型检查-D 配置.babelrc12345678&#123; ... \"plugins\": [ \"babel-plugin-transform-class-properties\", \"babel-plugin-syntax-flow\", \"babel-plugin-transform-flow-strip-types\" ]&#125; 配置.eslintrc12345678910111213141516&#123; \"parser\": \"babel-eslint\", \"plugins\": [ \"html\", \"flowtype-errors\" ], \"extends\": [ \"vue\" ], \"rules\": &#123; \"flowtype-errors/show-errors\": 2 &#125;&#125; 配置.flowconfig 在package.json的scripts标签中。添加&quot;flow&quot;: &quot;flow&quot;123\"scripts\":&#123; \"flow\": \"flow\"&#125; 在项目的根目录，执行flow init 生成.flowconfig文件123456789101112[ignore].*&#x2F;node_modules&#x2F;.*.*&#x2F;test&#x2F;.*.*&#x2F;build&#x2F;.*.*&#x2F;config&#x2F;.*[include][libs][options]module.file_ext&#x3D;.vuemodule.file_ext&#x3D;.js 在js文件和.vue文件中加入/* @flow */,flow开始工作test.js123456/* @flow */const doSomethingStupid(stringArg) &#123; // Flow should show an error here, \"The operand of an arithmetic operation must be a number.\" return stringArg * 3109;&#125;console.log(doSomethingStupid(`I'm stringy`)) test.vue123456789101112131415&lt;template&gt; &lt;p&gt;I'm made with Flow!&lt;/p&gt;&lt;/template&gt;&lt;script&gt;/* @flow */const randomThing: string = 'Boop!'export default &#123; created() &#123; console.log(randomThing) &#125;&#125;&lt;/script&gt; 在webpack 中使用 flow 检查 安装一个 flow 的 webpack 插件 flow-webpack-next-plugin1yarn add flow-webpack-next-plugin -D 配置webpack 1234var FlowWebpackPlugin = require('flow-webpack-next-plugin');plugins: [ new FlowWebpackPlugin()] 记录一个flow报错 required module not found原因： 因为webpack配置了别名(alias)，所以在 js 文件内直接 import 别名会导致 flow 无法正确找到对应的 module解决： 在 .flowconfig 使用 name_mapper 将对应的别名做一个映射，问题解决 1234[options]module.file_ext&#x3D;.vuemodule.file_ext&#x3D;.jsmodule.name_mapper&#x3D;&#39;\\(@\\)&#39; -&gt; &#39;&lt;PROJECT_ROOT&gt;&#x2F;src&#x2F;&#39; 站在巨人的肩膀上https://www.jianshu.com/p/95854085ec40https://www.digitalocean.com/community/tutorials/vuejs-components-flow","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"flow","slug":"flow","permalink":"https://feidom-up.github.io/tags/flow/"}]},{"title":"node-sass装包报错","slug":"node-sass装包报错","date":"2020-08-17T08:27:58.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/08/17/node-sass装包报错/","link":"","permalink":"https://feidom-up.github.io/2020/08/17/node-sass%E8%A3%85%E5%8C%85%E6%8A%A5%E9%94%99/","excerpt":"","text":"node-sass安装依赖error: node-sass: Command failed报错解决好好的yarn install。 报一个下图的错。 问题原因：查看报错信息，再查找资料。可能是被墙了。解决办法：将 sass-binary-site 添加至 yarn/npm config 中,指定node-sass在淘宝源中下载 12yarn config set sass-binary-site https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sassnpm config set sass-binary-site https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass 爬坑记录一下","categories":[],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://feidom-up.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"安装依赖问题","slug":"安装依赖问题","permalink":"https://feidom-up.github.io/tags/%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"}]},{"title":"vue源码解读之html与vNode间的转换","slug":"vue源码解读之html与vNode间的转换","date":"2020-08-13T08:27:24.000Z","updated":"2024-08-22T02:26:03.662Z","comments":true,"path":"2020/08/13/vue源码解读之html与vNode间的转换/","link":"","permalink":"https://feidom-up.github.io/2020/08/13/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bhtml%E4%B8%8EvNode%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;template&gt;被compiler处理。compiler使用generate(ast, options)方法，将template转换为指定结构的对象。 compiler编译阅读源码逻辑可得，在实际上compiler的主要处理点是： 1var compiled = baseCompile(template.trim(), finalOptions); 即调用baseCompile函数，而baseCompile则是核心，这边主要代码如下： 12345678910const ast = parse(template.trim(), options)if (options.optimize !== false) &#123; optimize(ast, options)&#125;const code = generate(ast, options)return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns&#125; 上面的代码 将template处理为ast(抽象语法树)，且 根据ast树结构构建render函数主体部分。 compiler中调用parse()解析核心中用到的parse()方法的处理过程为： 在new Vue实例化时，parseHTML解析html标签等html内容。parseHTML处理实际上会调用parseStartTag和handleStartTag来解析出开始标签，解析时，用到的方法是正则匹配。 parseText处理类似文本节点。实际上会将使用到响应式数据的文本变成：_s(text)，并且设置了@binding属性表示引用了哪个响应式变量。还有一点就是对于换行的处理也会保留，即文本区域原样，该有换行就有换行只是响应式变量的特殊处理而已。 示例总结：将&lt;div id=&quot;app&quot;&gt; &lt;/div&gt;,经过parseHTML + parseText的解析，得到如下的主要ast结构： 1234567891011type: 1,tag: 'div',attrs: [&#123; name: 'id', value: 'app'&#125;],attrList: [&#123;name: 'id', value: 'app'&#125;],attrMap: &#123;id: 'app'&#125;children: [ expression: \"\"\\n \"+_s(text)+\"\\n \"\" text: \"↵ &#123;&#123; text &#125;&#125;↵ \" tokens: (3) [\"↵ \", &#123;…&#125;, \"↵ \"] type: 2] generate通过解析出来的ast构建render在构建render的过程中，用到了罪恶的with()先看一下generate的部分源码： 123456const state = new CodegenState(options)const code = ast ? genElement(ast, state) : '_c(\"div\")'return &#123; render: `with(this)&#123;return $&#123;code&#125;&#125;`, staticRenderFns: state.staticRenderFns&#125; 实例的ast结构实际上构建成了: 12345678910with(this) &#123; return _c('div', &#123; attrs:&#123;\"id\":\"app\"&#125; &#125;, [ _v(\"\\n \"+_s(text)+\"\\n \") ] )&#125; 上面使用函数形式表示的，实际上Vue源码此处是字符串，即： 1\"with(this)&#123;return _c(\"div\",&#123;attrs:&#123;\"id\":\"app\"&#125;&#125;,[_v(\"\\n \"+_s(text)+\"\\n \")])&#125;\" 其中用到的_c(),_v(),_s的意思分别为： 1234567891011121314151617// _c()就是$createElement，即h函数。该方法是vnode创建的实际出发点，Vue核心方法之一。具体源码如下：vm._c = function(a, b, c, d) &#123; return createElement(vm, a, b, c, d, false);&#125;;// -v()实际上是createTextVNode，即创建虚拟文本节点（文本类型的虚拟DOM），实例方法如下function createTextVNode(val) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125;// -s()实际上是toString，处理对象和其他形式文本输出。处理null、对象以及数组形式的数据等将其转换为字符串。实例方法如下function toString(val) &#123; return val === null ? ' ' : typeof val === 'object' // 格式化对象，并指定缩进为2个空格 ? JSON.stringify(val, null, 2) : String(val);&#125; 这里需要说明下_c中createElement中a、b、c、d参数表示的含义： 1234// a：tag，表示标签名// b：data，表示属性、事件、class、props等的配置对象// c: children，表示子节点// d：normalizationType，表示类型，即要如何处理children中的数据 至此，我们得到了render函数： 1render: `with(this)&#123;return $&#123;code&#125;&#125;`, VNode的创建是在render执行过程中触发的render中用with()执行了_c(),_v()等方法。_c()就是$createElement,在createElement的处理逻辑中，最为核心的就是调用VNode构造函数创建虚拟DOM: 1new VNode(tag, data, children, undefined, undefined, context) 然后再说一下VNode构造函数VNode构造函数实际上就是定义相关属性，VNode中重要的属性有： 12345678910// tag：当前标签名// data：标签属性、props、事件等对象集合// text：当前标签文本内容// context：上下文对象，即Vue实例对象var VNode = function(tag, data, children, text, elm, context, componentOptions, asyncFactory) &#123; this.tag = tag; this.data = data; this.children = children; ...&#125; render中创建了VNode，那什么时候调用render呢??这里说明下之前render生成时的过程及时间点 初始化时renderMixin这部分是加载Vue.js文件过程中的处理，涉及到render的是renderMixin函数，实际上该函数主要定义Vue原型方法：12// Vue.prototype.$nextTick方法定义// Vue.prototype._render方法定义 new Vue时initRender创建Vue实例时会调用initRender进行初始化，实际上就是相关属性的定义 $mount挂载render处理在这个时候将template处理成render函数。 $mount中构建出了render函数，那再来看看render函数的调用上图是mountComponent主要的处理逻辑，实际上render函数的执行是在_render中处理的。_render函数的结果作为vm._update函数的参数。这里有一个非常需要注意的点，实际上是在构建Watcher实例触发的：1234var updateComponent = function() &#123; vm._update(vm._render());&#125;;new Watcher(vm, updateComponent, noop) updateComponent会作为getter函数，并且会在Watcher.prototype.get中被调用，而这个步骤就是重新生成html的过程。 再说下_render方法实际上_render中主要的处理也就是render函数的调用，核心代码如下：12var vnode = render.call(vm._renderProxy, vm.$createElement);return vnode; 再说下_update实例方法_update中处理实际上有两个主要点：12* vm._vnode相关处理，两点：prevNode &#x3D; vm._vnode，vm._vnode &#x3D; vnode* vm.__patch__的调用 prevNode记录更新前的vnode，如果是初始化，那么prevNode就是空，调用patch实现vnode -&gt; html的过程，也是diff算法的实现过程，是整个Vue中核心点之一。_update核心源码如下：123456789var prevNode = vm._vnode;vm._vnode = vnode;if (!prevNode) &#123; // 初始化 vm.$el = vm.__patch__(vm.$el，vnode, hydrating, false);&#125; else &#123; // 更新 vm.$el = vm.__patch__(prevNode, vnode);&#125; _update负责比较dom节点并替换。总结通过上面主要分析了处理html、处理文本情况，对于指令相关等部分直接略过，满足了分析这边的目的：探寻下Vue是如何解析template的。整个处理流程如下：构建code：123$mount -&gt; compileToFunctions -&gt; compile -&gt; baseCompile -&gt; parse -&gt; generate -&gt; render其中parse中主要的处理：parse -&gt; parseHTML、parseText（循环处理startTag、text等） 而vnode的创建实际上是在render调用阶段发生的，即执行render函数，函数体中_c、_v等函数触发的VNode创建。render函数调用:1生成render函数 -&gt; mountComponent -&gt; new Watcher -&gt; Vue.prototype._render调用 在查看源码的过程中，搜索了各种资料帮助自己理解，其中来自玉案轩窗老哥的Vue系列条理清晰，对自己帮助很大。以上笔记也借鉴了他的内容，方便之后学习理解。","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"vue源码解读","slug":"vue源码解读","permalink":"https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"vue源码解读","slug":"vue源码解读","date":"2020-08-13T06:45:50.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/13/vue源码解读/","link":"","permalink":"https://feidom-up.github.io/2020/08/13/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"看完这张图 各阶段间详细解读 html 《==转换==》 vNode Observer重写array监听 keep-alive的实现","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"vue源码解读","slug":"vue源码解读","permalink":"https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"vue2.x源码解读之observer重写array监听","slug":"vue源码解析之observer重写array监听","date":"2020-08-12T06:37:36.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/12/vue源码解析之observer重写array监听/","link":"","permalink":"https://feidom-up.github.io/2020/08/12/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bobserver%E9%87%8D%E5%86%99array%E7%9B%91%E5%90%AC/","excerpt":"","text":"Observervue的核心功能之一就是双向绑定，在vue2.x中，双向绑定的原理，是依赖Object.defineProperty这个方法。由于这个方法的一些弊端，导致Observer的实现，需要兼容这些弊端。以下内容详细说明了来龙去脉 先自己实现一个Observer123456789101112131415161718192021function defineReactive(data, key, value)&#123; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function defineGet()&#123; console.log(`get key: $&#123;key&#125; vaule:$&#123;value&#125;`); return value &#125;, set: function defineSet(newVal)&#123; console.log(`set key: $&#123;key&#125; vaule: vaule:$&#123;newVal&#125;`); value = newVal &#125; &#125;)&#125;function observe(data)&#123; Object.keys(data).forEach(function(key)&#123; defineReactive(data,key,data[key]) &#125;)&#125;// let arr = [1, 2, 3]// observe(arr) 首先对数组(arr)的监听12let arr = [1, 2, 3]observe(arr) 代码运行后，在控制台直接给arr增加一个元素。代码及输出如下：1234// 键入arr[3] = 4;// 输出// 4 ===&gt; 新增的数组元素无法监听原因： 在监听数组arr时，监听了它的key:0,1,2(数组下标)。并没有监听下标3，所以监听失败。 代码运行后，在控制台直接给arr最前面unshift一个元素。代码及输出如下：12345678910// 键入arr.unshift(1);// 输出// get key: 2 vaule:3// get key: 1 vaule:2// set key: 2 vaule: vaule:2// get key: 0 vaule:1// set key: 1 vaule: vaule:1// set key: 0 vaule: vaule:4// 4 ===&gt; 在进行部分数组操作时，会造成监听多次（数组移位）原因： 在监听数组arr时，监听了它的key:0,1,2(数组下标)。当在数组arr的前面插入一个数据，造成数组移位（splice也会这样），所有的元素向后移动一个位置。造成多次get/set。如下图所示： 对对象(obj)的监听12let obj = &#123;\"key1\":\"vaule1\"&#125;observe(obj) 代码运行后，在控制台直接给obj增加一个元素obj[&quot;key2&quot;] = &quot;value2&quot;。代码及输出如下：1234// 键入obj[\"key2\"] = \"value2\";// 输出// \"value2\" ===&gt; 新增的对象元素无法监听原因类同监听数组时的情况1 Observer的Object.defineProperty这些问题，vue如何解决在vue的core中，observe下专门对array的监听进行了重写，以下内容为源码中的代码片段，来说明如何重写实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; def &#125; from '../util/index'const arrayProto = Array.prototype // 获取Array原型export const arrayMethods = Object.create(arrayProto) // 用新的原型对象创建一个arrayMethods// 定义一个要重写的方法的数组，其中的方法，都是会发生数组移位的const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * 拦截变化方法并发出事件,遍历重写的方法的数组methodsToPatch */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] // def是一个Object.defineProperty def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change // 手动发布变更信息 ob.dep.notify() return result &#125;)&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"vue源码解读","slug":"vue源码解读","permalink":"https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"设计模式-观察者模式","slug":"观察者模式","date":"2020-08-12T01:24:58.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2020/08/12/观察者模式/","link":"","permalink":"https://feidom-up.github.io/2020/08/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单介绍一下观察者模式，又称发布/订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 使用观察者模式的好处： 支持简单的广播通信，自动通知所有已经订阅过的对象。 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。 用javaScript实现一般简单的观察者模式pub(Publish) 发布sub(Subscribe) 订阅dep 发布订阅中心-电话本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var dep = &#123;&#125;; // dep相当于电话本，所有订阅者都注册在这里(function (q) &#123; var topics = &#123;&#125;, // 回调函数存放的数组 subUid = -1; // 发布方法 q.publish = function (topic, args) &#123; if (!topics[topic]) &#123; return false; &#125; setTimeout(function () &#123; var subscribers = topics[topic], len = subscribers ? subscribers.length : 0; while (len--) &#123; // 遍历所有订阅的方法，全部执行 subscribers[len].func(topic, args); &#125; &#125;, 0); return true; &#125;; // 订阅方法 // @param topic 订阅者名称 // @param func 订阅方法，通知时，调用这个方法实现通知 q.subscribe = function (topic, func) &#123; if (!topics[topic]) &#123; // 注册观察对象 topics[topic] = []; &#125; var token = (++subUid).toString(); // 方法的唯一口令标识，退订时可用 // 注册观察方法 topics[topic].push(&#123; token: token, func: func &#125;); return token; &#125;; //退订方法 q.unsubscribe = function (token) &#123; for (var m in topics) &#123; if (topics[m]) &#123; for (var i = 0, j = topics[m].length; i &lt; j; i++) &#123; if (topics[m][i].token === token) &#123; // 根据唯一口令标识 移除观察方法，实现退订 topics[m].splice(i, 1); return token; &#125; &#125; &#125; &#125; return false; &#125;;&#125; (dep)); 使用上面这个观察者模式 12345678910111213141516// 来，订阅一个pubsub.subscribe('example1', function (topics, data) &#123; // 通知时，这个方法收到通知执行 console.log(topics + \": \" + data);&#125;)// 再加一个订阅方法pubsub.subscribe('example1', function (topics, data) &#123; // 这个方法也收到通知执行 if(!Array.isArray(data))&#123; console.log('接到通知2',topics, data) &#125;&#125;)//发布通知pubsub.publish('example1', 'hello world!');pubsub.publish('example1', ['test', 'a', 'b', 'c']);pubsub.publish('example1', [&#123; 'color': 'blue' &#125;, &#123; 'text': 'hello'&#125;]); 一张图说清楚观察者模式 特别鸣谢此篇笔记是看了汤姆大叔的博客-深入理解JavaScript系列（32）：设计模式之观察者模式,笔记内容大多来自该篇博客。大叔的博客中还有其他观察者模式的实现方式，如需更深的理解，请移步。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"vue中使用gsap的动画插件","slug":"vue中使用tweenmax动画插件","date":"2020-08-07T03:01:26.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/07/vue中使用tweenmax动画插件/","link":"","permalink":"https://feidom-up.github.io/2020/08/07/vue%E4%B8%AD%E4%BD%BF%E7%94%A8tweenmax%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/","excerpt":"","text":"gsap 动画TweenMax基础案例 npm install / yarn add 二选一 12npm install gsap --saveyarn add gsap component.vue局部引入，哪里需要哪里搬 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div id=\"demo\"&gt; &lt;p&gt;以下例子每个动画的开始时间按0.5s 错开。TweenLite没有stagger。&lt;/p&gt; &lt;div class=\"box green\"&gt;&lt;/div&gt; &lt;div class=\"box grey\"&gt;&lt;/div&gt; &lt;div class=\"box orange\"&gt;&lt;/div&gt; &lt;div class=\"box green\"&gt;&lt;/div&gt; &lt;div class=\"box grey\"&gt;&lt;/div&gt; &lt;div class=\"box orange\"&gt;&lt;/div&gt; &lt;div class=\"box green\"&gt;&lt;/div&gt; &lt;div class=\"box grey\"&gt;&lt;/div&gt; &lt;div class=\"box orange\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;el-button @click=\"showTest()\"&gt;开始&lt;/el-button&gt; &lt;/div&gt; &lt;template&gt;&lt;script&gt; import &#123; TweenLite, TweenMax &#125; from 'gsap' export default &#123; methods: &#123; showTest: function()&#123; //TweenMax、TimelineLite、TimelineMax可以使用stagger（错开动画），TweenLite则没有。 TweenMax.staggerTo(\".box\", 1, &#123;rotation:360, y:100&#125;, 0.5); &#125; &#125; &#125;;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"动画","slug":"动画","permalink":"https://feidom-up.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"tweenmax","slug":"tweenmax","permalink":"https://feidom-up.github.io/tags/tweenmax/"},{"name":"gsap","slug":"gsap","permalink":"https://feidom-up.github.io/tags/gsap/"}]},{"title":"vue中使用animate.css","slug":"vue中使用animateCss","date":"2020-08-07T02:51:11.000Z","updated":"2024-08-22T02:26:03.661Z","comments":true,"path":"2020/08/07/vue中使用animateCss/","link":"","permalink":"https://feidom-up.github.io/2020/08/07/vue%E4%B8%AD%E4%BD%BF%E7%94%A8animateCss/","excerpt":"","text":"在vue项目中使用animate.css配合vue中的transition标签来结合animate.css中的效果 npm install / yarn add 二选一 12yarn add animate.css@3.5.1# 在这要装3.5.1的版本，装了4.0之后的版本，会不生效。是版本兼容问题 main.js 12import animate from 'animate.css'Vue.use(animate); component.vue 1234567891011&lt;template&gt; &lt;div&gt; &lt;transition enter-active-class=\"animated bounceIn\" leave-active-class=\"animated bounceOut\" :duration=\"1000\"&gt; &lt;h3 v-show=\"show\"&gt;这个元素存在动画效果&lt;/h3&gt; &lt;/transition&gt; &lt;el-button @click=\"show=!show\"&gt;开始表演&lt;/el-button&gt; &lt;/div&gt; &lt;template&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"}],"tags":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/tags/css/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"动画","slug":"动画","permalink":"https://feidom-up.github.io/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"Css从边角走向中心","slug":"postcss","date":"2020-08-04T07:25:26.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/08/04/postcss/","link":"","permalink":"https://feidom-up.github.io/2020/08/04/postcss/","excerpt":"","text":"被轻视的CSSCSS是Cascading Style Sheets（层叠样式表单）的简称。这种样式脚本一直和其他编程语言有差距。导致了css被轻视。近几年所有的前端技术都在疯狂的迭代更新，css也不例外。从sass，less，stylus这些预处理器之后，到CSS Module，CSS-in-JS（典型的代表，react的styled-components）。再聊聊PostCss这种插件系统。 预处理器在css发展的过程中，出现了一些痛点： 语法不够强大，不能够嵌套书写，不利于模块开发 没有变量和逻辑上的复用机制，导致在css的属性值中只能使用字面量形式，以及不断重复的样式，导致难以维护。 然后css预处理器的出现，弥补了这些遗憾： 变量：对变量进行声明，在需要的地方引用。 作用域：对变量进行管理，像js一样，从局部作用域开始向上查找变量。 嵌套：由于dom的树状结构，css有嵌套的写法，更直接的表现了父子层级之间的明确关系。 混合(Mixin) Extend： 运算： 函数： Namespaces&amp;Accessors： scope： 注释： css预处理器提供的这些方案，是我们开发人员在写css时更加灵活，维护性强。但是，项目越来越大，缺乏模块的概念，全局变量的问题困扰着你。每次定义选择器时，总要顾及到其他文件中是否使用了同样的命名。 有问题就有解决，各种方案出现（css分层）Q：为什么要分层？A:原因： CSS有语义化的命名约定和CSS层的分离，将有助于它的可扩展性，性能的提⾼和代码的组织管理。 ⼤量的样式，覆盖、权重和很多!important，分好层可以让团队命名统⼀规范，⽅便维护。 有责任感地去命名你的选择器。 分层的设计规范有很多，以下具体介绍BEM规范 BEM规范和SMACCS⾮常类似，主要⽤来如何给项⽬命名。⼀个简单命名更容易让别⼈⼀起⼯作。⽐如选项卡导航是⼀个块(Block)，这个块⾥的元素的是其中标签之⼀(Element)，⽽当前选项卡是⼀个修饰状态(Modifier)：1234567891011121314// bookList模块 &lt;form class=\"list-from\"&gt; &lt;input class=\"list-from__input\"&gt;&lt;/input&gt; &lt;button class=\"list-from__button\"&gt;&lt;/button&gt;&lt;/form&gt;// 其中归类为以下约定// BEM：块（block）、元素（element）、修饰符（modifier）.block&#123;&#125; // 代表了更⾼级别的抽象或组件.block__element&#123;&#125; // 代表.block的后代，⽤于形成⼀个完整的.block的整体.block--modifier&#123;&#125; // 代表.block的不同状态或不同版本// 其中块可以用单个连字符来界定：如.site-search&#123;&#125; //块.site-search__field&#123;&#125; //元素.site-search--full&#123;&#125; //修饰符 ……好麻烦。 还有SMACSS(Scalable and Modular Architecture for CSS 可扩展的模块化架构的CSS)、SUIT：衍生自BEM、ACSS：原子css规范、ITCSS 后处理器 CSS压缩 ClEAN_CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework取代styles，后处理器发热 近几年火爆的CSS Module，CSS-in-JS（典型的代表，react的styled-components）。可以参考阮一峰写的CSS Module看8月3老袁的课，写一下。 PostCSS是什么？PostCSS是一个用 JavaScript 工具和插件转换 CSS 代码的工具。—-官方简介 PostCSS同时支持预处理和后处理，也可以在原生的css中使用它。通俗来说，PostCSS是一个“壳壳”，可以加载各种生态中的插件来实现对css的处理，可以结合兼容sass，less等 下面介绍几种插件（plugins）： postcss-cssnext plugin — 使用下个版本的css语法，语法见cssnext (css4)语法 postcss-custom-properties — 运行时变量 postcss-simple-vars — 与SCSS一致的变量实现 postcss-mixins — 实现类似sass的@mixin的功能 postcss-extend — 实现类似sass的继承功能 postcss-import — 实现类似sass的import使用gulp和webpack处理postcss代码：// gulpfile.js1234567891011121314151617181920212223var gulp = require('gulp'); var postcss = require('gulp-postcss'); var autoprefixer = require('autoprefixer'); var cssgrace = require('cssgrace'); var cssnext = require('cssnext'); gulp.task('css', function () &#123; var processors = [ autoprefixer(&#123;browsers: ['last 3 version'], cascade: false, remove: false &#125;), cssnext(), cssgrace ]; return gulp.src('./src/css/*.css') .pipe(postcss(processors)) .pipe(gulp.dest('./dist')); &#125;); gulp.task('watch', function()&#123; gulp.watch('./src/css/*.css', ['css']); &#125;); gulp.task('default', ['watch', 'css']); // webpack.conf.js1234567891011121314var config = &#123; output:&#123;publicPath: '../dist/'&#125;, module:&#123; // loaders... &#125;, postcss: function()&#123; return [ ima4dpr(dpr: 3,q: 'q50',s: 's150'&#125;), px2rem(&#123;remUnit: remUnit, baseDpr: baseDpr &#125;), autoprefixer(&#123;browers: [\"ios_saf &gt;= 7\",\"android &gt;= 4\"]&#125;) ] &#125;, devtool: 'source-map'&#125; 打包处理逻辑如下图所示： 以上内容借鉴zimo的《谈谈PostCSS》","categories":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/tags/css/"},{"name":"postcss","slug":"postcss","permalink":"https://feidom-up.github.io/tags/postcss/"}]},{"title":"npm/yarn及其他包管理工具常用总结","slug":"npm常用包","date":"2020-08-02T01:32:06.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/08/02/npm常用包/","link":"","permalink":"https://feidom-up.github.io/2020/08/02/npm%E5%B8%B8%E7%94%A8%E5%8C%85/","excerpt":"","text":"安装 npm装了nodeJs会装好npm yarn安装yarn npm install -g yarn 修改源 npm (淘宝源 ｜ 本源)npm config set registry http://registry.npm.taobao.org/ npm config set registry https://registry.npmjs.org/ yarn (淘宝源 ｜ 本源)yarn config set registry http://registry.npm.taobao.org/ yarn config set registry https://registry.npmjs.org/ 设置代理 npmnpm config set proxy http://127.0.0.1:8080 npm config set https-proxy http://127.0.0.1:8080 yarnyarn config set proxy http://127.0.0.1:8080 yarn config set https-proxy http://127.0.0.1:8080 删除代理 npmnpm config delete proxy npm config delete https-proxy yarnyarn config delete proxy yarn config delete https-proxy 查看安装包 npmnpm list -g --depth 0 yarnyarn global list --depth=0 npx npx 是 npm 5.2+ 版本之后自带的工具，能够帮助我们更高效的执行 npm 软件仓库里的安装包。对于那些不常使用、或者只想一次性尝试的工具，推荐使用 npx 的方式代替 npm install -g、yarn global 全局安装 $ npx create-react-app my-app # 执行以上这条命令 npx 会按以下顺序工作： # 1. 先查看当前项目有没 create-react-app # 2. 如果当前项目找不到，会去全局查找 create-react-app # 3. 如果全局还找不到，会帮我们临时从 npm 包仓库安装 create-react-app，不会污染到当前项目，也不会装到全局","categories":[{"name":"npm","slug":"npm","permalink":"https://feidom-up.github.io/categories/npm/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://feidom-up.github.io/tags/yarn/"},{"name":"npm","slug":"npm","permalink":"https://feidom-up.github.io/tags/npm/"}]},{"title":"package.json了解多少","slug":"package包","date":"2020-08-02T01:17:51.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/08/02/package包/","link":"","permalink":"https://feidom-up.github.io/2020/08/02/package%E5%8C%85/","excerpt":"","text":"scripts属性生命周期 pre钩子1234\"scripts\": &#123; \"predev\": \"echo 111\", \"dev\": \"echo 222\"&#125;, 上述代码执行yarn run dev,会先执行pre钩子，结果如下：1234$ yarn run dev// 以下为结果111222 &amp;(同步串行) 和 &amp;&amp;(异步并行)12345\"scripts\": &#123; \"dev\": \"echo 111\", \"server\": \"echo 222\", \"start\": \"npm run dev &amp; npm run server\"&#125;, 上述代码执行yarn start,会先执行dev,再执行server，dev有报错，server不会被执行。12345\"scripts\": &#123; \"dev\": \"echo 111\", \"server\": \"echo 222\", \"start\": \"npm run dev &amp;&amp; npm run server\"&#125;, 上述代码执行yarn start,会同步行dev和server，dev有报错，server仍会被执行。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/tags/nodejs/"}]},{"title":"Nginx 403 Forbidden","slug":"nginx403","date":"2020-07-31T08:05:22.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/31/nginx403/","link":"","permalink":"https://feidom-up.github.io/2020/07/31/nginx403/","excerpt":"","text":"检查目录权限。权限不足的就加个权限。 1chmod -R 755 /root/feidom_blog/ nginx.conf中的user问题 1234$ vi /usr/local/nginx/conf/nginx.conf# user nobody;# 把 user 用户名 改为 user root 或 其它有高权限的用户名称即可user root; centos中的selinux是否为关闭状态查看SELinux状态： 123$ &#x2F;usr&#x2F;sbin&#x2F;sestatus -vSELinux status: disabled## disabled&#x2F;enabled (关闭&#x2F;开启) 关闭SELinux： 临时关闭，不用重启机器。$ setenforce 0 #设置SELinux 成为permissive模式;$ setenforce 1 #设置SELinux 成为enforcing模式 修改/etc/selinux/config 文件后，重启机器使其生效。SELINUX=enforcing 改为 SELINUX=disabled","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://feidom-up.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"Nginx","slug":"Nginx","permalink":"https://feidom-up.github.io/tags/Nginx/"}]},{"title":"DNS域名解析","slug":"DNS域名解析","date":"2020-07-28T00:52:35.000Z","updated":"2024-08-22T02:26:03.657Z","comments":true,"path":"2020/07/28/DNS域名解析/","link":"","permalink":"https://feidom-up.github.io/2020/07/28/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/","excerpt":"","text":"DNS: domain name system 作用：将域名解析到对应的ip地址解析原理：分级解析 域名分级(一级，二级，三级) www.baidu.com com是根域名，baidu.com是一级域名（顶级域名），www.baidu.com是二级域名 ip 分为ipv4，ipv6 解析详解 www.baidu.com? com = 1.1.1.1 （TLD服务器地址） www.baidu.com? baidu.com = 2.2.2.2 （名称服务器地址 name server） www.baidu.com? www.baidu.com = 3.3.3.3 （目标ip地址） dns缓存可以使解析更快响应。","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Navigation Timing & Navigation Timing API","slug":"navigationTiming","date":"2020-07-24T02:35:22.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/24/navigationTiming/","link":"","permalink":"https://feidom-up.github.io/2020/07/24/navigationTiming/","excerpt":"","text":"Navigation Timing 图解： Prompt for unload // 激起卸载 navigationStart // 导航开始 redirect // 本地重定向 redirectStart redirectEnd unload // 本地重定向的同时 卸载 unloadStart unloadEnd App cache // 有缓存拿缓存 fetchStart DNS // DNS域名解析 domainLookipStart domainLookupEnd TCP // 建立tcp连接 connectStart // 开始三次握手，四次挥手 (secureConnectionStart) // 建立https安全协议的加密链接 connectEnd Request // 请求 requestStart Response // 响应 responseStart responseEnd Processing // 前端HTML处理 domLoading domInteractive domContentLoaded domComplate onload // onload loadEventStart loadEventEnd","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"HTML、CSS、JS互相阻塞？咋回事","slug":"HTMLCSSJS渲染执行","date":"2020-07-23T09:08:37.000Z","updated":"2024-08-22T02:26:03.657Z","comments":true,"path":"2020/07/23/HTMLCSSJS渲染执行/","link":"","permalink":"https://feidom-up.github.io/2020/07/23/HTMLCSSJS%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C/","excerpt":"","text":"js是同步的，为了操作dom。在html执行中，也由于这个原因，有同步阻塞的情况。 js的执行会影响Dom渲染吗?12345678910111213&lt;head&gt; &lt;script&gt; // 这个script放在dom上边，影响dom解析，也影响dom渲染。 alert('1') &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;script&gt; // 这个script放在dom下边，影响dom渲染，不影响dom解析 alert('1') &lt;/script&gt;&lt;/body&gt;css的执行会影响Dom渲染吗?123456789101112131415161718&lt;head&gt; &lt;style&gt; h1&#123; color: red !important; &#125; &lt;/style&gt; &lt;script&gt; setTimeout(()=&gt;&#123; console.log(document.querySelectorAll('h1')) &#125;,0) &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css\" &gt; &lt;!-- animate.css没回来之前，script中打印了h1，但是h1并没有在页面中展示。 --&gt; &lt;!-- css不影响dom解析，影响dom渲染 --&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt;&lt;/body&gt;css的执行会影响js执行吗?12345678910111213141516&lt;head&gt; &lt;style&gt; h1&#123; color: red !important; &#125; &lt;/style&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css\" &gt; &lt;!-- animate.css没回来之前，script中没有打印h1。h1并没有在页面中展示。 --&gt; &lt;!-- css加载阻塞js执行。原因：js中可能存在对dom元素的操作或者取值，同步解决这个问题。所以阻塞。 --&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;script&gt; console.log('1') &lt;/script&gt;&lt;/body&gt;css的执行会影响domReady吗?domReady时，js可以操作dom。 1234567891011121314151617&lt;head&gt; &lt;script&gt; document.addEventListener('DOMContentLoaded', function()&#123; console.log('DOMContentLoaded') &#125;) &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css\" &gt; &lt;!-- 在animate.css没回来之前，打印了DOMContentLoaded。说明css不影响domReady --&gt; &lt;script&gt; console.log('111') &lt;/script&gt; &lt;!-- 加了上面这个script脚本时，在animate.css没回来之前，不打印111，也不打印DOMContentLoaded。 也是因为js中可能存在对dom元素的操作或者取值 --&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt;&lt;/body&gt;","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"浏览器渲染过程及优化","slug":"浏览器渲染过程","date":"2020-07-22T06:32:38.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2020/07/22/浏览器渲染过程/","link":"","permalink":"https://feidom-up.github.io/2020/07/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"熟练使用Chrome开发工具 浏览器渲染基础cpu主要负责操作系统和程序 gpu负责显式 数据处理效率更高 gpu.js Dom是分层的 firefox的3d插件（已废弃）很好的展现了这个点。 Q:什么元素会分层？ A:根元素，position层，transform、半透明、css滤镜、canvas、video、overflow等 对DOM元素节点计算样式结果。（Recalculate Style） 为每个节点生成图形位置。（Layout 回流/重排） 将每个节点绘制填充到图层位图中。（Paint） 把图层作为纹理，上传到GPU 把符合的图层生成到页面上。（Composite Layers 合成层） Q:Composite Layers做了啥？ A:图层的绘制列表，准备好，commit给（合成线程）主线程 合成线程 viewport 划分图块 生成位图的过程 光栅化 Raster 所有图块 合成DarwQuad提交给浏览器渲染进程 viz组件接收到DarwQuad 后，绘制到屏幕上 总结上面过程的主要过程Layout ==&gt; Paint ==&gt; Composite Layers 渲染引擎结构与工作流程以HTML、JS、CSS等文件作为输入，以可视化内容作为输出经过下面步骤： Parsing HTML to construct DOM tree 根据html文件生成dom树，框架 Render Tree Construction 根据css，js文件，在dom树的基础上生成渲染树 Layout of Render Tree 渲染树布局排版（重排） Painting Render Tree 排版之后。绘制（重绘） Display （Composite Layers 合成层，布局树）后，把符合的图层上传到GPU生成到页面上展示。 把文档的结构、元素的样式、几何形状和绘制顺序转换在屏幕上的像素。这个过程称为光栅化 合成是一种将页面的各个部分分层，分别栅格化，并在一个被称为合成器线程的独立线程中合成页面的技术 上传到GPU生成到页面上展示。 浏览器渲染优化 跳过重排重绘 直接触发了GPU执行 这就是硬件加速 Q:什么会触发硬件加速，让GPU加入进来？ A:CSS3D、video、webgl、transform、css滤镜、will-change:transform 12345678910111213141516171819202122@keyframes ball-running &#123; 0% &#123; top:0; left: 0; /* transform: translate(0,0); */ &#125; 25% &#123; top:0; left: 200px; /* transform: translate(200px,0); */ &#125; 50% &#123; top:200px; left: 200px; /* transform: translate(200px,200px); */ &#125; 75% &#123; top:200px; left: 0; /* transform: translate(0,200px); */ &#125;&#125; 上面的动画代码会一直触发重排重绘，性能差 下面的动画代码将处理交给GPU放在一个layer层中去处理，跳过重排重绘,性能大大提升 1234567891011121314@keyframes ball-running &#123; 0% &#123; transform: translate(0,0); &#125; 25% &#123; transform: translate(200px,0); &#125; 50% &#123; transform: translate(200px,200px); &#125; 75% &#123; transform: translate(0,200px); &#125;&#125; Q:什么属性会造成重排重绘，导致性能下降？ A: 可以参考这个网站：[csstriggers](https://csstriggers.com/) 盒子模型的盒子变了 读属性时：offset、scroll、client、width会造成重排（下面为解决方案:requestAnimationFrame） 123456&#x2F;&#x2F; 解决方式: 读写分离（读写读写读写&#x3D;&#x3D;&#x3D;&gt;读读读写写写）const width &#x3D; document.getElementById(&quot;xx&quot;).width;requestAnimationFrame(function()&#123; &#x2F;&#x2F; 写逻辑 &#x2F;&#x2F; React Fiber？&#125;) 大量Dom如何优化以下内容来自京城一灯小程序Day102题 缓存Dom对象 操作Dom时，如果有访问Dom的操作。尤其像循环遍历这种时间复杂度较高的操作。 在循环前将父（主）节点先获取到，在循环中就可以直接饮用，不必要循环查询 12345let rootElem = document.querySelector('#app');let childList = rootElem.child; for(let i=0;i&lt;childList.length;j++)&#123; //对应操作&#125; 文档片段 利用document.createDocumentFragment()方法创建文档碎片节点，创建的是一个虚拟Dom对象。向这个节点添加Dom节点，修改Dom节点并不会影响到真是的Dom结构。 我们可以利用这一点先将需要修改的Dom一并修改完，保存至文档碎片中，然后用文档碎片一次性的替换真实的Dom节点。与虚拟Dom类似，也达到了不频繁修改Dom而导致的重排和重绘的过程 123456let fragment = document.createDocumentFragment();const operationDomHandler = (fragment)=&gt;&#123; // 操作&#125;operationDomHandler(fragment);rootElem.replaceChild(fragment, oldDom) 这样只触发一次回流（重排），效率会打打提升。如果需要对元素进行复杂的操作（删减，添加加点），那么我们应当先将元素从页面中移除，然后再对其进行操作。或者将其复制一个（cloneNode()）,在内存中进行操作后再替换原来的节点 123let cloneNode = old.cloneNode(true);operationDomHandler(cloneNode); rootElem.replaceChild(cloneNode, oldDom); 用innerHtml代替高频的appendChild 最优的layout方案 批量读，一次性写。 先对一个不在render tree上的节点进行操作，在把这个节点添加回render tree。这样只处罚一次Dom操作。使用requestAnimationFrame()，把任何导致重绘的操作放入requestAnimationFrame 12345const width = document.getElementById(\"xx\").width;requestAnimationFrame(function()&#123; // 写逻辑 // React Fiber？&#125;) 虚拟Dom js模拟Dom树并对Dom树操作的一种技术。Virtual Dom是一个纯js对象（字符串对象），所以对它操作是高效的。 利用Virtual Dom，将dom抽象为虚拟Dom，在Dom发生改变的时候先将虚拟Dom进行操作，通过Dom diff算法将虚拟Dom和原虚拟Dom的结构对比，最终批量的去修改真是的Dom结构，尽可能的避免了频繁修改Dom而导致的频繁的重排和重绘。 fastdom，处理dom的插件","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端性能优化","slug":"前端性能优化","date":"2020-07-21T01:29:03.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/07/21/前端性能优化/","link":"","permalink":"https://feidom-up.github.io/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"Http请求的代价是昂贵的Navigation Timing从输入网址敲击回车开始到页面完全加载完成展示。其中的过程是优化的要点。 性能优化方向前端性能优化（一）雅虎军规前端性能优化（二）缓存为王前端性能优化（三）协议处理前端性能优化（四）渲染优化前端性能优化（五）HTML中css,js标签位置的影响 渐进式 Web 应用（PWA） 站点测速根据用户的网速进行适配的资源加载 navigator.connection Navigator.connection 是只读的，提供一个NetworkInformation 对象来获取设备的网络连接信息。例如用户设备的当前带宽或连接是否被计量， 这可以用于基于用户的连接来选择高清晰度内容或低清晰度内容。(不太准确) connectionInfo = navigator.connection 纯图片请求，速度 = 文件大小 / 时间 算出的速度包含dns解析等时间，不纯粹不准 speed = size/time 多普勒测速 speed = (40k-10k)/(t5-t4)","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端性能优化（三）协议处理","slug":"前端性能优化（三）协议处理","date":"2020-07-21T01:28:22.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/07/21/前端性能优化（三）协议处理/","link":"","permalink":"https://feidom-up.github.io/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"http请求的代价是昂贵的HTTP 缓存，对于前端的性能优化方面来讲，是非常关键的，从缓存中读取数据和直接向服务器请求数据。 协议缓存规则浏览器发起请求，服务器响应请求。在这个过程中，双方协商了两种方式来规定缓存规则。 强缓存： 浏览器在加载资源时，根据请求头的 Expires 和 Cache-control 判断，是则直接从缓存读取资源，不会发请求到服务器。 优先级高于协商缓存 协商缓存 如果没有命中强缓存，加载资源的请求会发送到服务器，通过 Last-Modified 和 Etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回304（Not Modified），但是不会返回这个资源的数据，依然是从缓存中读取资源。 如果前面两者都没有命中，直接从服务器加载资源。","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端性能优化（二）缓存为王","slug":"前端性能优化（二）缓存为王","date":"2020-07-21T01:27:45.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/07/21/前端性能优化（二）缓存为王/","link":"","permalink":"https://feidom-up.github.io/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%93%E5%AD%98%E4%B8%BA%E7%8E%8B/","excerpt":"","text":"HTTP缓存常用的库(jquery等)，不经常变得这些库，版本要求不是很严格，用HTTP强缓存。前端性能优化（三）协议处理 前端离线缓存业务代码，md5变化频繁，使用本地缓存。 cookie 存储最大数据量为4K 同一个域名下存放 Cookie 的个数是有限制的，不同浏览器的个数不一样，一般为 20 个； Cookie 支持设置过期时间，当过期时自动销毁； 每次发起同域下的请求都会发送回服务器 Local Storage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。（和Session Storage的区别） 相当于一个 5M左右的针对于前端页面的数据库 键值对存储，存储的Value限定为string类型 在浏览器的隐私模式下不可读取 本质上是对字符串的读取,且操作是同步的，建议存储量在2.5M以下，否则会变卡 不能被爬虫抓取到 受到同源限制，不能跨域。但是,可以借助postMessage和iframe来实现跨域的数据读取 在同源的所有标签页和窗口之间共享数据 Session Storage 与 localStorage 拥有统一的 API 接口； 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。（和Local Storage的区别） 数据在页面刷新后依然存在，但在关闭浏览器标签页之后数据就会被清除； IndexedDB（NoSQL 数据库） 允许储存大量数据（一般来说不少于 250M，甚至没有上限），提供查找接口，还能建立索引。 键值对储存。所有类型的数据都可以直接存入，包括 JavaScript 对象。同时支持二进制储存（ArrayBuffer 对象和 Blob 对象）。 操作是异步的 支持事务。 受到同源限制，每一个数据库对应创建它的域名。访问不能跨域。 来自 阮一峰的网络日志 Web SQl Web SQL 能方便进行对象存储 Web SQL 支持事务，能方便地进行数据查询和数据处理操作 HTML5放弃了Web SQL Database放弃的原因是：This document was on the W3C Recommendation track but specification work has stopped. The specification reached an impasse: all interested implementors have used the same SQL backend (Sqlite), but we need multiple independent implementations to proceed along a standardisation path.大概意思是：这个文档是W3C推荐的，但是规范工作已经停止了。规范陷入了僵局:所有感兴趣的实现者都使用相同的SQL后端(Sqlite)，但是我们需要多个独立的实现来沿着标准化的道路前进。 本地缓存方案 主流的数据 开源库 localForagelocalForage 是一个快速简单的 JavaScript 存储库。它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。 Dexie.jsDexie.js 是 IndexedDB 的包装库，它提供了一套经过精心设计的 API，强大的错误处理，较强的可扩展性，此外它能够跟踪数据变化，支持 KeyRange (搜索不区分大小写，可设置匹方式和 OR 操作)。Dexie.js 主要为了解决原生 IndexedDB API 中存在的三个主要问题：异常错误处理。较弱的查询功能。代码复杂性。 local Storage缓存js方案管理版本 存储文件的js完整路径及名称，名称中包含文件版本信息（md5等）。localStorage.setItem(&quot;common:widget/a.js&quot;, &quot;/static/common/widget/a_[md5旧].js&quot;) 根据js完整路径及名称，存储js代码localStorage.setItem(&quot;/static/common/widget/a_[md5旧].js&quot;, &quot;代码code...&quot;) init时，启动的js脚本加载manifest这种清单123const manifest = &#123; \"common:widget/a.js\":\"/static/common/widget/a_[md5新].js\"&#125; 逻辑判断，加载js12345678910111213141516171819202122232425262728const aJs = localStorage.getItem(\"common:widget/a.js\") // \"/static/common/widget/a_[md5旧].js\"const md5 = \"md5新\" // 文件版本&lt;!-- 然后判断这个文件是否存在 --&gt;if(aJs)&#123; // 存在，有缓存 if(md5 === \"md5旧\")&#123; // 缓存没过期，直接去缓存里的 const aJsCode = localStorage.getItem(aJs) // 执行缓存的js代码,evel只是例子，不建议使用.可以addScript evel(aJsCode) &#125;else&#123; // 缓存过期 localStorage.removeItem(aJs) // 拉取新的 const aJsCodeNew = fetch(\"/static/common/widget/a_[md5新].js\") // 存缓存 localStorage.setItem(\"common:widget/a.js\", \"/static/common/widget/a_[md5新].js\") localStorage.setItem( \"/static/common/widget/a_[md5新].js\", aJsNew) // 执行新的js代码 evel(aJsCodeNew) &#125;&#125;else&#123; // 不存在，没有缓存。拉取新的文件，执行 fetch(\"/static/common/widget/a_[md5新].js\") // 做缓存 localStorage.setItem(\"common:widget/a.js\", \"/static/common/widget/a_[md5新].js\") localStorage.setItem(\"/static/common/widget/a_[md5新].js\", \"代码code...\")&#125;","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端性能优化（一）雅虎军规","slug":"前端性能优化（一）雅虎军规","date":"2020-07-21T00:40:57.000Z","updated":"2024-08-22T02:26:03.663Z","comments":true,"path":"2020/07/21/前端性能优化（一）雅虎军规/","link":"","permalink":"https://feidom-up.github.io/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84/","excerpt":"","text":"雅虎军规 内容主体： 尽量减少HTTP请求数 减少DNS查找 避免重定向 让Ajax可缓存 延迟加载组件 预加载组件 减少DOM元素的数量 善用css伪类 按需加载，减少不必要的渲染 结构合理，语义化标签 跨域分离组件 分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。 尽量少用iframe 杜绝404 css部分： 把样式表放在顶部 避免使用CSS表达式 选择&lt;link&gt;舍弃@import 避免使用滤镜 js部分： 去除重复脚本 尽量减少DOM访问 用智能的事件处理器 事件委托 把脚本放在底部 5-6个script请求，每个文件大小gzip后30kb左右 javascript, css部分: 把JavaScript和CSS放到外面 压缩JavaScript和CSS 图片 优化图片 优化CSS Sprite 不要用HTML缩放图片 用小的可缓存的favicon.ico（P.S. 收藏夹图标） svg图片的使用；CSS Sprites（雪碧图/精灵图）；tinypngjs（图片压缩工具） cookie 给cookie减肥 把组件放在不含cookie的域下 移动端 保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件 把组件打包到一个复合文档里 服务器 Gzip组件 避免图片src属性为空 配置ETags 对Ajax用GET请求 尽早清空缓冲区 使用CDN（内容分发网络） 添上Expires或者Cache-Control HTTP头","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"node的websockets监听unix_domain_socket","slug":"node的websockets监听unix-domain-socket","date":"2020-07-20T09:45:57.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/20/node的websockets监听unix-domain-socket/","link":"","permalink":"https://feidom-up.github.io/2020/07/20/node%E7%9A%84websockets%E7%9B%91%E5%90%ACunix-domain-socket/","excerpt":"","text":"WebSockets listening on UNIX domain socket? Server side: 12345var http = require('http');var WebSocketServer = require('ws').Server;var server = http.createServer()var wss = new WebSocketServer(&#123; server : server&#125;);server.listen('/tmp/server.sock') Client side: 123var ws = require('ws');var client = new ws(\"ws+unix:///tmp/server.sock\")client.send('hello') 原文地址","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/tags/nodejs/"}]},{"title":"linux下常用命令查看端口占用","slug":"linux下常用命令查看端口占用","date":"2020-07-11T07:07:02.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/11/linux下常用命令查看端口占用/","link":"","permalink":"https://feidom-up.github.io/2020/07/11/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/","excerpt":"","text":"查看当前所有tcp端口$ netstat -ntlp 查看所有9000端口使用情况netstat -ntulp | grep 3306","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://feidom-up.github.io/tags/Linux/"}]},{"title":"sonarqube配置及使用","slug":"sonarqube配置及使用","date":"2020-07-11T00:47:02.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2020/07/11/sonarqube配置及使用/","link":"","permalink":"https://feidom-up.github.io/2020/07/11/sonarqube%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"sonarqube官网文档：代码质量的检测及管理 安装java环境 安装java环境（本地和服务器都需要）sonarqube依赖高版本的java环境，以下内容使用jdk14在oracle官网下载javamac版（macOS Installer）和服务器Linux版（Linux RPM Package）。这种的不需要配环境变量，自动配好。 注意：不要装openjdk 将服务器Linux版的jdk上传到服务器并安装(pwd命令查看文件绝对路径)$ scp /Users/yingying/Downloads/jdk-14.0.1_linux-x64_bin.rpm root@8.129.182.113:/opt/rpm安装jdk$ rpm -i jdk-14.0.1_linux-x64_bin.rpmrpm查询包信息$ rpm -qa 找到=&gt; jdk-14.0.1-14.0.1-ga.x86_64rpm卸载jsk$ rpm -e jdk-14.0.1-14.0.1-ga.x86_64 安装sonarqube 在服务器端安装Community版本wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-8.4.0.35506.zip sonarqube不能使用root身份启动，所以建一个sonar用户，将sonarqube-developer-8.4.0.35506.zip文件给到sonar用户。123root$ useradd sonarroot$ passwd sonarroot$ chown -R sonar sonarqube-developer-8.4.0.35506.zip 切换用户身份到sonar进行接下来的操作su sonar1sonar$ unzip sonarqube-developer-8.4.0.35506.zip 提示没有权限。 注意：在opt文件夹下解压 文件.zip。会创建一个新的文件夹存放解压文件。此时sonar用户没有opt文件夹的读写执行权限。所以报错Permission denied解决：使用root身份修改文件权限。给sonar权限。 12root$ chmod 754 optroot$ chmod 777 /opt/sonarqube-developer-8.4.0.35506.zip 然后执行unzip，解压成功。之后进入解压文件夹下的bin目录的linux-x86-64目录1sonar$ cd /opt/sonarqube-8.4.0.35506/bin/linux-x86-64/ 运行sonarqube在这有sonar.sh启动脚本，先不着急./sonar.sh start。先使用console查看启动日志,再start 123sonar$ cd /opt/sonarqube-8.4.0.35506/bin/linux-x86-64/sonar$ ./sonar.sh consolesonar$ ./sonar.sh start 意外：在启动成功后，使用公网ip:端口号 访问失败。发现是阿里云安全组的问题。配置好了以后访问成功意外：在装了汉化包之后，重启sonarqube，启动成功。但是访问一直pending。过一会就好了。应该是汉化包太大，在加载的原因 初始化一个项目（test）以下操作都可以在公网ip:9000项目中可视化操作 使用公网ip:9000访问到sonarqube 使用默认账号/密码：admin/admin登陆 手工设置一个项目：test 设置一个token（客户端会用到的口令） 开始分析项目 选择项目的主要语言：其他（js） 选择客户端的操作系统（macOS） 下载并解压macOS平台的解析器SonarScanner，是一个zip文件 为SonarScanner配置环境变量配置～/.bash_profile123# sonar-scanner 环境变量 pwd找到sonar-scanner目录下的bin文件夹路径export SCANNER_HOME=\"/Users/yingying/Documents/qwf/libs/sonar-scanner-4.4.0.2170-macosx\"export PATH=$PATH:$SCANNER_HOME/bin 使环境变量生效$ source .bash_profile可以执行$ sonar-scanner -v来查看是否配置安装成功 在项目（例：nodejs-demo）中配置SonarScanner在项目根目录新建sonar-project.properties文件。123456789sonar-scanner \\ # 项目名 -Dsonar.projectKey=test \\ # 要扫描的代码目录 -Dsonar.sources=. \\ # 要上报报告的服务器链接 -Dsonar.host.url=http://8.129.182.113:9000 \\ # token -Dsonar.login=a258647adea0e982df705ac3512cbbe47154cfd3 在终端 shell 执行你的这个 sonar-project.properties 文件bash sonar-project.properties。静静等待10分钟左右… 结果报表会在公网ip:9000中可视化展示 数据库配置 自带的内嵌数据库比较小。处理大项目需要配一下 sonarQube默认不支持mysql。需要安装mysql Connector(驱动)后才能使用安装方式：将驱动放在extensions/jdbc-driver/mysql/（这个路径不确定）下 配置文件：/opt/sonarqube-8.4.0.35506/conf/sonar.properties1sonar.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.1.222:3306&#x2F;sonar?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;rewriteBatchedStatements&#x3D;true 在使用库使，要提前建立好sonar库，命令参照如下：1234567891011DROP DATABASE sonar;CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;CREATE USER &#39;sonar&#39; IDENTIFIED BY &#39;sonar&#39;;GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;;GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;sonar&#39;;FLUSH PRIVILEGES; 结束详细操作链接","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"sonarqube","slug":"sonarqube","permalink":"https://feidom-up.github.io/tags/sonarqube/"}]},{"title":"进程&线程&协程","slug":"进程线程协程","date":"2020-07-08T00:24:22.000Z","updated":"2024-08-22T02:26:03.664Z","comments":true,"path":"2020/07/08/进程线程协程/","link":"","permalink":"https://feidom-up.github.io/2020/07/08/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"基本概念 进程是cpu调度的基本单位 线程是cpu调度的最小单位，一个进程至少有一个线程（主线程） 协程不被操作系统内核所管理，完全由程序控制。 多种进程 单线程进程的fork过程，将主线程的代码、数据、文件、寄存器状态、栈都复制多份。 多线程进程中，各个线程拥有自己的寄存器状态和栈。共享进程中的代码、数据、文件。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://feidom-up.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://feidom-up.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"js实现PM2多进程原理（简版）","slug":"js实现PM2多进程原理（简版）","date":"2020-07-07T03:43:27.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/07/js实现PM2多进程原理（简版）/","link":"","permalink":"https://feidom-up.github.io/2020/07/07/js%E5%AE%9E%E7%8E%B0PM2%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E7%89%88%EF%BC%89/","excerpt":"","text":"了解进程&amp;线程&amp;协程 app.js 前端实现的node项目 123456// workervar http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200); res.end(\"hello world\\n\");&#125;).listen(8000); pm2.js 模拟PM2多进程 12345678910111213// mastervar cluster = require('cluster');var numCPUs = require('os').cpus().length; // 多核cpu的核数 // cluster.isMaster为true，表示是主进程if (cluster.isMaster) &#123; console.log(numCPUs); for (var i = 0; i &lt; numCPUs; i++) &#123; var worker = cluster.fork(); &#125;&#125; else &#123; require(\"./app.js\");&#125; pm2.js运行后，会创建一个主进程（父进程master）。 然后创建numCPUs个node进程，这些进程相当于子进程。受到主进程master的管理，调度分配共创建了numCPUs+1个进程 重点在cluster.fork()来fork子进程。然后cluster.isMaster为false时，创建的子进程去require(&quot;./app.js&quot;)，实现多进程管理。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/tags/nodejs/"},{"name":"PM2","slug":"PM2","permalink":"https://feidom-up.github.io/tags/PM2/"},{"name":"进程管理","slug":"进程管理","permalink":"https://feidom-up.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"Linux免密远程登录","slug":"Linux免密远程登录","date":"2020-07-07T02:51:12.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/07/07/Linux免密远程登录/","link":"","permalink":"https://feidom-up.github.io/2020/07/07/Linux%E5%85%8D%E5%AF%86%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","excerpt":"","text":"前端在部署项目时，使用Linux免密远程登录可以实现自动化中的一环。 免密登录的原理ssh，密码学，公钥，私钥 免密登录的步骤 下文中：[你自己的名字]是私钥，[你自己的名字_rsa]是公钥 生成密匙对 $ ssh-keygen -t rsa -C [你自己的名字] -f [你自己的名字_rsa] 上传配置公钥 上传公钥到服务器对应账号的home路径下的.ssh/中$ ssh-copy-id -i [你自己的名字_rsa] [用户名@服务器ip或域名] 配置公钥文件访问权限为 600 (设置拥有者可读写，其他人不可读写执行 -rw——-)$ chmod 600 [你自己的名字_rsa] 配置本地私钥 把第一步生成的私钥复制到你的home目录下的.ssh/ 路径下 配置你的私钥文件访问权限为 600 (-rw——-,不是600系统会认为不安全拒绝访问)$ chmod 600 [你自己的名字] 这一步之后已经可以免密登录ssh -i [你自己的名字] root@[ip] 免密登陆功能的本地配置文件(更方便的免密登录方式) 编辑自己home目录的.ssh/ 路径下的config文件vi config1234567891011121314151617181920212223242526272829303132333435363738394041# 多主机配置Host gateway-produceHostName IP或绑定的域名Port 22Host node-produceHostName IP或绑定的域名Port 22Host java-produceHostName IP或绑定的域名Port 22Host *-produce (多主机别名，免密登录时可以使用这个别名登录)User rootIdentityFile ~/.ssh/你自己的名字_rsaProtocol 2Compression yesServerAliveInterval 60ServerAliveCountMax 20LogLevel INFO#单主机配置Host feidom-cloud (别名，免密登录时可以使用这个别名登录)User rootHostName IP或绑定的域名IdentityFile ~/.ssh/你自己的名字_rsaProtocol 2Compression yesServerAliveInterval 60ServerAliveCountMax 20LogLevel INFO#单主机配置Host feidom2-siteUser gitHostName IP或绑定的域名IdentityFile ~/.ssh/你自己的名字_rsaProtocol 2Compression yesServerAliveInterval 60ServerAliveCountMax 20LogLevel INFO 配置config文件的访问权限为 644 使用ssh [别名]","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://feidom-up.github.io/tags/Linux/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"categories和tags页面不自动收录的问题","slug":"hexo的categories和tags页面不自动收录的问题","date":"2020-07-06T01:51:18.000Z","updated":"2024-08-22T02:26:03.659Z","comments":true,"path":"2020/07/06/hexo的categories和tags页面不自动收录的问题/","link":"","permalink":"https://feidom-up.github.io/2020/07/06/hexo%E7%9A%84categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E8%87%AA%E5%8A%A8%E6%94%B6%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"在使用hexo的过程中，发现分类(categories)页面和标签(tags)页面不自动收录文章(其实收录了，只是没显示)的categories和tags。解决方案： 编辑categories/index.md123456title: 分类date: 2020-07-01 08:56:35type: categories增加下面这一行layout: &quot;categories&quot; tags/index.md123456title: 标签date: 2020-07-01 09:03:55type: &quot;tags&quot;增加下面这一行layout: &quot;tags&quot;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://feidom-up.github.io/categories/hexo/"}],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://feidom-up.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"hexo","slug":"hexo","permalink":"https://feidom-up.github.io/tags/hexo/"}]},{"title":"git常用命令(个人总结)","slug":"git常用命令","date":"2020-07-04T13:04:13.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/07/04/git常用命令/","link":"","permalink":"https://feidom-up.github.io/2020/07/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git概念 Workspace：工作区 Index / Stage：暂存区 Repository：本地仓库 Remote：远程仓库 常用命令 查看git config配置git config --list git config全局配置 12git config --global user.name \"feidom\"git config --global user.email \"qiaoxiansen@hotmail.com\" git config针对单个项目配置用户 123# cd 项目目录,作用于当前项目下的.git目录下的configgit config user.name \"feidom\"git config user.email \"qiaoxiansen@hotmail.com\" 克隆一个项目和它的整个代码历史$ git clone [url] 查看本地仓库分支$ git branch 查看所有本地分支和远程分支$ git branch -a 查看所有所有远程分支$ git branch -r 查看分支关联关系$ git branch -vv 查看不同$ git diff 显示有变更的文件$ git status 添加当前目录的所有文件到暂存区$ git add . 提交暂存区到本地仓库$ git commit -m [提交信息] 拉取远程仓库带代码到本地仓库并合并$ git pull [remote] [branch]$ git pull(分支有关联关系时) 上传本地指定分支到远程仓库$ git push [remote] [branch]$ git push(分支有关联关系时) 创建一个新的空分支（内容来自互联网）$ git checkout --orphan [新的分支名] (建一个没有父节点的分支，但是会复制当前分支的内容到新的分支上。) &emsp; 这个命令创建了新的分支并切换到新的分支下，并且里边有上个分支的内容&emsp; 注意 ：其实这个时候新的分支还不能说是一个分支，你查看分支的话，是没有这个分支的，你必须要提交一次，这个分支才算是真的创建出来了&emsp; 因为这个分支没有父节点，所以没有任何的历史，只需要调用&emsp; $ git rm -rf .&emsp; 删除所有的文件（只会删除加入版本管理的文件），然后你可以随便创建一个文件，提交之后，这个新的空分支就算是创建完成了。 新建一个本地分支，并切换到该分支$ git checkout -b [本地分支] [remote](-b会建立本地分支和远程分支的关联关系) 从某个提交记录(2b5c3292)拉一个新分支出来$ git checkout 2b5c3292 -b [branch] 提交当前分支到远程仓库的对应的新分支$ git push -u origin [branch](-u会建立本地分支和远程分支的关联关系) 新建本地分支与远程分支关联关系git branch --set-upstream-to [远程分支] [本地分支] 删除本地分支切到其他分支，然后git branch -d [本地分支] 从远程获取其他用户push上来的新分支git fetch 查看远程仓库信息git remote -v 移除远程仓库git remote remove origin 添加远程仓库git remote add origin [远程仓库地址] 查看该分支的远程仓库git remote showupstream：被fork的仓库/origin：自己fork的仓库 从自己本地切一个分支出来git checkout -b [本地分支名] 从远程仓库地址pull代码git pull origin master --rebase 先拉自己fork仓库的最新代码git pull upstream master --rebase 再拉被fork仓库的最新代码 推送代码到自己fork仓库分支git push origin [自己远程仓库的分支] 合并多个commit记录为一个git rebase -i HEAD~ 自己的远端提pull request到upstream的远端，github上操作 vscode合并分支在vscode界面，输入：ctrl(win)/command(mac)+shift+p,然后输入git merge，然后选一个要合并到当前分支的分支，回车确定即可。 git问题解决： git clone 时出错： 12error: RPC failed; result&#x3D;35, HTTP code &#x3D; 0fatal: The remote end hung up unexpectedly 解决： 查看全局的postBuffer配置 git config http.postBuffer 把这个配置改大一点： git config http.postBuffer 24288000","categories":[{"name":"git","slug":"git","permalink":"https://feidom-up.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://feidom-up.github.io/tags/git/"}]},{"title":"svg图标的使用","slug":"svg图标的使用","date":"2020-07-04T13:01:58.000Z","updated":"2024-08-22T02:26:03.660Z","comments":true,"path":"2020/07/04/svg图标的使用/","link":"","permalink":"https://feidom-up.github.io/2020/07/04/svg%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"svg图标在前端应用的优点 和传统的图像比起来，尺寸更小，且可压缩性更强 可伸缩 任何分辨率之下都可以被完美的打印 svg中图像中的文本是可选的，同时也是可搜索的，很适合做地图。 svg必须知道的标签知识 &lt;defs&gt;SVG 允许我们定义以后需要重复使用的图形元素。 建议把所有需要再次使用的引用元素定义在defs元素里面。这样做可以增加SVG内容的易读性和可访问性。 在defs元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用&lt;use&gt;元素呈现这些元素。 &lt;use&gt;官方说法：使用URI引用一个,或其他具有一个唯一的ID属性和重复的图形元素。复制的是原始的元素，因此文件中的原始存在只是一个参考。原始影响到所有副本的任何改变。理解：作用是能从SVG文档内部取出一个节点，通过唯一的ID属性克隆它，并把它输出到别处。跟‘引用’很相似，但它是深度克隆。 &lt;path&gt;SVG路径，path元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。 svg常用修改 修改宽(width)高(height) 修改svg标签内的width、height来修改图标的大小宽(width)高(height) 修改颜色 在style标签中定义类，使用fill关键字定义颜色，如.st7。 在path标签中增加类名：class=”st7”，用类名控制颜色。 如下例： 1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!-- 修改svg标签内的width、height来修改图标的大小宽(width)高(height) --&gt;&lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;图层_1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot; width&#x3D;&quot;17px&quot; height&#x3D;&quot;16px&quot; viewBox&#x3D;&quot;0 0 11 11&quot; style&#x3D;&quot;enable-background:new 0 0 11 11;&quot; xml:space&#x3D;&quot;preserve&quot;&gt;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; .st0&#123;fill:#08A6F1;&#125; .st1&#123;fill:#18C27B;&#125; .st2&#123;fill:#FFA200;&#125; .st3&#123;fill-rule:evenodd;clip-rule:evenodd;fill:#18C27B;&#125; .st4&#123;fill-rule:evenodd;clip-rule:evenodd;fill:#FFA200;&#125; .st5&#123;fill:#F44436;&#125; .st6&#123;clip-path:url(#SVGID_2_);&#125; .st7&#123;fill:#00CDD9;&#125;&lt;&#x2F;style&gt;&lt;!-- 1.在style标签中定义类，使用fill关键字定义颜色，如.st7。 --&gt;&lt;!-- 2.在path标签中增加类名：class&#x3D;&quot;st7&quot;，用类名控制颜色。 --&gt;&lt;path class&#x3D;&quot;st7&quot; d&#x3D;&quot;M11,10.7c0,0.2-0.2,0.3-0.3,0.3H0.3C0.2,11,0,10.8,0,10.7V10c0-0.2,0.2-0.3,0.3-0.3h10.3c0.2,0,0.3,0.2,0.3,0.3L11,10.7 L11,10.7z M1.9,4.8l3.3,3.4c0.1,0.1,0.4,0.1,0.5,0l0,0l3.3-3.4c0.1-0.1,0.1-0.2,0.1-0.4C9.1,4.3,9,4.2,8.8,4.2h-2V0.3 C6.9,0.2,6.7,0,6.5,0H4.5C4.3,0,4.1,0.2,4.1,0.3v3.9h-2C2,4.2,1.8,4.4,1.8,4.6C1.8,4.7,1.8,4.8,1.9,4.8L1.9,4.8z&quot;&#x2F;&gt;&lt;&#x2F;svg&gt;","categories":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/tags/css/"},{"name":"svg","slug":"svg","permalink":"https://feidom-up.github.io/tags/svg/"}]},{"title":"NodeJs前端话事人","slug":"NodeJs前端话事人","date":"2020-07-01T01:27:39.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/07/01/NodeJs前端话事人/","link":"","permalink":"https://feidom-up.github.io/2020/07/01/NodeJs%E5%89%8D%E7%AB%AF%E8%AF%9D%E4%BA%8B%E4%BA%BA/","excerpt":"","text":"NodeJsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。 Node.js 中文网 NodeJs应用场景 我要的只是一个香蕉，得到的确是整个森林 SSR(服务器端渲染) SEO友好 优化单页应用的首屏加载时间 NodeJs闪亮登场SPA(single page web application) + NodeJs方案：NodeJs做Proxy(代理)层，加载web页，连接后台服务。 实现了: 消减接口返回的response。经过NodeJs层处理返回的数据，前端拿到的只有她该拿到的东西，数据小了，传输快了，性能更好。 真假路由混用。Node可以独立控制路由，并不受后端限制，可以独立部署上线。前端拥有更强的主动性。 Node可以独立控制路由，可以做同构。 Q&amp;A： &emsp;Q:为什么用NodeJs做代理层，而不用其他语言？ &emsp;A:NodeJs是基于JavaScript语言的，前端框架Vue等只提供Js的API(Nuxt.js)。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/tags/nodejs/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-27T13:09:27.000Z","updated":"2024-08-22T02:26:03.658Z","comments":true,"path":"2020/06/27/hello-world/","link":"","permalink":"https://feidom-up.github.io/2020/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Clean1$ hexo clean New categories1$ hexo new page categories New tags1$ hexo new page tags","categories":[{"name":"hexo","slug":"hexo","permalink":"https://feidom-up.github.io/categories/hexo/"}],"tags":[]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://feidom-up.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/categories/js%E5%8E%9F%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/categories/react/"},{"name":"移动端","slug":"移动端","permalink":"https://feidom-up.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/categories/webpack/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/categories/vue/"},{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"手写代码系列","slug":"手写代码系列","permalink":"https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"vue","slug":"react/vue","permalink":"https://feidom-up.github.io/categories/react/vue/"},{"name":"前端安全","slug":"前端安全","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"编译原理","slug":"编译原理","permalink":"https://feidom-up.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/categories/css/"},{"name":"npm","slug":"npm","permalink":"https://feidom-up.github.io/categories/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/categories/nodejs/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"操作系统","slug":"操作系统","permalink":"https://feidom-up.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"hexo","permalink":"https://feidom-up.github.io/categories/hexo/"},{"name":"git","slug":"git","permalink":"https://feidom-up.github.io/categories/git/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://feidom-up.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"js原理","slug":"js原理","permalink":"https://feidom-up.github.io/tags/js%E5%8E%9F%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"https://feidom-up.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"OT","slug":"OT","permalink":"https://feidom-up.github.io/tags/OT/"},{"name":"react","slug":"react","permalink":"https://feidom-up.github.io/tags/react/"},{"name":"移动端","slug":"移动端","permalink":"https://feidom-up.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://feidom-up.github.io/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://feidom-up.github.io/tags/vue/"},{"name":"vue源码解读","slug":"vue源码解读","permalink":"https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://feidom-up.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://feidom-up.github.io/tags/%E6%A0%88/"},{"name":"serverless","slug":"serverless","permalink":"https://feidom-up.github.io/tags/serverless/"},{"name":"svg","slug":"svg","permalink":"https://feidom-up.github.io/tags/svg/"},{"name":"前端安全","slug":"前端安全","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"问题解决","slug":"问题解决","permalink":"https://feidom-up.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"单元测试","slug":"单元测试","permalink":"https://feidom-up.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"编译原理","slug":"编译原理","permalink":"https://feidom-up.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"图表","slug":"图表","permalink":"https://feidom-up.github.io/tags/%E5%9B%BE%E8%A1%A8/"},{"name":"css","slug":"css","permalink":"https://feidom-up.github.io/tags/css/"},{"name":"动画","slug":"动画","permalink":"https://feidom-up.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"flow","slug":"flow","permalink":"https://feidom-up.github.io/tags/flow/"},{"name":"安装依赖问题","slug":"安装依赖问题","permalink":"https://feidom-up.github.io/tags/%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"name":"tweenmax","slug":"tweenmax","permalink":"https://feidom-up.github.io/tags/tweenmax/"},{"name":"gsap","slug":"gsap","permalink":"https://feidom-up.github.io/tags/gsap/"},{"name":"postcss","slug":"postcss","permalink":"https://feidom-up.github.io/tags/postcss/"},{"name":"yarn","slug":"yarn","permalink":"https://feidom-up.github.io/tags/yarn/"},{"name":"npm","slug":"npm","permalink":"https://feidom-up.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://feidom-up.github.io/tags/nodejs/"},{"name":"Nginx","slug":"Nginx","permalink":"https://feidom-up.github.io/tags/Nginx/"},{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Linux","slug":"Linux","permalink":"https://feidom-up.github.io/tags/Linux/"},{"name":"sonarqube","slug":"sonarqube","permalink":"https://feidom-up.github.io/tags/sonarqube/"},{"name":"操作系统","slug":"操作系统","permalink":"https://feidom-up.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"PM2","slug":"PM2","permalink":"https://feidom-up.github.io/tags/PM2/"},{"name":"进程管理","slug":"进程管理","permalink":"https://feidom-up.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"hexo","slug":"hexo","permalink":"https://feidom-up.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://feidom-up.github.io/tags/git/"}]}