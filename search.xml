<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hhkb快捷键备忘</title>
    <url>/2024/08/22/hhkb%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h3 id="切换连接方式："><a href="#切换连接方式：" class="headerlink" title="切换连接方式："></a>切换连接方式：</h3><ul>
<li>fn+ctrl+0 有线</li>
<li>fn+ctrl+1~4 蓝牙设备</li>
</ul>
<h3 id="蓝牙配对信息注册："><a href="#蓝牙配对信息注册：" class="headerlink" title="蓝牙配对信息注册："></a>蓝牙配对信息注册：</h3><ul>
<li>fn+q 进入等待配对模式</li>
<li>fn+ctrl+1<del>4 将即将要配对的设备存放到 1</del>4 位置。</li>
</ul>
<h3 id="删除所有配对信息："><a href="#删除所有配对信息：" class="headerlink" title="删除所有配对信息："></a>删除所有配对信息：</h3><ul>
<li>fn+q 进入等待配对模式</li>
<li>fn+z+delete</li>
</ul>
<h3 id="删除个别配对信息："><a href="#删除个别配对信息：" class="headerlink" title="删除个别配对信息："></a>删除个别配对信息：</h3><ul>
<li>fn+q 进入等待配对模式</li>
<li>fn+ctrl+delete+1~4</li>
</ul>
<h3 id="配对中途取消配对："><a href="#配对中途取消配对：" class="headerlink" title="配对中途取消配对："></a>配对中途取消配对：</h3><ul>
<li>fn+q 进入等待配对模式</li>
<li>fn+x</li>
</ul>
<h3 id="软改切换模式（非-DIP，仅在无线状态下有效）"><a href="#软改切换模式（非-DIP，仅在无线状态下有效）" class="headerlink" title="软改切换模式（非 DIP，仅在无线状态下有效）"></a>软改切换模式（非 DIP，仅在无线状态下有效）</h3><ul>
<li>切换为 win 模式：fn+ctrl+w</li>
<li>切换为 mac 模式：fn+ctrl+m</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-in-V8</title>
    <url>/2021/12/30/Javascript-in-V8/</url>
    <content><![CDATA[<p>之前对<a class="link"   href="http://www.feidom.com/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/"  target="_blank" rel="noopener">js对象你不知道的那些特点<i class="fas fa-external-link-alt"></i></a> 有一些粗浅的认识，这个笔记写的很无理取闹。现在研究清楚以后，重新补一篇笔记来完善知识。之前的这篇就留着吧，也是学习和思考中一个必有的认知阶段。</p>
<h4 id="JS-Object-中的常规属性和排序属性"><a href="#JS-Object-中的常规属性和排序属性" class="headerlink" title="JS Object 中的常规属性和排序属性"></a>JS Object 中的常规属性和排序属性</h4><ul>
<li><p>常规属性(V8:properties)<br>在properties对象中，会按照创建时的顺序保存常规属性。</p>
</li>
<li><p>排序属性(V8:elements)<br>当key为数字时，会将这类属性存储在elements对象中，将其作为一块连续的内存以Array的形式进行存储。在elements对象中，会按照数字大小的顺序来存放排序属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'100'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'B1'</span>] = <span class="string">'B'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'50'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'3'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'A2'</span>] = <span class="string">'A'</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="string">'C'</span>] = <span class="string">'C'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ClassA();</span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;a[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">a.qwf = <span class="string">'qwf'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = <span class="string">`eeeeee_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="string">`p_<span class="subst">$&#123;i&#125;</span>`</span>] = <span class="string">`pppppp_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ClassB(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>

<p>作为两个属性，为啥在console的控制台打印的结果中没有发现呢。其实console的控制台打印的没那么深，那怎么能找到他们呢。在Memory控制台录制快照，就能很明显的看到他们。</p>
</li>
</ul>
<h4 id="V8引擎对Object做了什么残忍的事"><a href="#V8引擎对Object做了什么残忍的事" class="headerlink" title="V8引擎对Object做了什么残忍的事"></a>V8引擎对Object做了什么残忍的事</h4><ul>
<li><p>Hidden Class 隐藏类</p>
</li>
<li><p>Properties pointer 常规属性指针</p>
</li>
<li><p>Elements pointer 排序元素指针</p>
<p>为什么要这样分开呢？？？<br>首先我们需要聊一下公认最快的C语言，它的快很大程度上归功于它严格的类型约束。也就是说大型的面向对象系统都有严格的数据结构，这对快速的属性查询很关键。<br>所以，Js中的Object的定义非常差,因为它太灵活了，没有类型的概念。而且存在可以任性修改的原型链，它没有限制。<br>所以在V8对JS Object进行处理时，为了快速的属性查询，有一个内部的类型系统：对具有相同结构的对象进行分组；各个对象之间可以共享；生成的成本很高，但是之后的成本很低。</p>
</li>
</ul>
<h4 id="V8对Object做的优化"><a href="#V8对Object做的优化" class="headerlink" title="V8对Object做的优化"></a>V8对Object做的优化</h4><p>  属性内联缓存<br>  在属性查询中检查隐藏类</p>
<ol>
<li>在第一次时完全通用查询</li>
<li>然后记住你在哪个地方找到的这个属性<br>生成新的优化代码</li>
<li>下次使用，直接访问</li>
</ol>
<h4 id="Object-属性的存储"><a href="#Object-属性的存储" class="headerlink" title="Object 属性的存储"></a>Object 属性的存储</h4><ul>
<li>直接在object上，即默认状态，这个很快</li>
<li>array形式存储，也很快</li>
<li>哈希表结构（字典模式），这个的交互会慢很多<br>字典模式相比于其他模式，运行速度降低。触发字典模式的行为如下：</li>
<li>非常多的属性，他们没有办法被放在默认状态的内存中，这个数字可能是10 ？30？</li>
<li>改变属性</li>
<li>删除属性</li>
</ul>
<h4 id="JS-Array-字典模式"><a href="#JS-Array-字典模式" class="headerlink" title="JS Array 字典模式"></a>JS Array 字典模式</h4><p>  同样对比C，Js中的Array也因为没有类型约束给了用户很大的自由，也挺样带来了不可控的性能问题。<br>  连续内存的存储和hash表（字典模式）不同的存储方式，不一样的性能体验。<br>  触发字典模式的行为如下：</p>
<ol>
<li><p>非常多的属性，大于1024？ 10000？</p>
</li>
<li><p>动态扩容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>);</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'nihao'</span>;</span><br><span class="line">a[<span class="number">100</span>] = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="结合以上特点，我们应该做什么"><a href="#结合以上特点，我们应该做什么" class="headerlink" title="结合以上特点，我们应该做什么"></a>结合以上特点，我们应该做什么</h4><p>  Js给我们很高的灵活度让我们随心所欲，但是我们不应该为所欲为，自由度高，带来的就是性能的不友好。<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'100'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ClassA();</span><br><span class="line">a.qwf = <span class="string">'qwf'</span>;  <span class="comment">// 这样直接添加属性，改变了隐藏类</span></span><br></pre></td></tr></table></figure><br>  所以尽量定义好默认属性，不要在构造函数之外做大量的动态属性添加和删除，尽量共享隐藏类。</p>
<h4 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h4><p>  <a class="link"   href="https://v8.dev/"  target="_blank" rel="noopener">V8<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first type of attry to talk about in javascript is the TypedArray</span><br><span class="line"></span><br><span class="line">So TypedArrays are going to make a lot of aense to you if</span><br><span class="line">you are coming from a C background</span><br><span class="line"></span><br><span class="line">They are contiguous blocks of memory that are specified for a particylar data type.</span><br><span class="line"></span><br><span class="line">So you have Uint32Array, Float64Array, Unit8Array, and so on, and so forth, which actually, if you are familiar with Javascript,is sort of unusual. Because most things in Javascript have no type. </span><br><span class="line"></span><br><span class="line">So this idea that we are specifying a very specific size for our numbers id actually like pretty unique. And that&#39;s because the TypedArray specification grew up alongside the WebGL specification.</span><br><span class="line"></span><br><span class="line">And you can inagine how you need that level of specificity if you are doing graphics programming.</span><br><span class="line"></span><br><span class="line">So that&#39;s sort of where the TypedArray specification came from.</span><br><span class="line"></span><br><span class="line">But it&#39;s been adopted into other things now that it&#39;s there.</span><br><span class="line"></span><br><span class="line">So agein, they&#39;re memory efficient. You don&#39;t have to box them.</span><br><span class="line"></span><br><span class="line">They behave as you&#39;d expect.</span><br><span class="line"></span><br><span class="line">They&#39;re a very nice option for arrays.</span><br><span class="line"></span><br><span class="line">But if you can&#39;t use TypedArrays for whatever reason, you need to use Javascript Arrays.</span><br><span class="line"></span><br><span class="line">SO Javascript Array object --Array with a captital A-- has an API which is going to look a little weird to you if you are used to C-style arrays.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have operations that are different.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have like push and pop.</span><br><span class="line"></span><br><span class="line">It&#39;s going to allow you to index out of bounds.</span><br><span class="line"></span><br><span class="line">It&#39;s going to have just sort of odd behavior to me as somebody coming from C.</span><br><span class="line"></span><br><span class="line">So as you can imagine, because the API allows all these non-C array-like things, the backing storage in V8 is not always somethings that looks like array. There are actually two diffent types of backing storage for arrays. Thewe are sparse arrays and dense arrays, which map to either something tach looks like a C-style array. like you&#39;d expect, or a hash table. And if you array is backed by a V8 hash table, that&#39;s called being in dictionary mode, and it&#39;s considerably less efficient. It&#39;s case that you want to avoid.</span><br><span class="line"></span><br><span class="line">There are many factors in V8 that causes you to be kicked into dictionary mode or not. </span><br><span class="line"></span><br><span class="line">So it&#39;s kind of complicated to define them all. </span><br><span class="line"></span><br><span class="line">But one of them, for instance, is space efficiency.</span><br><span class="line"></span><br><span class="line">So is the codes you wrote will be three times more effcient, use three times less space if it was backed by a hash table than an array, then it&#39;ll be a hsah table on back end. So there are criteria like that. </span><br><span class="line"></span><br><span class="line">js allows you to create a new uninitialized array and then just suddenly index into it at whatever index.</span><br><span class="line"></span><br><span class="line">This, doesn&#39;t make any sense in C. It&#39;s not something you&#39;d actually do. And in V8, it will immediately trigger dictionary mode. So this, you will now have a nice, slow array to waok with, not something you want.</span><br><span class="line"></span><br><span class="line">So real simple change.</span><br><span class="line"></span><br><span class="line">All you have to do is declare how much storage you want up font.Now you have declared to V8 that you actually want an array of a certain size. V8 will back your array by a contigous array of that size, and you can go from there.</span><br><span class="line"></span><br><span class="line">Veay sensible, kind of no-brainerish, but again, Javascript allows you to do it in a way that ends up being very inefficient, so it&#39;s important to know.</span><br><span class="line"></span><br><span class="line">So that is the numeric representation and the immediate representation of objects.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">Object in V8 </span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">So objects in JavaScript are there very poorly defined things.</span><br><span class="line"></span><br><span class="line">They are associative arrays.</span><br><span class="line"></span><br><span class="line">They&#39;re just bundles of key value pairs of properties.</span><br><span class="line"></span><br><span class="line">So you have string balue for key, property value.</span><br><span class="line"></span><br><span class="line">And all property values are these undefined whatevers, because Javascript doesn&#39;t have a notion of type.</span><br><span class="line"></span><br><span class="line">Object have prototype chains. You can add and remove properties anywhere at the prototype chain and on the object inself at any point. </span><br><span class="line"></span><br><span class="line">Javascript doesn&#39;t enforce any specificity or structure in your code.</span><br><span class="line"></span><br><span class="line">So if you wanted to, you could make every single object in your whole program absolutely a unique set of properties.</span><br><span class="line"></span><br><span class="line">Nothing in Javascript will enforce structure or self-similarity.</span><br><span class="line"></span><br><span class="line">But just because JavaScript allows you to do that, you really,really shouldn&#39;t.</span><br><span class="line"></span><br><span class="line">That&#39;s actually a terrible thing to do for performance.</span><br><span class="line"></span><br><span class="line">And I&#39;ll explain why in a minute.</span><br><span class="line"></span><br><span class="line">So in V8,the V8 team looked at trying to write a large-scale application in JavaScript and thought, hey, you know what&#39;s important in large-scale systems is object-orientenness.</span><br><span class="line"></span><br><span class="line">And if you have object-orientenness in your system, then now, property access is one of the key things that you need to make fast. </span><br><span class="line"></span><br><span class="line">So V8 designed its structure to make property access on objects as efficient as it could be.</span><br><span class="line"></span><br><span class="line">So the internal representation of an object in V8 is three words.</span><br><span class="line"></span><br><span class="line">So first, we have a hidden class pointer, which is an internal notion of type, which I&#39;ll explain in a second.</span><br><span class="line"></span><br><span class="line">And then we have two pointers to different kinds of properties.</span><br><span class="line"></span><br><span class="line">We have properties that have string names and then properties that have int names. </span><br><span class="line"></span><br><span class="line">But really, the only thing that&#39;s important is your have a type, and then you have property storage.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So waht&#39;s this hidden class thing?</span><br><span class="line"></span><br><span class="line">So hidden classes, again, ther&#39;re V8&#39;s interbal notion of type.</span><br><span class="line"></span><br><span class="line">JavaScript itself isn&#39;t going to enforce any kind of notionof type on you.</span><br><span class="line"></span><br><span class="line">BUt in order to make things effcient, V8itself need to have some sort of structure in whst it things you&#39;re doing. </span><br><span class="line"></span><br><span class="line">So it introduces a type system.</span><br><span class="line"></span><br><span class="line">And that type system froups objects with the same structure.</span><br><span class="line"></span><br><span class="line">So as you&#39;re adding properties to objects, which you can do in JavaScript, V8 will be looking at the properties on each object and mapping ta&#x3D;hat bundle of properties to a hidden class, which defines an object with exactly those properties.</span><br><span class="line"></span><br><span class="line">So, dor instance, if I have this constructor in JavaScript where I have a point, and it has an x and y, and the way those values are added by first adding x to the object and then adding y, thay&#39;s going to generate a hidden class that backs objects that are created from this function that has exactle the properties x and y.</span><br><span class="line"></span><br><span class="line">And that really seems sort of obvious.</span><br><span class="line"></span><br><span class="line">But then, the first time this function is run, that hidden class is going to be built for the first time. And then, all subsequent times this dunction is run, those new objects can share the same hidden class.So you only pay the price for building it the very first time.</span><br><span class="line"></span><br><span class="line">After that, you can just use the same object.</span><br><span class="line"></span><br><span class="line">So we went through all this trouble of building up a notion of type.</span><br><span class="line"></span><br><span class="line">So now, we have types that correspond to specifically what exact </span><br><span class="line">properties are on an object.</span><br><span class="line"></span><br><span class="line">We can use taht notion of type to make property access quick using something called inline caching.</span><br><span class="line"></span><br><span class="line">So if yoiu want to look up a property on an object in Javascript, you&#39;re going to say, I am looking for property with name x on object y.</span><br><span class="line"></span><br><span class="line">The first thing you do whrn you&#39;re trying to look up a property is check the hidden class of the object.</span><br><span class="line"></span><br><span class="line">If you&#39;re never tried to look up that property on an object of that type before, then what you&#39;re going to have to do is a fully generic search for that property.</span><br><span class="line"></span><br><span class="line">So again, we just have a bundle of properties somewhere.</span><br><span class="line"></span><br><span class="line">They all have string names.</span><br><span class="line"></span><br><span class="line">You have a string of the property you&#39;re looking for.</span><br><span class="line"></span><br><span class="line">And you&#39;re going to have to look through taht list for the property that has a matching name.</span><br><span class="line"></span><br><span class="line">That&#39;s a pretty slow operation.</span><br><span class="line"></span><br><span class="line">But once you found thst property once, you can remember the offset to it. you can remember where you found that property and use it later, which means that you can use that to generate new optimized code which specifies how you look up that particular property on that particular object.</span><br><span class="line"></span><br><span class="line">And next time you want to look up property with that name on an object of that type, you can have direct access You know exactly where to go in an object of that type.</span><br><span class="line"></span><br><span class="line">And it&#39;s much much much faster.</span><br><span class="line"></span><br><span class="line">So thst&#39;s really what the notion of having hidden class is getting us, is now we can make property access really fast through inline caching.</span><br><span class="line"></span><br><span class="line">So this is a classic example of bad idea. </span><br><span class="line"></span><br><span class="line">function Vec2(x,y)&#123;</span><br><span class="line">	this.x &#x3D; x;</span><br><span class="line">	this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">var v0 &#x3D; new  Vec2(5,8);</span><br><span class="line">v0.z &#x3D; 34;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So I have another constructor. It&#39;s creating a vector object. </span><br><span class="line"></span><br><span class="line">But then, after I go through the trouble of doing that, I decide that I now wanted property z on this object.</span><br><span class="line"></span><br><span class="line">The problem with that is that if you add a property z to that object at some future point, if you just dynamically do that, you&#39;re going to change the hidden class of the object, which means that all this nice caching you&#39;re done and building up a notion of where the properties are, that&#39;s just blown away because now you have a new hidden class. </span><br><span class="line"></span><br><span class="line">You have to pay to build the new hidden class, and now you have to deal with a new hidden class.</span><br><span class="line"></span><br><span class="line">So one of the best things you can do to make you code efficient is to create a few well-defined types.</span><br><span class="line"></span><br><span class="line">Don&#39;t do alot of dynamic property adding and removing outside of constructors.</span><br><span class="line"></span><br><span class="line">Pretty much set things up once, have them look alike so that they can share the same hidden class, and don&#39;t mess with the properties they have.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">Object properties storage</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">So now we know an object has properties.</span><br><span class="line"></span><br><span class="line">those properties can be in different storage states.</span><br><span class="line"></span><br><span class="line">So the first state ,the default, is that they can be stored directly in an array on the object.</span><br><span class="line"></span><br><span class="line">that great, that&#39;s fast. that&#39;s where you want to be. </span><br><span class="line"></span><br><span class="line">A second state they can be in is being stored in array off the objects. still great. No problem.</span><br><span class="line"></span><br><span class="line">The third case, which is the one you really have to look out for, is when they&#39;re stored in a hash table.</span><br><span class="line"></span><br><span class="line">So mush like just the array case in general where arrays can have different types of backing storage, properties can have different types of backing storage too.</span><br><span class="line"></span><br><span class="line">So properties can either be in normal mode where they&#39;re stored as an array or a dictionary mode where they&#39;re stored as a hash table. </span><br><span class="line"></span><br><span class="line">And if you have an object in dictionary mode, it&#39;s going to be mush slower to interact with.</span><br><span class="line"></span><br><span class="line">So you don&#39;t want that.</span><br><span class="line"></span><br><span class="line">So what triggers dictionary mode ,and how do you avoid it? Well, one thing that triggers itis toomany properties.</span><br><span class="line"></span><br><span class="line">So if you have so many properties that they won&#39;t fit into the internal storage for properties, then you have to have a hash table elsewhere. And that number of too many properties is somewhere around 30. It&#39;s quite generous, but you mighe hit it in some cases.</span><br><span class="line"></span><br><span class="line">The other things you can do to confuse your object and kick it into dictionary mode are to change the properties on the object.</span><br><span class="line"></span><br><span class="line">You can change the attribute, you can delete properties, that kind of thing. Those things are all going to kick you straight to dictionary mode.</span><br><span class="line"></span><br><span class="line">Again, and now you&#39;re going to make your object mush slower to interact with.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js原理</category>
      </categories>
      <tags>
        <tag>js原理</tag>
      </tags>
  </entry>
  <entry>
    <title>js对象你不知道的那些特点</title>
    <url>/2021/08/09/js%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<h4 id="js对象的“快-慢”属性"><a href="#js对象的“快-慢”属性" class="headerlink" title="js对象的“快/慢”属性"></a>js对象的“快/慢”属性</h4><p>定义一个obj，它是下面这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">5</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">'2'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'6'</span>,</span><br><span class="line">  <span class="string">'qwf'</span>: <span class="string">'乔文飞'</span>,</span><br><span class="line">  <span class="string">'yy'</span>: <span class="string">'qwf'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init初始化时，属性会尽量归为“快”属性，同时也会存在“慢”属性。<br>那么它在js中，为了有效的提升存储和访问属性的性能，js对慢属性的存储是下图这样的。<br><img src="http://i.feidom.com/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png" alt="对象属性"></p>
<ul>
<li>快属性：直接加在对象内属性上，方便读取。</li>
<li>慢属性：加载排序或常规属性上，方便操作。（在对象设置属性时，会加到慢属性）</li>
</ul>
<p>Q：为啥慢？<br>A：多了一层深度，影响数据操作，多了Element层和Properties层。</p>
<p>Q：为啥不直接都存在内属性上？<br>A：在内属性中，obj越来越大，影响存储。（以前内属性只能动态设置10个，现在不止-硬件加强等原因）</p>
<h4 id="js数组的“快-慢”数组"><a href="#js数组的“快-慢”数组" class="headerlink" title="js数组的“快/慢”数组"></a>js数组的“快/慢”数组</h4><ul>
<li>快数组：线性结构，连续内存（动态扩容），当定义初始化长度小于1024时，属于快数组</li>
<li>慢数组：定义长度大于1024时，需要维护额外的哈希米表。</li>
</ul>
<p>由快到慢：</p>
<ol>
<li>定义长度大于1024时。动态扩容时，length*1.5+16以上。</li>
<li>快数组的新容量时扩容容量的3倍以上时。</li>
</ol>
<p>由慢到快：</p>
<ol>
<li>数量在1024内</li>
<li>容量一下缩减50%。<br>减容时，新数组长度是原来长度的1/2，就计算需要释放的空间，做好标记，等待GC回收。<br>如果1/2 &lt; length &lt; 1,用holes对象填充，holes太多也是慢数组。</li>
</ol>
]]></content>
      <categories>
        <category>js原理</category>
      </categories>
      <tags>
        <tag>js原理</tag>
      </tags>
  </entry>
  <entry>
    <title>js上下文执行机制</title>
    <url>/2021/08/09/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><ul>
<li>ECS(Execute Context Stack): js函数执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。</li>
<li>GC(Global Context): 全局上下文。</li>
<li>GO(Global Context): 全局上下文生成的对象。</li>
<li>VO(Var Object): 声明时对象。</li>
<li>AO(Action Object): 执行时对象。</li>
</ul>
<p><img src="http://i.feidom.com/%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="看下这张图"></p>
<p>在AO执行时，分为两个阶段：</p>
<ul>
<li>变量定义：AO的准备阶段，es6之前的<strong>变量提升</strong>就在这个阶段</li>
<li>变量赋值。</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">GC:&#123;</span><br><span class="line">  lexicalEnvironment: &#123; <span class="comment">// 词法环境</span></span><br><span class="line">    EnvironmentRecord: &#123; <span class="comment">// 环境记录</span></span><br><span class="line">      Type: <span class="string">"Object"</span>,</span><br><span class="line">      &#123;...&#125;, <span class="comment">// 标识符什么的其他信息</span></span><br><span class="line">      outer: <span class="literal">null</span>, <span class="comment">// 全局上下文没有引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  variablesEnvironment:&#123; <span class="comment">// 变量环境</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行上下文 Function Exection Context</span></span><br><span class="line">EC:&#123;</span><br><span class="line">  lexicalEnvironment: &#123; <span class="comment">// 词法环境</span></span><br><span class="line">    EnvironmentRecord: &#123; <span class="comment">// 环境记录</span></span><br><span class="line">      Type: <span class="string">"Declarative"</span>, <span class="comment">//函数环境</span></span><br><span class="line">      &#123;...&#125;, <span class="comment">// 标识符什么的其他信息</span></span><br><span class="line">      outer: <span class="string">'&lt;Global outer&gt;, &lt;function enviroment reference&gt;,'</span>, <span class="comment">// 对全局环境或外部函数环境的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  variablesEnvironment:&#123; <span class="comment">// 变量环境</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了适配早起的ES5的var等，增加了变量环境。变量环境也是一个词法环境，其环境记录其包含了由变量声明语句。<br>在ES6中，词法环境记录器和变量环境记录器的区别在于：</p>
<ul>
<li>词法环境：用于存储函数声明和变量（let，const）的绑定。</li>
<li>变量环境：仅用于存储变量（var）的绑定</li>
</ul>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul>
<li>scope chain：作用域链<br>其实就是在 [AO,GC,VO] 时。</li>
<li><em>闭包原理*</em> 在作用域scope堆空间中存储closore(fn)。</li>
</ul>
]]></content>
      <categories>
        <category>js原理</category>
      </categories>
      <tags>
        <tag>js原理</tag>
      </tags>
  </entry>
  <entry>
    <title>OT在线协作</title>
    <url>/2021/08/05/ot%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="OT协作思想"><a href="#OT协作思想" class="headerlink" title="OT协作思想"></a>OT协作思想</h4><p><strong>解决冲突</strong></p>
<p>A, B两个用户在协作同一段初始文本：’aaab’。<br>冲突操作：<br>  A在第3个字符后面插入了一个<code>c</code>(‘aaacb’)。<br>  B在第3个字符后面插入了一个<code>d</code>(‘aaadb’)。</p>
<p>若A先提交，ot后正确结果：’aaacdb’。<br>？为什么不是按顺序的’aaadcb’。因为不是顺序执行，产生冲突时，为保证双方操作最大程度得到保存，ot协作后，B的操作实际变为在第4个子都后插入。<br>A视角：A的结果’aaacb’被B拿去操作，结果’aaadcb’。<br>B视角：B的结果’aaadb’被A拿去操作，结果’aaacdb’。可见这个结果是正确结果。</p>
<p>后台聪明的ot转发功能就是把每个人提交的行为转变一下再告诉别人，两方的结果就一致了。其实这个技术就是 OT 算法：<br>A接收到的B操作：’在第3个字符后面插入了一个<code>d</code>‘  ==ot==&gt; ‘aaacb在第4个字符后面插入了一个<code>d</code>‘(aaacdb)<br>B接收到的A操作：’在第3个字符后面插入了一个<code>c</code>‘  ==ot==&gt; ‘aaadb在第3个字符后面插入了一个<code>c</code>‘(aaacdb)</p>
<p>OT 算法全名叫 Operation Transformation，你看从名字就对应了上面我说的转变算法。<br>假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A’,B’。<br>也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A’行为告诉 B，把 B’行为告诉 A，这样大家再应用就相安无事了。</p>
<p>核心公式：apply(apply(S,A),B) = apply(apply(S,B),A)<br>S:开始状态<br>A：A的操作A<br>B：B的操作B<br>冲突时，A执行完自己的操作后，再执行经OT转换的B操作。与B执行完自己的操作，再执行经OT转换的A操作，双方的结果是一致的。<br>图示：<br><img src="http://www.alloyteam.com/wp-content/uploads/2019/07/0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png" alt="ot"></p>
<p><a class="link"   href="http://operational-transformation.github.io/"  target="_blank" rel="noopener">一个演示OT的小网站<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>参考:<a class="link"   href="http://www.alloyteam.com/2019/07/13659/"  target="_blank" rel="noopener">揭开在线协作的神秘面纱-OT算法<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>OT</tag>
      </tags>
  </entry>
  <entry>
    <title>从props的children中获取ref</title>
    <url>/2021/07/12/%E4%BB%8Eprops%E7%9A%84children%E4%B8%AD%E8%8E%B7%E5%8F%96ref/</url>
    <content><![CDATA[<h4 id="从props-children中处理ref"><a href="#从props-children中处理ref" class="headerlink" title="从props.children中处理ref"></a>从<code>props.children</code>中处理ref</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetRef</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ref);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> childElement = React.Children.only(<span class="keyword">this</span>.props.children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">      childElement, </span><br><span class="line">      &#123; <span class="attr">ref</span>: <span class="function"><span class="params">el</span> =&gt;</span> <span class="keyword">this</span>.ref = el &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GetRef</span>&gt;</span><span class="tag">&lt;<span class="name">Child</span>/&gt;</span><span class="tag">&lt;/<span class="name">GetRef</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合转发ref将ref绑定到children组件中的div中"><a href="#结合转发ref将ref绑定到children组件中的div中" class="headerlink" title="结合转发ref将ref绑定到children组件中的div中"></a>结合转发ref将ref绑定到children组件中的div中</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Com组件</span></span><br><span class="line">interface Props &#123;</span><br><span class="line">  forwardedRef: ref | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;forwardedRef&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div ref=&#123;forwardedRef&#125;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">  &#125; </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const forwardRefCom =  React.forwardRef((props, ref) =&gt; (</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Com</span> <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">  ));</span></span><br><span class="line"><span class="xml">return forwardRefCom;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react的转发ref</title>
    <url>/2021/07/12/react%E7%9A%84%E8%BD%AC%E5%8F%91ref/</url>
    <content><![CDATA[<h4 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h4><p>使用通用的高阶组件时，外层组件ref控制高阶组件中包裹的子组件中的元素，此时外层组件传入的ref并不作用于高阶上，这个时候，高阶组件就要用到<code>React.forwardRef</code>进行ref转发。</p>
<h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a class="link"   href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"  target="_blank" rel="noopener">React.forwardRef<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="简单举栗🌰"><a href="#简单举栗🌰" class="headerlink" title="简单举栗🌰"></a>简单举栗🌰</h4><p>🌰栗子 来自<a class="link"   href="https://www.jianshu.com/p/ea89610dbbfd"  target="_blank" rel="noopener">JamesSawyer—-React 中的转发ref<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'先前的属性：'</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'当前属性：'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 使用forwardedRef作为一个ref属性传入组件中</span></span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用React.forwardRef对LogProps组件进行转发</span></span><br><span class="line">  <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    &#123;<span class="string">' 上面定义的LogProps组件接受一个forwarded属性 '</span>&#125;</span><br><span class="line">    &lt;LogProps forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FancyButton.js 子组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> logProps <span class="keyword">from</span> <span class="string">'./logProps'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受props和ref作为参数</span></span><br><span class="line"><span class="comment">// 返回一个React 组件</span></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"fancybutton"</span> ref=&#123;ref&#125;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用高阶组件对其进行封装</span></span><br><span class="line"><span class="regexp">export default logProps(FancyButton);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父组件</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ app.js</span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 创建一个ref 名字随意</span></span><br><span class="line"><span class="regexp">    this.ref = React.createRef();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('ref', this.ref);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ this.ref.current 表示获取ref指向的DOM元素</span></span><br><span class="line"><span class="regexp">    this.ref.current.classList.add('primary'); /</span><span class="regexp">/ 给FancyButton中的button添加一个class</span></span><br><span class="line"><span class="regexp">    this.ref.current.focus(); /</span><span class="regexp">/ focus到button元素上</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 直接使用ref=&#123;this.fancyButtonRef&#125;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;FancyButton ref=&#123;this.fancyButtonRef&#125;&gt;子组件&lt;/</span>FancyButton&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React-防止内存泄漏处理</title>
    <url>/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>用React写了一段代码，浏览器的控制台<font color=red size=5>Error </font>如下：<br><font color=red>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</font></p>
<p>啥意思呢：不能在未挂载的组件上执行React状态更新。这是一个无用功，但它表明你的应用程序中存在内存泄漏。要解决这个问题，在useEffect清理函数中取消所有的订阅和异步任务。</p>
<p>以下是这段问题代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; itemId &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [ isRemoveing, setIsRemoveing ] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> handlerRemove = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(isRemoveing) <span class="keyword">return</span>;</span><br><span class="line">    setIsRemoveing(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">await</span> removeItem(itemId); <span class="comment">// 删除当前这个组件的数据，这个组件卸载</span></span><br><span class="line">    setIsRemoveing(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div class_name=&#123; !isRemoveing ? <span class="string">'class1'</span> : <span class="string">'class2'</span> &#125; onClick=&#123;handlerRemove&#125; &gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因是啥呢</strong>：await等待一个异步请求的返回再<code>setIsRemoveing</code>。假如这个组件unmounted之后，请求还没回来，你还在这setState，不就炸了。</p>
<p>好吧，那解决方式是不是在<code>useEffect</code>中定义一个卸载时的变量<code>unmounted</code>，然后在setIsRemoveing时判断卸载状态？</p>
<p>嗯，基本是这个思路。那这个<code>unmounted</code>该怎么定义，是直接<code>const unmounted = false;</code>, 还是<code>const [ unmounted, setUnmounted ] = useState(false);</code>？<br>以下是Stack Overflow里一个帖子的回复：</p>
<ul>
<li>方式一：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> unmounted = <span class="literal">false</span>;</span><br><span class="line">  setPageLoading(<span class="literal">true</span>);</span><br><span class="line">  props</span><br><span class="line">    .dispatch(fetchCourses())</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        toast.error(error);</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted = <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li>
<li>方式二：useRef<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> unmounted = useRef(<span class="literal">false</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted.current = <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setFilter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    props.dispatch(fetchCourses()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted.current) &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ReactTable onFetchData=&#123;setFilter&#125; <span class="comment">/* other props omitted */</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>方式二中如果不用ref，用state或者直接定义变量的话，都实现不了。<br>好吧，是我不熟悉的<a class="link"   href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref"  target="_blank" rel="noopener">useRef<i class="fas fa-external-link-alt"></i></a>,这个链接是官方文档，可以先看下。<br>然后为了研究它，我找到一篇来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<a href="/2021/06/18/useEffect-useRef/">这里</a>是我对这篇文章的翻译，仅供参考。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a class="link"   href="https://daviseford.com/blog/2019/07/11/react-hooks-check-if-mounted.html"  target="_blank" rel="noopener">React Hooks - Check If A Component Is Mounted<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/58038008/how-to-stop-memory-leak-in-useeffect-hook-react/58038029"  target="_blank" rel="noopener">how-to-stop-memory-leak-in-useeffect-hook-react<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>useEffect &amp; useRef</title>
    <url>/2021/06/18/useEffect-useRef/</url>
    <content><![CDATA[<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>本文是一片翻译，原文来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<br>为啥翻译并记录这篇文章呢，因为看了以后觉得通俗易懂的为凡人解释了<code>useEffect</code>和<code>useRef</code>。<br>在此记录，方便以后回头复习。</p>
<h4 id="通俗的解释React的-useEffect-和-useRef"><a href="#通俗的解释React的-useEffect-和-useRef" class="headerlink" title="通俗的解释React的 useEffect 和 useRef"></a>通俗的解释React的 useEffect 和 useRef</h4><p><img src="https://leewarrick.com/blog/static/fdb92914fc9093dee6a2c20dad8fbd50/c35de/acropolis.jpg" alt="原文中过的图"><br>&emsp;&emsp;如果React文档让你一筹莫展，或者Dan Abramov的博客让你觉得你在阅读从奥林匹斯山流传下来的古希腊文卷轴，你并不孤单,不是只有你这样认为。<br>&emsp;&emsp;有时，React神殿的众神们很难将他们的智慧转化为我们其他人可以理解的语言。事情通常是这样的。你在使用React时遇到困难，用谷歌搜索你的问题，然后读到一个博客或Stack Overflow的帖子，其中的一些建议让你感到比开始时更迷茫。<br>&emsp;&emsp;我当然也曾多次成为这种情况的受害者。特别是useEffect。在我们深入研究这个特殊的钩子之前，让我说我喜欢用hooks来写React，而且不想再回到类中去。这就是说，useEffect是一个很大的痛点。</p>
<h6 id="到底什么是“effect副作用”"><a href="#到底什么是“effect副作用”" class="headerlink" title="到底什么是“effect副作用”"></a>到底什么是“effect副作用”</h6><p>&emsp;&emsp;为了让你真正理解useEffect，让我们退后一点，谈谈编程和JavaScript。<br>&emsp;&emsp;useEffect的名字就是我们亲切地称为 “副作用 “的效果。<br>&emsp;&emsp;那么什么是副作用呢？它是一段代码，它伸出手来……做别的事情。这是一个抽象的概念，所以让我们用例子来说明。<br>&emsp;&emsp;这里有一个没有副作用的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数add除了接受一个输入并返回一个输出外，什么也没做。它并没有伸手到自身以外的地方去捣乱!<br>&emsp;&emsp;我们来介绍一个副作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="built_in">document</span>.getElementById(<span class="string">'add-example'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = a + b</span><br><span class="line">  resultDiv.textContent = <span class="string">`The Result is <span class="subst">$&#123;result&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;add-example&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在，我们的函数伸到了自身之外来更新DOM（Document Object Model的缩写），并显示了结果。这个额外的行为是一个副作用。</p>
<h6 id="React中的副作用"><a href="#React中的副作用" class="headerlink" title="React中的副作用"></a>React中的副作用</h6><p>&emsp;&emsp;那么React呢？它是一个几乎只更新DOM的库。一个视图库，如果你愿意的话。那么在React中，你会把什么叫做副作用呢？<br>&emsp;&emsp;任何在更新页面之外的东西。如果你不使用React来更新状态或渲染HTML，那就是一个副作用。它是任何非React的东西。<br>&emsp;&emsp;这意味着任何时候你调用API，使用setInterval/setTimeout，添加键盘监听器，或者真的任何时候你搞乱窗口对象，你都在引入副作用。<br>&emsp;&emsp;hooks很神奇，让你写出真正可读、可重用的代码……除了当你处理副作用的时候。这很不幸，因为当你仔细想想，作为网络开发者，我们所做的大多数有趣的事情都是围绕着副作用展开的。<br>&emsp;&emsp;让我们从钩子上退一步，看看我们如何在基于类的组件中处理副作用。</p>
<h6 id="类组件和副作用"><a href="#类组件和副作用" class="headerlink" title="类组件和副作用"></a>类组件和副作用</h6><p>&emsp;&emsp;在基于类的组件中，我们会使用生命周期方法来执行侧面效果。例如，在componentDidMount上，我们会调用API来获取渲染的数据。<br>&emsp;&emsp;”为什么不在构造函数中调用API？”你可能会问。好吧，因为React说我们用于渲染的东西都在 “状态 “中，在我们的组件被加载到页面上之前，我们不能乱用状态。如果我们试图在组件加载之前更新状态，就会出现错误。<br>&emsp;&emsp;下面是一个典型的基于类的组件的情况,这是一个小精灵的例子（后面会用hooks改写）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> pokemon = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &#123; pokemon</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">          &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">            Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        : <span class="string">'Loading...'</span></span><br><span class="line">      &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样做很好，除了不这样做的时候。当我们想再次点击API来抓取不同的小精灵时会发生什么？如果这个组件被连接到我们的应用程序中的某个路由上，而这个路由发生了变化，但这个组件并没有卸载/重装。如果用户进入了不同的页面，而组件在API调用结束前就卸载了怎么办？<br>&emsp;&emsp;答案是增加更多的生命周期方法，如<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以执行更多的API调用，防止奇怪的卸载错误。所以我们添加了这些生命周期方法来处理我们所有的边缘情况。当我们完成后，我们发现我们的大部分组件都是由生命周期代码组成的。</p>
<h5 id="然后来试一下Hooks"><a href="#然后来试一下Hooks" class="headerlink" title="然后来试一下Hooks"></a>然后来试一下Hooks</h5><p>&emsp;&emsp;React团队意识到，类的API有点笨重，难以推理。人们正在制作生命周期流程图，试图了解React的内部运作……这是一个混乱。<br>&emsp;&emsp;因此，在2018年10月的ReactConf上，在Sophie Alpert概述了类的使用有多么糟糕之后，Dan Abramov上台介绍了钩子（你可以在这里观看视频）。<br>&emsp;&emsp;钩子在功能组件中引入了状态性，以及处理副作用的新方法。钩子使React的代码更容易重复使用，而且代码量更少–这是一个巨大的胜利！但是有一个小问题。<br>&emsp;&emsp;除了一个小问题。<strong>每次渲染，整个组件/功能都要重新运行</strong>。<br>&emsp;&emsp;让我们看一个基于Hooks开发的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RerenderExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [bool, setBool] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> randomNum = <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;This number will be different each time you click the button:&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setBool(!bool)&#125;&gt;Trigger a render&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在渲染的JSX中甚至没有使用bool，但每次状态改变时，整个函数都会运行。每次渲染，组件内的所有东西都会重新运行：函数定义、变量创建/分配等等。<br>&emsp;&emsp;如果你在想 “如果我必须在组件中做一些计算量大的事情怎么办？这不可能是高性能的……”，这是个敏锐的观察。在一个功能性组件中进行昂贵的操作是不可能有性能的。事实上，useCallback和useMemo的存在正是为了解决这个问题而设置的避难所。Kent C Dodds在这里对这些问题有一个挑战性的解读，但总结起来，根据Kent的说法，在你看到性能影响之前，你不应该担心重读的问题。</p>
<blockquote>
<p>注意：如果你对钩子不熟悉，请把这篇文章收藏起来，等你准备好了再来看看。除非你必须要担心记忆化的问题<br>&emsp;&emsp;像useState这样的钩子采用了一些内在的魔法来避免重现的问题。这很好，而且使用useState似乎很简单，但是<strong>当你需要做设置状态以外的事情时，怎么办？</strong><br>&emsp;&emsp;使用useEffect。那些讨厌的生命周期方法没有了，万岁！然而，这个钩子也有它自己的奇怪之处。首先让我们来看看语法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//accepts two arguments: a function, and dependency array</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; <span class="comment">//function to undo our stuff from above when component unmounts</span></span><br><span class="line">&#125;, []) <span class="comment">//dependency array of things to watch for changes on</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以你给useEffect传递一个要运行的回调函数，其中包含你的副作用，然后是一个要观察的事物的数组。如果被监视的事物发生变化，useEffect将重新运行我们的回调函数。如果你需要在卸载时清理你的副作用，返回一个包含该代码的函数。<br>&emsp;&emsp;让我们看看我们的小精灵的例子，用钩子和useEffect。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, []) <span class="comment">// empty array means nothing to watch, so run once and no more</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果你盯着那个空的依赖性数组，你已经注意到了第一个useEffect的怪癖。通过传递一个空数组，我们在说 “只做这一次”。React万神殿告诉我们，在极少数情况下这是可以的，但大多数时候你都希望里面有东西。原因是，通常你想与你的代码中的东西同步，而不是只执行一次效果。例如，如果我们的小精灵组件依赖于一个路由参数或道具，任何可以说 “去获得一个新的小精灵 “而不需要挂载/卸载的东西呢？<br>&emsp;&emsp;比方说，我们的组件依赖于一个道具pokemonToGet，它是一个参数，告诉它要从API中获得哪些小精灵。让我们也为测试目的添加一个小小的表单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params">&#123;pokemonToGet&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">`https://pokeapi.co/api/v2/pokemon/<span class="subst">$&#123;pokemonToGet&#125;</span>/`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [pokemonToGet]) <span class="comment">// get a new pokemon with the pokemonToGet prop changes</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">          alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function PokemonForm() &#123;</span></span><br><span class="line"><span class="regexp">  const [inputValue, setInputValue] = React.useState("rowlet")</span></span><br><span class="line"><span class="regexp">  const [pokemonToGet, setPokemonToGet] = React.useState("gengar")</span></span><br><span class="line"><span class="regexp">  function getPokemon() &#123;</span></span><br><span class="line"><span class="regexp">    setPokemonToGet(inputValue.trim().toLowerCase())</span></span><br><span class="line"><span class="regexp">    setInputValue("")</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input onChange=&#123;(e) =&gt; setInputValue(e.target.value)&#125;</span></span><br><span class="line"><span class="regexp">        value=&#123;inputValue&#125; type="text"/</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;getPokemon&#125;&gt;</span><br><span class="line">        Get Pokemon</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Pokemon pokemonToGet=&#123;pokemonToGet&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">render(&lt;PokemonForm /</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;很好，现在我们的组件根据我们的道具变化获取了一个新的小精灵。如果使用类，我们就必须使用<code>componentDidUpdate</code>之类的东西来达到类似的效果。<br>&emsp;&emsp;Ryan Florence在推特上对useEffect的用法做了很好的总结。</p>
<blockquote>
<p>The question is not “when does this effect run” the question is “with which state does this effect synchronize with”<br>  useEffect(fn) // all state<br>  useEffect(fn, []) // no state<br>  useEffect(fn, [these, states])</p>
</blockquote>
<p>&emsp;&emsp;他提到的 “所有状态 “的情况，即你没有传入任何依赖关系的情况是一个奇怪的情况。我个人从未发现它的用途。我们知道整个组件在每次渲染时都会运行，所以我想知道是否有一些奇怪的边缘情况需要你使用<code>useEffect(fn)</code>而不使用任何依赖阵列。在任何情况下，大多数时候你都会用这个方法：<code>useEffect(fn, [these, states])</code>。</p>
<h5 id="UseEffect和Previous-State-事情败露的地方。"><a href="#UseEffect和Previous-State-事情败露的地方。" class="headerlink" title="UseEffect和Previous State: 事情败露的地方。"></a>UseEffect和Previous State: 事情败露的地方。</h5><p>&emsp;&emsp;到目前为止，useEffect的心理模型似乎很简单：将它与你选择的某些状态变化同步。问题是，当你需要在一个效果中引用该状态，而不仅仅是知道它是否发生了变化。<br>&emsp;&emsp;在useEffect中，你无法获得对当前状态的访问。<br>&emsp;&emsp;在我们的API调用例子中，我们没有看到这一点，因为我们只是覆盖了之前的状态。<br>&emsp;&emsp;让我们看一个简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;似乎我们做了所有正确的事情（甚至清理了卸载时的副作用），但我们的计数器没有递增。这是一个问题吗？我们是否无法访问setInterval所属的窗口对象？<br>&emsp;&emsp;不是，也不是。如果你把console.log添加到那个间隔中，你会看到它每秒钟都在跳动。<br>&emsp;&emsp;我可以证明给你看:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [randomNum, setRandomNum] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">      setRandomNum(<span class="built_in">Math</span>.random())</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;RandomNum is &#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意，我们每秒钟都会得到一个新的随机数。我们的时间间隔代码是好的。<br>&emsp;&emsp;我们能够设置新的状态，但无法访问当前状态。<br>&emsp;&emsp;这就是一个 “陈旧的闭包”。我不会去讨论闭包，但只需知道，由于React/hooks的实现，在我们的间隔函数中，count变量总是会是0。这是一个旧的参考。<br>&emsp;&emsp;事实证明，像上面这样的简单例子有一个解决方案，正如John Tucker所指出的（谢谢John！）。和基于类的组件中的setState一样，useState也可以接受一个回调函数，接收之前的状态作为一个参数。React文档也注意到了这一点。<br>&emsp;&emsp;下面是一个快速修复的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//let's pass a function instead</span></span><br><span class="line">      <span class="comment">//the argument is the current state</span></span><br><span class="line">      setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不过，这仍然不能解决我们所有的问题。如果你需要在useEffect中访问最新的状态，但不更新它，你将不得不开始用setState回调来包装你的useEffect代码，然后在最后返回未改变的状态。这很快就会变成一个绝对的混乱，特别是当你在处理多个状态值的时候。<br>&emsp;&emsp;另一个可能的解决方案是只使用useReducer，因为它可以接收之前的状态，但是用副作用填充你的reducer也显得非常混乱，而且我不建议任何人完全停止使用useState。<br>&emsp;&emsp;无论如何，在写钩子的时候，我已经陷入了陈旧的闭包陷阱很多很多次。我甚至不知道它有个名字，直到我在Svelte背后的人Rich Harris的演讲中看到它<br>&emsp;&emsp;显然，我也不是唯一一个在钩子上被它们绊倒的人。<br><img src="https://leewarrick.com/blog/static/5a5dbcc6667a5da9eeabc5cbe90a1427/ed46b/staleclosures.png" alt="Rich Harris的"><br>&emsp;&emsp; <strong>React甚至在他们的文档中提到了这一点。</strong></p>
<blockquote>
<p>“Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in.”<br>  译：组件内的任何功能，包括事件处理程序和效果，都能 “看到 “它所创建的渲染中的道具和状态。<br>&emsp;&emsp;我之前读过这个，在真正深入了解这个问题之前，我觉得没什么意义。我想象这可能是React的一个不好的点，所以也许他们不希望太大声地叫出来。<br>&emsp;&emsp;然而，Dan Abramov在他的博客中更好地描述了这个问题，甚至提供了一个解决方案。<br>“Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref.”<br>  译：效果总是 “看到 “它们所定义的渲染中的道具和状态。这有助于防止bug，但在某些情况下会很烦人。对于这些情况，你可以明确地在一个可变的上下文中保存一些值。</p>
</blockquote>
<p>&emsp;&emsp;这很有帮助，因为它以useRef的形式提供了一个解决方案（感谢Dan！），但它让我对如何帮助避免这个问题一无所知（主要是因为我不了解useRef）。</p>
<h5 id="什么是“ref”，你会怎么使用它"><a href="#什么是“ref”，你会怎么使用它" class="headerlink" title="什么是“ref”，你会怎么使用它"></a>什么是“ref”，你会怎么使用它</h5><p>&emsp;&emsp;传统上，引用的目的是让你直接访问一个html元素。例如，假设你需要关注一个输入字段。你必须跳出React，使用常规的JavaScript来调用.focus()。钩子实际上让这一切变得相当简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = React.useRef()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;</span><br><span class="line">        Click to Focus the input</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;很好! 当我们需要的时候，Refs是访问本地DOM APIs的一个简单的逃生通道。<br>&emsp;&emsp;…但这如何帮助我们解决我们陈旧的关闭计数器的例子呢？</p>
<h5 id="使用“Refs”来避免陈旧的闭包"><a href="#使用“Refs”来避免陈旧的闭包" class="headerlink" title="使用“Refs”来避免陈旧的闭包"></a>使用“Refs”来避免陈旧的闭包</h5><p>&emsp;&emsp;React文档将“Refs”比作 “实例变量”。我不知道那是什么意思（谢谢维基百科），所以我觉得那没什么用。<br>&emsp;&emsp;我设法通过这样思考来理解Refs的含义。<br>&emsp;&emsp;<strong>Refs存在于重新渲染周期之外。</strong><br>&emsp;&emsp;<strong>把Refs看作是你设置在一边的一个变量。当你的组件重新运行时，它会很高兴地跳过这个反射，直到你用<code>.current</code>调用它。</strong><br>&emsp;&emsp;让我们看看对我们的定时器例子的修正。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我们想把计时器停在比如说10的位置，我们可以很容易地用refs来做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (countRef.current === <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId)</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了便于比较，这里是使用setState回调方法的替代方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count === <span class="number">10</span>) &#123;</span><br><span class="line">            clearInterval(intervalId)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到这很快就会接近回调地狱，所以如果你在做更复杂的事情，我会提醒你不要使用回调方法。</p>
<h5 id="State-Versus-Refs"><a href="#State-Versus-Refs" class="headerlink" title="State Versus Refs"></a>State Versus Refs</h5><p>&emsp;&emsp;是否有可能完全抛弃状态而只使用refs？<br>&emsp;&emsp;你可能倾向于认为你可以用 refs 来代替你的组件的状态，从而避开所有这些奇怪的行为。<br>&emsp;&emsp;你不能这样做。refs不是反应性的。当你改变一个 ref 时，它不会导致重新渲染。记住，<strong>它们存在于重新渲染周期之外</strong>。<br>&emsp;&emsp;以下是不可能的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      count.current = count.current + <span class="number">1</span></span><br><span class="line">      <span class="comment">//console.log('Ref example count: ' + count.current)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count.current&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那个组件实际上是在内部进行计数，但它并没有导致HTML的更新。你需要useState来实现这一点。如果你不相信我的话，请继续取消对console.log的注释）。<br>&emsp;&emsp;这里有一个例子来证明Refs与state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;State Count: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment State Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;p&gt;Ref Count: &#123;countRef.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; countRef.current = countRef.current + 1&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment Ref Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(&lt;Counter/</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在你通过设置状态触发重新渲染之前，你不会看到Ref计数的变化。</p>
<h5 id="离别感言"><a href="#离别感言" class="headerlink" title="离别感言"></a>离别感言</h5><p>&emsp;&emsp;我喜欢React中的钩子和功能组件，但我所概述的怪异现象让我暂停了。我不喜欢被要求对React的内部工作了解这么多才能使用它。我认为这给学习React的人带来了障碍，我希望将来React团队能想出一些更好的方法来处理这些问题。</p>
<h4 id="翻译结束"><a href="#翻译结束" class="headerlink" title="翻译结束"></a>翻译结束</h4><p>很棒的文章。</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Touch和Mouse事件</title>
    <url>/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h4><p>移动端的一个页面，猜测哈，hover事件&amp;mouseover事件都被监听时，mouse应该失效吧。因为移动端只有点触，没有mouse。<br>事实：出现mouseover（定义了这个时候的样式）状态，就很奇怪。<br>然后，本以为mouse和touch在浏览器中是这样的：</p>
<ul>
<li>pc端：mouse事件生效，touch事件<del>失效</del></li>
<li>移动端：mouse事件<del>失效</del>，touch事件生效</li>
<li><strong>但是</strong>，结果是这样的：<br>同时监听了mouse和touch两种事件，在ios移动设备中的safari浏览器中，点击触发touch事件之后，定义的mouseover事件也触发了，产生了bug。</li>
</ul>
<h4 id="研究它"><a href="#研究它" class="headerlink" title="研究它"></a>研究它</h4><p>敲黑板：</p>
<ul>
<li>pc端：onTouch事件会被屏蔽。</li>
<li>移动端：两种事件都会被触发。且顺序是这样的：<ol>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
<li>mouseover</li>
<li>mousemove</li>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
</ol>
</li>
</ul>
<p>好吧，这是这一切出现的原因。<br>在适配多种设备的项目中，怎么区分这两种事件，让mouse事件在移动端失效呢。</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li>设置一个flag，mouse事件时判断touchFlag决定return或者执行。</li>
<li>分开写，判断设备后需要mouse的写mouse，需要touch的写touch。</li>
<li>最好的方法：preventDefault()<blockquote>
<p><strong>Use preventDefault() inside touch event handlers, so the default mouse-emulation handling doesn’t occur.</strong></p>
</blockquote>
</li>
</ul>
<h4 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault()"></a>preventDefault()</h4><p>专门挑出来说一下这个：preventDefault()【该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。】<br>于是，在<code>touchstart</code>方法中使用<code>e.preventDefault()</code>去阻止之后的mouseover事件。<br><font color='red'>报错了</font>：Unable to preventDefault inside passive event listener due to target being treated as passive.</p>
<blockquote>
<p>翻译： 由于目标被视为被动，无法在被动事件监听器内防止。</p>
</blockquote>
<h5 id="passive-的事件监听器"><a href="#passive-的事件监听器" class="headerlink" title="passive 的事件监听器"></a>passive 的事件监听器</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEventListener(type, listener, &#123;</span><br><span class="line">    capture: <span class="literal">false</span>,</span><br><span class="line">    passive: <span class="literal">true</span>,</span><br><span class="line">    once: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>三个属性都是布尔类型的开关。其中 capture 属性等价于以前的 useCapture 参数；once 属性就是表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它；passive 属性在 Firefox 和 Chrome 已经实现。<br>很多移动端的页面都会监听 touchstart 等 touch 事件，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ... <span class="comment">// 浏览器不知道这里会不会有 e.preventDefault()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。</p>
<p>Passive Event Listeners：就是告诉前页面内的事件监听器内部是否会调用<code>preventDefault</code>函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，代表该监听器内部不会调用<code>preventDefault</code>函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性当前仅支持mousewheel/touch相关事件。</p>
<p><strong>耗时是什么</strong><br>当用户在移动设备上点击网页中的某个元素时，没有为移动交互设计的网页在触摸开始事件和处理鼠标事件（mousedown）之间至少有300毫秒的延迟。如果你有触摸设备，你可以看看这个例子。或者，使用Chrome浏览器，你可以在Chrome开发者工具中打开 “模拟触摸事件”，以帮助你在非触摸系统上测试触摸界面!</p>
<p>这个延迟是为了让浏览器有时间判断用户是否在做其他手势–特别是双击缩放。很明显，在你想对手指触摸做出即时反应的情况下，这可能是个问题。目前正在进行的工作是试图限制这种延迟自动发生的情况。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Chrome for Android</th>
<th align="left">Android Browser</th>
<th align="left">Opera Mobile for Android</th>
<th align="left">Firefox for Android</th>
<th align="left">Safari iOS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Non-scalable viewport</td>
<td align="left">No delay</td>
<td align="left">300ms</td>
<td align="left">300ms</td>
<td align="left">No delay</td>
<td align="left">300ms</td>
</tr>
<tr>
<td align="left">No Viewport</td>
<td align="left">300ms</td>
<td align="left">300ms</td>
<td align="left">300ms</td>
<td align="left">300ms</td>
<td align="left">300ms</td>
</tr>
</tbody></table>
<p>避免这种问题的一个简单方法，就是直接告诉浏览器，我这个页面不需要滚动：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt;</code>，一般在移动端这样写可以。</p>
<p><strong>综上</strong>：<br>  事件监听时，设置第三个参数中：passive为false，告诉浏览器我要自己控制<code>preventDefault</code>函数来阻止事件的默认行为。</p>
<p><strong>如下</strong>：<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private onTouchStart(e:MouseEvent) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onTouchStart'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">private onMouseOver(e:MouseEvent) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onMouseOver'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.touchElement) &#123;</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.onTouchStart, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'mouseover'</span>, <span class="keyword">this</span>.onMouseOver, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div styleName=&#123;<span class="string">'btn-start-wrap'</span>&#125; ref=&#123;</span><br><span class="line">  (ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      <span class="keyword">this</span>.touchElement = ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><br>  以上的代码touchstart后不会触发mouseover。实现了阻止移动端也触发mouse事件的逻辑。</p>
<h4 id="参见："><a href="#参见：" class="headerlink" title="参见："></a>参见：</h4><p>  <a class="link"   href="https://www.jianshu.com/p/5bae6433025f"  target="_blank" rel="noopener">Passive Event Listeners——让页面滑动更加流畅的新特性<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.cnblogs.com/ziyunfei/p/5545439.html"  target="_blank" rel="noopener">紫云飞 – passive 的事件监听器<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.html5rocks.com/en/mobile/touchandmouse/"  target="_blank" rel="noopener">touch&amp;mouse<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpackPlugins</title>
    <url>/2021/05/28/webpackPlugins/</url>
    <content><![CDATA[<h4 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h4><ul>
<li>简介<br>在编译时创建一个可以配置的全局变量，在区分开发模式｜生产模式的不同时十分有用。</li>
<li>使用：<ul>
<li>在webpack的plugins中，增加<code>webpack.DefinePlugin(Object)</code>的实例</li>
<li>方法中传入的Object的key值，可以在项目所有import的文件中使用。</li>
<li>使用时得到的是key对应额value，这里在编译时，并不是变量的引用，而是<strong>编译时直接替换</strong><blockquote>
<p>因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p>
</blockquote>
</li>
</ul>
</li>
<li>文档地址<ul>
<li><a class="link"   href="https://v4.webpack.docschina.org/plugins/define-plugin/"  target="_blank" rel="noopener">webpack.DefinePlugin<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3的数据响应式系统</title>
    <url>/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="Vue2-0的数据监听"><a href="#Vue2-0的数据监听" class="headerlink" title="Vue2.0的数据监听"></a>Vue2.0的数据监听</h3><p><strong>Object.defineProperty</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123; bValue = newValue; &#125;,</span><br><span class="line">    enumerable : <span class="literal">true</span>,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>
<h3 id="Vue3-0的数据响应式系统"><a href="#Vue3-0的数据响应式系统" class="headerlink" title="Vue3.0的数据响应式系统"></a>Vue3.0的数据响应式系统</h3><p><strong>proxy</strong> get\set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用vue-next(3)源码中'packages/reactivity/dist/reactivity.global.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;reactive, effect&#125; = VueObserver;</span><br><span class="line"><span class="comment">//  reactive: 把数据处理成为响应式数据</span></span><br><span class="line"><span class="comment">//  effect: </span></span><br><span class="line"><span class="comment">//      1.首先会执行一次对应的监听函数</span></span><br><span class="line"><span class="comment">//      2.修改对应监听函数内使用的响应式数据，对应的监听函数就会立即执行，重新执行的过程就会获取新的数据</span></span><br><span class="line"><span class="keyword">const</span> yideng = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> state = reactive(yideng);</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = state.count;</span><br><span class="line">    <span class="keyword">const</span>.log(<span class="string">'当前的count'</span>, count)</span><br><span class="line">    <span class="comment">//render(count)  如果在这触发render渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">effect(fn)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之队列</title>
    <url>/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>特性：先进先出</li>
<li>解题法则：<ul>
<li>题目具备<strong>广度遍历（分层遍历）</strong>和<strong>顺序输出</strong>的特点，就应该想到用FIFO 队列来试一试。</li>
<li><strong>滑动窗口</strong>类型题</li>
</ul>
</li>
<li>模板：<ul>
<li>分层遍历</li>
<li>循环队列</li>
<li>单调队列</li>
</ul>
</li>
</ul>
<hr>
<h5 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h5><ul>
<li>例题1：从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。<br>  输入： <pre><code>   3
9     8
    6   7</code></pre>  输出：<code>[[3], [9, 8], [6, 7]]</code></li>
</ul>
<p><strong>二叉树的层次遍历</strong>的解题技巧</p>
<ul>
<li>遍历方式的变化：<ul>
<li>二叉树的锯齿形遍历</li>
<li>二叉树层次倒序遍历</li>
</ul>
</li>
<li>层的信息变化<ul>
<li>二叉树的层平均值</li>
<li>二叉树最深层的叶节点的和</li>
<li>二叉树的最大宽度</li>
</ul>
</li>
<li>树的变化<ul>
<li>N叉树的层次遍历</li>
<li>N叉树的最大深度</li>
</ul>
</li>
</ul>
<hr>
<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><ul>
<li>重点： 循环使用固定空间</li>
<li>难点： 控制好 front/rear 两个首尾指示器</li>
<li>空队列和满队列的判断，在于<code>used</code>变量</li>
<li>例题2：设计一个可以容纳 k 个元素的循环队列。需要实现以下接口：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数k表示这个循环队列最多只能容纳k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="comment">// 将value放到队列中, 成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">// 删除队首元素，成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队首元素，如果为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否已放满k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><ul>
<li>概念： 要求队列中的元素必须满足单调性，比如<strong>单调递增</strong>，或者<strong>单调递减</strong>。单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：<ul>
<li>FIFO 队列只能从尾部添加元素，首部弹出元素；</li>
<li>双端队列可以从首尾两端 push/pop 元素。</li>
</ul>
</li>
<li>注意： 单调队列在入队的时候，需要满足 2 点：<ul>
<li>入队前队列已经满足单调性；</li>
<li>入队后队列仍然满足单调性。</li>
</ul>
</li>
<li>例题3：滑动窗口的最大值<br>  输入：nums = [1,3,-1,-3,5,3], k = 3<br>  输出：[3,3,5,5]<blockquote>
<p>符合<font color=red>单调递减队列！</font></p>
</blockquote>
</li>
<li>例题4： 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？<br>  输入：[1,-1,-100,-1000,100,3], k = 2<br>  输出：4<br>  解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>手写代码系列之New(fn)</title>
    <url>/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/</url>
    <content><![CDATA[<h3 id="New操作符做了哪些事"><a href="#New操作符做了哪些事" class="headerlink" title="New操作符做了哪些事"></a>New操作符做了哪些事</h3><ul>
<li>创建了一个全新的对象。</li>
<li>会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li>
<li>使this指向新创建的对象。</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>版本一：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，且将其隐式原型指向构造函数原型</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            __proto__: fn.prototype</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行构造函数</span></span><br><span class="line">        fn.call(obj, ...arguments)</span><br><span class="line">        <span class="comment">// 返回该对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = myNew(Person)(<span class="string">'chen'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本二：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fn.prototype !==<span class="literal">null</span>)&#123;</span><br><span class="line">        res.__proto__ = fn.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = fn.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>手写代码系列</category>
      </categories>
  </entry>
  <entry>
    <title>手写代码系列之防抖与节流</title>
    <url>/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>思路</strong>：在规定时间内未触发第二次，则执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 在规定时间内再次触发</span></span><br><span class="line">        <span class="comment">// 会先清除定时器再重设定时器</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, debounce(fn1, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>思路</strong>：在规定时间内只触发一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存时间</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt;= delay)&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, throttle(fn2, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>手写代码系列</category>
      </categories>
  </entry>
  <entry>
    <title>手写代码咔咔咔</title>
    <url>/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/</url>
    <content><![CDATA[<h3 id="咔咔咔"><a href="#咔咔咔" class="headerlink" title="咔咔咔"></a>咔咔咔</h3><ul>
<li><a href="/2021/03/16/手写代码系列之防抖与节流/">手写代码系列之防抖与节流</a></li>
<li><a href="/2021/03/17/手写代码系列之New-fn/">手写New</a></li>
<li><a href="">手写Promise</a></li>
<li><a href="">手写Promise.all</a></li>
<li><a href="">二叉树的深及遍历</a></li>
<li><a href="">version版本对比</a></li>
<li><a href="">一个字符串最大的回文字符串</a></li>
<li><a href="">三数之和</a></li>
<li><a href="">手写indexof</a></li>
<li><a href="">手写EventEmitter</a></li>
<li><a href="">手写Redux.createStore</a></li>
<li><a href="">手写深拷贝、深拷贝函数</a></li>
</ul>
]]></content>
      <categories>
        <category>手写代码系列</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之栈结构</title>
    <url>/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>特性：先进后出</li>
<li>解题法则：<ul>
<li>题目中有<strong>配对、消除</strong>的题意，优先考虑<strong>栈</strong>结构</li>
<li>栈中存放的可以是<strong>内容本身</strong>和<strong>内容的索引</strong></li>
<li>数组中右边<strong>第一个比我小</strong>的元素的位置，求解用<strong>递增栈</strong></li>
<li>较小的数<strong>消除</strong>掉较大的数的时候，使用<strong>递增栈</strong>。</li>
<li>根据题意总结<strong>入栈与出栈的时机</strong></li>
</ul>
</li>
</ul>
<h5 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h5><ul>
<li>规律性：<font color=red>配对、消除</font></li>
</ul>
<hr>
<ul>
<li>例题1：字符串中只有字符’(‘和’)’。合法字符串需要括号可以配对。比如：<br>  输入：”()”<br>  输出：true<br>  解释：()，()()，(())是合法的。)(，()(，(()是非法的。<br>  请你实现一个函数<code>isValid(s)</code>，来判断给定的字符串是否合法。<blockquote>
<p>针对例1这种<font color=green>内容一样</font>时，可以使用<font color=green>计数器优化</font></p>
</blockquote>
</li>
<li>例题拓展： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<br>  左括号必须用相同类型的右括号闭合<br>  左括号必须以正确的顺序闭合<br>  注意空字符串可被认为是有效字符串<br>  请实现<code>isValid(s)</code></li>
</ul>
<hr>
<ul>
<li>例题2：在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:<br>  所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；<br>  当方向相对时，大鱼会吃掉小鱼；<br>  鱼的大小都不一样。<br>  输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]<br>  输出：3<br>  完成<code>solution(Size, Dir)</code>来计算还剩下几条鱼？</li>
</ul>
<hr>
<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><ul>
<li>定义：单调栈就是指栈中的元素必须是按照升序排列的栈，或者是降序排列的栈。<br>  升序排列的栈称为<strong>递增栈</strong><br>  降序排列的栈称为<strong>递减栈</strong><br>  特点：任何时候都需要保证栈的有序性</li>
</ul>
<hr>
<ul>
<li>例题1：一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。（找出数组中右边比我小的元素）<br>  输入：[5, 2]<br>  输出：[1, -1]<br>  解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</li>
</ul>
<blockquote>
<p>类似题：<br>数组中右边第一个比我大的元素的位置<br>数组中元素左边离我最近且比我小的元素的位置<br>数组中元素左边离我最近且比我大的元素的位置</p>
</blockquote>
<ul>
<li>例题2：给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。<br>  输入：nums = [3,5,2,6], k = 2<br>  输出：[2,6]<br>  解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</li>
</ul>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png" alt="图"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="算法四步分析法："><a href="#算法四步分析法：" class="headerlink" title="算法四步分析法："></a>算法四步分析法：</h3><ol>
<li>模拟：模拟题目的运行。</li>
<li>规律：尝试总结出题目的一般规律和特点。</li>
<li>匹配：找到符合这些特点的数据结构与算法。</li>
<li>边界：考虑特殊情况。</li>
</ol>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul>
<li><a href="/2021/03/16/数据结构与算法之栈结构/">栈结构与算法</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual DOM的工作原理</title>
    <url>/2021/01/02/%E8%99%9A%E6%8B%9Fdom/</url>
    <content><![CDATA[<h4 id="Virtual-DOM-也被称为虚拟DOM"><a href="#Virtual-DOM-也被称为虚拟DOM" class="headerlink" title="Virtual DOM 也被称为虚拟DOM"></a>Virtual DOM 也被称为虚拟DOM</h4><ul>
<li>在react中，<code>jsx语法</code>经过<code>babel解析</code>转化为<code>React.createElement()</code>函数调用后生成<code>ast抽象语法树</code>，再通过<code>render</code>函数将<code>ast树</code>转换为<code>fiber 结构</code>，填入许多调度、更新、diff相关数据，并转换<code>ast树</code>为<code>虚拟DOM树</code>，再完成挂载。</li>
<li>在vue中，模版语法 经过 <code>generate</code>处理(正则匹配 生成 <code>ast抽象语法树</code>)，<code>render</code>中调用<code>_c()/createElement()</code>函数将<code>ast树</code>生成<code>VNode(虚拟DOM)</code>,再完成挂载。</li>
</ul>
<h4 id="虚拟DOM的来源"><a href="#虚拟DOM的来源" class="headerlink" title="虚拟DOM的来源"></a>虚拟DOM的来源</h4><p>react的前身是facebook的<code>XHP</code>，在这个框架中，页面都是通过转义的方式生成的，并没有直接的HTML，确保在<code>XHP</code>中写出安全的静态页面。</p>
<p>初衷是：</p>
<ul>
<li>简化前端开发（后端赋能）</li>
<li>防止xss攻击</li>
</ul>
<p>发展是：</p>
<ul>
<li>通过虚拟DOM规避风险，不让用户直接的操作DOM了，而是把它封起来自己管理</li>
</ul>
<h4 id="虚拟DOM的表现形式"><a href="#虚拟DOM的表现形式" class="headerlink" title="虚拟DOM的表现形式"></a>虚拟DOM的表现形式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'input'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    childrean: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>React 有两个函数<br>    * diff 函数，去计算状态变更前后的虚拟 DOM 树差异<br>    * 渲染函数，渲染整个虚拟 DOM 树或者处理差异点。<br>    现在是不是有些理解为什么 React 与 ReactDOM 是两个库了？正是由于计算与渲染的分工。<br>    其中 React 的主要工作是组件实现、更新调度；ReactDOM 提供了在 网页上渲染 的基础</p>
</blockquote>
<h4 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h4><p>优点</p>
<ul>
<li>性能优越</li>
<li>规避XSS</li>
<li>可跨平台</li>
</ul>
<p>但是不是所有的操作都是虚拟DOM更高效<br>&emsp;&emsp;大量的直接操作DOM容易引起页面性能下降。这时React基于虚拟DOM的diff处理与批处理操作，可降低DOM的操作频次和范围，提升页面性能<br>&emsp;&emsp;但是在首次渲染或者微量dom操作的时候，虚拟DOM的性能就更慢一些。</p>
<p>那虚拟 DOM 一定可以规避 XSS吗？<br>&emsp;&emsp;虚拟 DOM 内部确保了字符转义，所以确实可以做到这点，但 React 存在风险，因为 React 留有 dangerouslySetInnerHTML API 绕过转义。</p>
<p>没有虚拟 DOM 不能实现跨平台吗？<br>&emsp;&emsp;比如 NativeScript 没有虚拟 DOM 层 ，它是通过提供兼容原生 API 的 JS API 实现跨平台开发。<br>那虚拟 DOM 的优势在哪里？<br>&emsp;&emsp;实际上它的优势在于跨平台的成本更低。在 React Native 之后，前端社区从虚拟 DOM 中体会到了跨平台的无限前景，<br>所以在后续的发展中，都借鉴了虚拟 DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟 DOM 的结构描述对象，来支撑多端转换。</p>
<p>缺点</p>
<ul>
<li>内存占用较高</li>
<li>难以进行优化</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Serverless是什么</title>
    <url>/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li><p>广义上来说<br>是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服务器”，但这并不代表着应用运行不需要服务器，而是开发者不需要关心服务器。而基于 Serverless 思想实现的软件架构就是 Serverless 架构。</p>
</li>
<li><p>狭义上说<br>  狭义的 Serverless 是 <code>FaaS</code> 和 <code>BaaS</code> 的组合。</p>
<ul>
<li>FaaS（Function as a Service）：<ol>
<li>FaaS本质上是一个函数运行平台，函数运行时，你对底层的服务器是无感知的，FaaS 产品会负责资源的调度和运维，这是它的特点之一，<strong>不用运维</strong>。</li>
<li>FaaS 中的函数也不是持续运行的，而是通过事件进行触发，比如 HTTP 事件、消息事件等，产生事件的源头叫触发器，FaaS 平台会集成这些触发器，我们直接用就行，这是 FaaS 的第二个特点，<strong>事件驱动</strong>。</li>
<li>FaaS 的第三个特点是<strong>按量付费</strong>。 FaaS 产品的收费方式，都是按照函数执行次数和执行时消耗的 CPU、内存等资源进行计费的。</li>
<li>FaaS 在运行函数的时候，会根据并发量自动生成多个函数实例，并且并发理论是没有上限的，这是它的第四个特点，<strong>弹性伸缩</strong>。</li>
</ol>
<ul>
<li>FaaS 每次执行函数时，都会初始化一个新的运行环境，然后从头开始执行整个代码，而不是只执行其中的 handler 方法。执行完毕后，运行环境就会被释放。这样每次函数执行，都是新的运行环境，自然不同函数之间就无法共用 pv 这个变量了。FaaS 的另一个特点，<strong>无状态</strong>。</li>
</ul>
</li>
<li>BaaS（Backend as a Service）<br> 为了解决分布式中的状态共享问题<br> BaaS 本质上就是把后端功能封装起来，以接口的形式提供服务。</li>
</ul>
</li>
<li><p>总<br>基于 FaaS 和 BaaS 的架构，是一种计算和存储分离的架构。 计算由 FaaS 负责，存储由 BaaS 负责，计算和存储也被分开部署和收费。这使应用的存储不再是应用本身的一部分，而是演变成了独立的云服务，降低了数据丢失的风险。而应用本身也变成了无状态的应用，更容易进行调度和扩缩容。</p>
</li>
</ul>
<p>基于 FaaS 和 BaaS ，你的应用就实现了自动弹性伸缩、按量付费、不用关心服务器，这正是 Serverless 架构的必要因素。所以说狭义的 Serverless 是 FaaS 和 BaaS 的组合。</p>
<h3 id="与其他架构的区别"><a href="#与其他架构的区别" class="headerlink" title="与其他架构的区别"></a>与其他架构的区别</h3><ul>
<li>PaaS<br>  PaaS （平台即服务）是云计算虚拟机时代的主要形态之一。 它是指云厂商提供开发工具、依赖库、服务和运行平台等能力，开发者可以依赖这些能力将自己的应用直接部署在云平台上，不用关心底层的计算资源、网络、存储等。虽然与Serverless 很类似，但依旧存在一些区别。</li>
<li>Kubernetes<br>  Kubernetes 是一种容器编排技术。在 Kubernetes 中应用运行的基本单位是 Pod（容器组），Pod 是应用及运行环境的集合，所以你也不用关心服务器了。基于 Kubernetes，你能很方便地进行 Pod 的管理，并且实现应用的弹性伸缩。<br>  所以，Kubernetes 是介于 Serverful 和 Serverless 中间的产物。</li>
</ul>
<p><strong>Serverless 是云原生的一种实现，云原生的另一种实现是 Kubernetes。</strong></p>
<table>
<thead>
<tr>
<th align="left">Serverless</th>
<th align="left">PaaS （平台即服务）</th>
<th align="left">Kubernetes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按实际使用量付费</td>
<td align="left">按资源付费</td>
<td align="left">按照资源数量计费</td>
</tr>
</tbody></table>
<h3 id="Serverless-的优缺点"><a href="#Serverless-的优缺点" class="headerlink" title="Serverless 的优缺点"></a>Serverless 的优缺点</h3><ul>
<li>优点：不用运维、弹性伸缩、节省成本、开发简单、降低风险、易于扩展。</li>
<li>缺点：<ol>
<li>依赖第三方服务：一旦你选择了一个云厂商，要想从一个云移到另一个台，成本很高</li>
<li>底层硬件的多样性：代码依赖的地层硬件多样性</li>
<li>应用性能瓶颈：函数运行前需要现初始化函数运行环境，这个过程需要消耗一定时间。因为函数不是持续“在线”的，而是需要运行的时候才启动（不像传统应用，服务是一直启动的）。</li>
<li>函数通信效率低：在 Serverless 应用中，函数与函数之间就完全独立了。如果两个函数的数据有依赖，需要进行通信、交换数据，就要进行函数与函数之间的调用（调用方式是 HTTP 调用）。相比之前的内存调用，数据交互效率显然低了很多。而这个问题的本质，是 FaaS 还没有比较好的数据通信协议或方案。</li>
<li>开发调试复杂：Serverless 架构正处于飞速发展的阶段，其开发、调试、部署工具链并不完善（基本是每个云厂商各玩各的）</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>React面向组件跨层级通信</title>
    <url>/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h4 id="父与子"><a href="#父与子" class="headerlink" title="父与子"></a>父与子</h4><pre><code>父组件包裹子组件，父组件向子组件传递数据。</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子 </span></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    &lt;button type=<span class="string">"button"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">state = &#123;</span></span><br><span class="line"><span class="regexp">    text: "默认文案"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">asyc componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    const response = await fetch('/</span>api/buttonText<span class="string">')</span></span><br><span class="line"><span class="string">    this.setState(&#123;</span></span><br><span class="line"><span class="string">    text: response.buttoText</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        const &#123;</span></span><br><span class="line"><span class="string">        text</span></span><br><span class="line"><span class="string">        &#125; = this.state</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;Button text=&#123;text&#125; /&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样的通信方式非常适用于展示组件。</p>
<h4 id="子与父"><a href="#子与父" class="headerlink" title="子与父"></a>子与父</h4><pre><code>子组件存在于父组件之中，子组件需要向父组件传递数据。</code></pre><ul>
<li>回调函数（主要方式）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchPosts</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        data: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/posts'</span>)</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            data: response.data,</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state.loading) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.renderPosts(<span class="keyword">this</span>.state.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        &lt;FetchPosts</span><br><span class="line">            renderPosts=&#123;posts =&gt; (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">                &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">                    &lt;h2&gt;&#123;post.title&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;p&gt;&#123;post.description&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    ))&#125;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        /&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例函数（不符合 React 的设计理念，不被推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   modalRef = React.createRef()  <span class="comment">//实例</span></span><br><span class="line">   showModal = () =&#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.show()</span><br><span class="line">   &#125;</span><br><span class="line">   hideModal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.hide()</span><br><span class="line">   &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          text</span><br><span class="line">        &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">              &lt;Button onClick=&#123;<span class="keyword">this</span>.showModal&#125;&gt;展示 Modal &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Button onClick=&#123;this.hideModal&#125;&gt;隐藏 Modal &lt;/</span>Button&gt;</span><br><span class="line">              &lt;Modal ref=&#123;modalRef&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h4><p>  两个组件并列存在于父组件中，数据需要进行相互传递，往往依赖共同的父组件进行中转。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleChanged = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChangeText(e.target.text)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleTextChanged&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="keyword">const</span> StaticText = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;P&gt;&#123;children&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    state = &#123;</span></span><br><span class="line"><span class="regexp">        text: '默认文案'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    handleTextChanged = (text) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">        text,</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Input onChangeText=&#123;this.handleTextChanged&#125; /</span>&gt;</span><br><span class="line">              &lt;StaticText&gt;<span class="keyword">this</span>.state.text&lt;<span class="regexp">/StaticText&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无直接关系"><a href="#无直接关系" class="headerlink" title="无直接关系"></a>无直接关系</h4><p>  两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据。</p>
</li>
<li><p>Context<br>  Context 第一个最常见的用途就是做 i18n</p>
<ol>
<li>i18n使用Context <code>I18nContext</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> I18nContext = createContext(&#123;</span><br><span class="line">    translate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">''</span>,</span><br><span class="line">    getLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    setLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> I18nContext;</span><br></pre></td></tr></table></figure></li>
<li>用<code>I18nContext</code>封装个组件<code>I18nProvider</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I18nProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        locale: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> i18n =  &#123;</span><br><span class="line">            translate: <span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.props.languages[locale][key],</span><br><span class="line">            getLocale: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.state.locale,</span><br><span class="line">            setLocale: <span class="function"><span class="params">locale</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                loacal,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;I18nContext.Provider value=&#123;i18n&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/I18nContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default I18nProvider;</span></span><br></pre></td></tr></table></figure></li>
<li>用<code>I18nContext</code>实现高阶组件<code>withI18n</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="keyword">const</span> withI18n = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">        &lt;I18nContext.Consumer&gt;</span><br><span class="line">            &#123;i18n =&gt; <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...i18n</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/I18nContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default withI18n;</span></span><br></pre></td></tr></table></figure></li>
<li>在最顶层注入 Provider<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; I18nProvider &#125; <span class="keyword">from</span> <span class="string">'./i18n'</span>;</span><br><span class="line"><span class="keyword">const</span> locales = [ <span class="string">'en-US'</span>, <span class="string">'zh-CN'</span> ];</span><br><span class="line"><span class="keyword">const</span> languages = &#123;</span><br><span class="line">    <span class="string">'en-US'</span>: <span class="built_in">require</span>(<span class="string">'./locales/en-US'</span>),</span><br><span class="line">    <span class="string">'zh-CN'</span>: <span class="built_in">require</span>(<span class="string">'./locales/zh-CN'</span>),</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;I18nProvider locales=&#123;locales&#125; languages=&#123;languages&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/I18nProvider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li>
<li>在需要的地方使用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = withI18n(</span><br><span class="line">    (&#123; translate &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;translate('title')&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> Footer = withI18n(</span><br><span class="line">    (&#123; setLocale &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params"> &lt;Button onClick=((</span>) =&gt;</span> &#123;</span><br><span class="line">            setLocale(<span class="string">'zh-CN'</span>)</span><br><span class="line">        &#125;) /&gt; )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>全局变量<br>  全局变量，顾名思义就是放在 Window 上的变量。但值得注意的是修改 Window 上的变量并不会引起 React 组件重新渲染。</p>
</li>
<li><p>状态管理框架</p>
<ul>
<li>Flux</li>
<li>Redux</li>
<li>Mobx</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计react组件</title>
    <url>/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="痛定思痛"><a href="#痛定思痛" class="headerlink" title="痛定思痛"></a>痛定思痛</h4><p>没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。</p>
<ul>
<li>把一个页面写成一个组件</li>
<li>一个组件有3000行代码</li>
</ul>
<h4 id="基于场景的设计分类"><a href="#基于场景的设计分类" class="headerlink" title="基于场景的设计分类"></a>基于场景的设计分类</h4><p>围绕“如何组合”根据不同的场景设计不同模式</p>
<ul>
<li><p>组件的类别</p>
<ul>
<li><p>无状态组件/哑组件/展示组件： 只做展示、独立运行、不额外增加功能的组件</p>
<ul>
<li>优点： <ul>
<li>展示组件的复用性更强，复用率更高</li>
<li>内部没有任何的state，只受制于外部的props传参</li>
</ul>
</li>
<li>衍生出的其他组件设计<ul>
<li>代理组件：基于ui框架的其他组件，外面封装一层，实现代理组件。<ol>
<li>更换ui框架时更方便。解决了组件库的强依赖特性，实现无痛切换</li>
<li>都内聚在代理组件中，修改基础组件的属性更方便，不会散落在各处</li>
</ol>
</li>
<li>样式组件：本质上也是一种代理组件，但是又细分了处理样式的领域，将当前的关注点分离在组件内<ol>
<li>自身承接业务判断逻辑，封装了ui库中的组件来控制样式，改动会更方便更友好</li>
</ol>
</li>
<li>布局组件： 基本设计与样式组件完全一样，增加了一个小优化<ol>
<li>布局组件一般不根据状态改变，所以可以封装布局组件后，可以直接使用<code>shouldComponentUpdate</code>函数阻断渲染，提升性能</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有状态组件/灵巧组件： 处理业务逻辑与数据状态的组件<br>  灵巧组件更专注于业务本身；灵巧组件一定要至少包含一个灵巧组件或展示组件。功能更丰富，但复用率低</p>
<ul>
<li>衍生出的其他组件设计<ul>
<li>容器组件：几乎没有复用性，主要功能在<strong>拉取数据</strong>和<strong>组合组件</strong> </li>
<li>高阶组件： React中复用组件的高级技术，基于React组合特性形成的设计模式<ol>
<li>道理类似函数式编程的高级函数（接收一个函数，返回一个函数），高阶组件接收参数为组件，返回值也是新一个组件。</li>
<li>可抽取公共逻辑<ul>
<li>登陆态的判断<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰器写法</span></span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkLogin() ? <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">LoginPage</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(RawUserPage)</span><br></pre></td></tr></table></figure></li>
<li>页面埋点统计<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> trackPageView = (pageName) = &#123; </span><br><span class="line">    <span class="comment">// 发送埋点信息请求</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            trackPageView(pageName)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'购物车页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'订单页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>既要判断登陆态，又要埋点：<strong>链式调用</strong><br>  链式调用是函数式编程高级函数的一种使用场景。在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数调用方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(PV(<span class="string">'用户页面'</span>)(RawUserPage))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器调用方式</span></span><br><span class="line"></span><br><span class="line">@checkLogin</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>渲染劫持<br> 渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.props.isLoading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。</li>
</ol>
</li>
<li>高阶组件的缺点<ul>
<li>丢失静态函数：由于被包裹了一层，所以静态函数在外层是无法获取的。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserPage.jsx</span></span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getUser() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">'./UserPage'</span></span><br><span class="line">UserPage.checkLogin() <span class="comment">// 调用失败，并不存在。</span></span><br></pre></td></tr></table></figure>
  <em>解决方案</em>：在外部函数中把内部函数的方法复制出来：<code>hoist-non-react-statics</code>(现成的库)  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                trackPageView(pageName)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hoistNonReactStatics(Wrap, WrappedComponent);</span><br><span class="line">        <span class="keyword">return</span> Wrap;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>refs 属性不能透传: ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidUpdate(prevProps) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'old props:'</span>, prevProps);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'new props:'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="所以：组件的目录结构"><a href="#所以：组件的目录结构" class="headerlink" title="所以：组件的目录结构"></a>所以：组件的目录结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过目录级别完成切分</span></span><br><span class="line">    src</span><br><span class="line">    ├── components</span><br><span class="line">    │   ├── basic   <span class="comment">// 最基本的展示组件放入 basic 目录中 建议使用类似 Storybook 的工具进行组件管理。</span></span><br><span class="line">    │   ├── container  <span class="comment">//将容器组件放入 container</span></span><br><span class="line">    │   └── hoc  <span class="comment">//高阶组件放入 hoc 中</span></span><br><span class="line">    └── pages  <span class="comment">//将页面外层组件放在页面目录中</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a class="link"   href="https://storybook.js.org/"  target="_blank" rel="noopener">Storybook官网<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react的类组件和函数组件</title>
    <url>/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>react的最小单位是组件</p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>实际用途是一样的，都可作为基础组件展示UI</li>
<li>在现代浏览器中，除极端场景下，类（类组件）和闭包（函数组件）的性能差异不大</li>
</ul>
<h4 id="区别点"><a href="#区别点" class="headerlink" title="区别点"></a>区别点</h4><ul>
<li>代码实现思想<ul>
<li>类组件的根基是OOP，面向对象编程</li>
<li>函数组件的根据是FP，函数式编程</li>
</ul>
</li>
<li>使用场景<ul>
<li>类组件使用生命周期</li>
<li>函数组件使用react hooks实现类似生命周期的能力</li>
</ul>
</li>
<li>设计模式<ul>
<li>类组件可以实现继承</li>
<li>函数组件缺少继承能力<blockquote>
<p>react前端思想：组合优于继承（继承的灵活性差，细节屏蔽过多）</p>
</blockquote>
</li>
</ul>
</li>
<li>性能优化<ul>
<li>类组件依靠<code>shouldComponentUpdate</code>函数阻断渲染</li>
<li>函数组件依靠<code>React.memo()</code>来优化<blockquote>
<p>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p>
</blockquote>
</li>
</ul>
</li>
<li>未来趋势<ul>
<li>基于hooks的加持，react社区主推<strong>函数组件</strong></li>
</ul>
</li>
</ul>
<h4 id="优劣性"><a href="#优劣性" class="headerlink" title="优劣性"></a>优劣性</h4><ul>
<li>类组件<ul>
<li>this的模糊性</li>
<li>业务逻辑散落在生命周期中</li>
<li>类组件缺乏标准的拆分方式</li>
</ul>
</li>
<li>函数组件<ul>
<li>基于函数式编程的优点（输入输出恒定，无副作用等），函数组件更纯粹、简单、易测试。</li>
<li>闭包捕获的值优于this的模糊性，捕获的值永远是确定且安全的</li>
<li>更细腻的逻辑组织和复用，更好的作用于时间切片与并发模式</li>
<li>由于函数组件的执行从来都是自顶向下，依赖于<code>dom diff</code>算法不至于频繁渲染</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react生命周期爬坑</title>
    <url>/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/</url>
    <content><![CDATA[<p>由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件</p>
<h3 id="梳理生命周期的时机和职责，建立时机与操作的对应关系"><a href="#梳理生命周期的时机和职责，建立时机与操作的对应关系" class="headerlink" title="梳理生命周期的时机和职责，建立时机与操作的对应关系"></a>梳理生命周期的<strong>时机</strong>和<strong>职责</strong>，建立时机与操作的对应关系</h3><ul>
<li>使用方式（时机梳理）： 挂载，更新，卸载</li>
<li>适用范围（职责梳理）：状态变更、错误处理</li>
</ul>
<h4 id="时机梳理"><a href="#时机梳理" class="headerlink" title="时机梳理"></a>时机梳理</h4><h5 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h5><pre><code>挂载阶段是指组件从初始化到完成加载的过程。</code></pre><ul>
<li><p>constructor<br>  是类通用的构造函数，常用于初始化。所以在过去，constructor 通常用于初始化 state 与绑定函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">   <span class="comment">// constructor react 官方弃用</span></span><br><span class="line">   <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">      <span class="keyword">super</span>(props)   </span><br><span class="line">      <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getDerivedStateFromProps</p>
<ul>
<li>当props被传入</li>
<li>state发生变化时</li>
<li>fouceUpdate被调用<blockquote>
<p>最常见的一个错误是认为只有 props 发生变化时，getDerivedStateFromProps 才会被调用，而实际上只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。所以是外部参数，也就是 props 传入时就会发生变化。你可能不需要使用派生 state</p>
</blockquote>
</li>
</ul>
</li>
<li><p>UNSAFE_componentWillMount(componentWillMount)<br>  用于组件加载前做某些操作<br>  因在React的异步渲染机制下，会被多次调用。react弃用<br>  eg：同构时，在服务器端和客户端同时发起请求拉取数据，会分别被执行一次</p>
</li>
<li><p>render 纯函数  返回jsx解构，描述渲染内容</p>
</li>
<li><p>componentDidMount<br>  组件加载完成时做某些操作，用于发起请求</p>
</li>
</ul>
<h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><pre><code>更新阶段是指外部 props 传入，或者 state 发生变化时的阶段。</code></pre><ul>
<li><p>UNSAFE_componentWillReceiveProps<br>  被标记弃用，因为其功能可被函数 getDerivedStateFromProps 所替代。</p>
</li>
<li><p>getDerivedStateFromProps<br>  同挂载阶段的表现一致。</p>
</li>
<li><p>shouldComponentUpdate<br>  该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</p>
<p>  React 官方提供了一个通用的优化方案，也就是 PureComponent。PureComponent 的核心原理就是默认实现了shouldComponentUpdate函数，在这个函数中对 props 和 state 进行浅比较，用来判断是否触发更新。 </p>
</li>
<li><p>UNSAFE_componentWillUpdate<br>  同样已废弃，因为后续的 React 异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p>
</li>
<li><p>render<br>  同挂载阶段的表现一致。</p>
</li>
<li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate 方法是配合 React 新的异步渲染的机制，在 DOM 更新发生前被调用，返回值将作为 componentDidUpdate 的第三个参数。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">        <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">        <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">        <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">        <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>componentDidUpdate<br>  正如上面的案例，getSnapshotBeforeUpdate 的返回值会作为componentDidUpdate的第三个参数使用。</p>
</li>
</ul>
<h5 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h5><ul>
<li>componentWillUnmount<br>  卸载阶段唯一的回调函数。<br>  该函数主要用于执行清理工作。一个比较常见的 Bug 就是忘记在 componentWillUnmount 中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以一定要在该阶段解除事件绑定，取消定时器。</li>
</ul>
<h4 id="职责梳理"><a href="#职责梳理" class="headerlink" title="职责梳理"></a>职责梳理</h4><p>如果我们的 React 应用足够复杂、渲染层级足够深时，一次重新渲染，将会消耗非常高的性能，导致卡顿等问题。<br>关键点：</p>
<ol>
<li>什么情况下会触发重新渲染。</li>
<li>渲染中发生报错后会怎样？又该如何处理？</li>
</ol>
<hr>
<ul>
<li>函数组件</li>
</ul>
<p>函数组件任何情况下都会重新渲染。<br>官方提供了一种方式优化手段，那就是 React.memo。<br>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>React.Component<br>  如果不实现 shouldComponentUpdate 函数，那么有两种情况触发重新渲染。</p>
<ol>
<li>当 state 发生变化时。这个很好理解，是常见的情况。</li>
<li>当父级组件的 Props 传入时。无论 Props 有没有变化，只要传入就会引发重新渲染。</li>
</ol>
</li>
<li><p>React.PureComponent<br>  PureComponent 默认实现了 shouldComponentUpdate 函数。所以仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。</p>
</li>
<li><p>错误边界<br>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，如下 React 官方所给的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是 React，还是 React Native，如果没有错误边界，在用户侧看到的现象会是这样的：在执行某个操作时，触发了 Bug，引发了崩溃，页面突然白屏。<br>但渲染时的报错，只能通过 componentDidCatch 捕获。这是在做线上页面报错监控时，极其容易忽略的点儿。</p>
</li>
</ul>
<h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><ul>
<li>在不恰当的时机调用不合适的代码</li>
<li>在需要调用时，忘记了调用</li>
</ul>
<p>以下情况容易造成生命周期的坑</p>
<ol>
<li><p>getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p>
</li>
<li><p>componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。</p>
</li>
<li><p>componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p>
</li>
<li><p>shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p>
</li>
<li><p>componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p>
</li>
<li><p>如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p>
</li>
<li><p>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>你可能不需要使用派生state</title>
    <url>/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/</url>
    <content><![CDATA[<p><a class="link"   href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html"  target="_blank" rel="noopener">你可能不需要使用派生state<i class="fas fa-external-link-alt"></i></a></p>
<p>文中列举了两种反模式的使用方式</p>
<ul>
<li>直接复制prop到state</li>
<li>在props变化后修改state</li>
</ul>
<p>这两种使用方式除了增加代码的维护成本外，没有任何的好处</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack优化之代码分割splitChunck</title>
    <url>/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><ul>
<li>splitChunck</li>
<li>动态引用<ul>
<li>适用场景：抽离相同代码到一个共享块</li>
<li>脚本懒加载，使得初始下载代码更小</li>
</ul>
</li>
<li>懒加载JS脚本方式<ul>
<li>CommonJS: require.ensure</li>
<li>ES6: 动态import（需要babel支持，@babel/plugin-syntax-dynamic-import)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置.babelrc</span></span><br><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dist代码通过window[‘webpackJsonp’]来获取对应脚本</p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack优化之Scope Hoisting</title>
    <url>/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/</url>
    <content><![CDATA[<h4 id="webpack打包现象"><a href="#webpack打包现象" class="headerlink" title="webpack打包现象"></a>webpack打包现象</h4><p>webpack构建后的代码存在大量的闭包代码</p>
<ul>
<li>大量函数闭包包裹代码，导致体积增大(模块越多越明显)</li>
<li>运行代码时创建的函数作用域变多，内存开销变大</li>
<li>被webpack转换后的模块会带上一层包裹，import会被转换成<strong>webpack_require</strong></li>
</ul>
<h4 id="Scope-Hoisting原理"><a href="#Scope-Hoisting原理" class="headerlink" title="Scope Hoisting原理"></a>Scope Hoisting原理</h4><ul>
<li>将所有模块的代码按照引用顺序放在一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突</li>
<li>对比，通过scope hoisting 可以减少函数声明代码和内存开销</li>
</ul>
<h4 id="开启scope-hoisting"><a href="#开启scope-hoisting" class="headerlink" title="开启scope hoisting"></a>开启scope hoisting</h4><ul>
<li>webpack4 mode 为 production默认开启，必须是ES6语法，commonJS不支持</li>
<li>webpack3 增加插件 new webpack.optimize.ModuleConcatenationPlugin()</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack优化之tree-shaking</title>
    <url>/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BTreeShaking/</url>
    <content><![CDATA[<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><ul>
<li>静态分析，不是动态分析</li>
<li>代码不会被执行到，就不会打包到bound.js</li>
<li>必须使用ES6的语法(import、export)才支持tree-shaking，commonjs方式不支持</li>
<li>webpck默认支持，在.babelrc里面设置 modules: false即可，同时mode=production默认开启</li>
</ul>
<h4 id="tree-shaking原理"><a href="#tree-shaking原理" class="headerlink" title="tree-shaking原理"></a>tree-shaking原理</h4><ul>
<li>只能作为模块顶层的语句出现</li>
<li>import的模块只能是字符串常量   export function() {}</li>
<li>import binding 是 immutable 的</li>
</ul>
<p>代码擦除: uglify阶段删除无用代码</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4&amp;&amp;ESlint</title>
    <url>/2020/12/15/webpack4&amp;&amp;ESlint/</url>
    <content><![CDATA[<h4 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h4><p>ESLint是一个用来识别ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.eslint.js</span></span><br><span class="line"><span class="comment">// 区分生产环境、开发环境</span></span><br><span class="line"><span class="keyword">const</span> _mode = process.env.NODE_ENV || <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"node"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"globals"</span>: &#123;</span><br><span class="line">        <span class="string">"$"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"process"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"dirname"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"eslint:recommended"</span>,</span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">            <span class="string">"jsx"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"legacyDecorators"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">2018</span>,</span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"react"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="string">"no-debugger"</span>: _mode===<span class="string">'development'</span> ? <span class="number">0</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"no-alert"</span>: _mode===<span class="string">'development'</span> ? <span class="number">0</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// "no-multi-spaces": "error",</span></span><br><span class="line">        <span class="string">"no-unused-vars"</span>: <span class="string">"off"</span>, <span class="comment">// react中不适用</span></span><br><span class="line">        <span class="string">"no-constant-condition"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="string">"no-fallthrough"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="comment">// "keyword-spacing": ["error", &#123; "before": true&#125; ], // 不生效，先注释</span></span><br><span class="line">        <span class="comment">// "indent": [</span></span><br><span class="line">        <span class="comment">//  "error",</span></span><br><span class="line">        <span class="comment">//  2</span></span><br><span class="line">        <span class="comment">// ],</span></span><br><span class="line">        <span class="string">"linebreak-style"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"unix"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// "quotes": [</span></span><br><span class="line">        <span class="comment">//  "error",</span></span><br><span class="line">        <span class="comment">//  "single"</span></span><br><span class="line">        <span class="comment">// ],</span></span><br><span class="line">        <span class="string">"semi"</span>: [<span class="number">0</span>],</span><br><span class="line">        <span class="string">"no-unexpected-multiline"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"no-class-assign"</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="检查eslint"><a href="#检查eslint" class="headerlink" title="检查eslint"></a>检查eslint</h4><ul>
<li>方式一: 安装husky，增加npm script，适合老项目</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">//"precommit": "eslint --ext .js --ext .jsx src/",</span></span><br><span class="line">    <span class="string">"precommit"</span>: <span class="string">"eslint lint-staged"</span>, <span class="comment">// 增量检查修改的文件  </span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="comment">//"src/**/*.js": [</span></span><br><span class="line">    <span class="comment">//  "eslint --ext .js --ext .jsx",</span></span><br><span class="line">    <span class="comment">//  "git add"</span></span><br><span class="line">    <span class="comment">//]</span></span><br><span class="line">    <span class="string">"linters"</span>: &#123;</span><br><span class="line">        <span class="string">"*.[js,scss]"</span>: [<span class="string">"eslint --fix"</span>, <span class="string">"git add"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：webpack与eslint结合，新项目</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实新项目中，可以将两种方式同时使用</p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4定位源代码source-map</title>
    <url>/2020/12/15/webpack4%E5%AE%9A%E4%BD%8D%E6%BA%90%E4%BB%A3%E7%A0%81source-map/</url>
    <content><![CDATA[<h4 id="定位源代码"><a href="#定位源代码" class="headerlink" title="定位源代码"></a>定位源代码</h4><ul>
<li><p>通过 source-map 定位到源代码</p>
</li>
<li><p>开发环境：建议使用</p>
<ul>
<li>首先在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系。因此不管是开发环境还是生产环境，我们都会选择增加cheap基本类型来忽略模块打包前后的列信息关联。</li>
<li>其次，不管在生产环境还是开发环境，我们都需要定位debug到最最原始的资源，比如定位错误到jsx，coffeeScript的原始代码处，而不是编译成js的代码处，因此，不能忽略module属性</li>
<li>再次我们希望通过生成.map文件的形式，因此要增加source-map属性</li>
</ul>
</li>
<li><p>线上环境关闭</p>
</li>
<li><p>eval：使用<code>eval</code>包裹模块代码</p>
</li>
<li><p>cheap：不包含列信息</p>
</li>
<li><p>inline：将.map作为DataURI嵌入，不单独生成.map文件</p>
</li>
<li><p>module：包含loader的source</p>
</li>
<li><p>source-map 类型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">devtool</th>
<th align="left">首次构建</th>
<th align="left">二次构建</th>
<th align="left">是否适合生产环境</th>
<th align="left">可以定位的代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(none)</td>
<td align="left">+++</td>
<td align="left">+++</td>
<td align="left">yes</td>
<td align="left">最终输出的代码</td>
</tr>
<tr>
<td align="left">eval</td>
<td align="left">+++</td>
<td align="left">+++</td>
<td align="left">no</td>
<td align="left">webpack生成的代码块（一个个的模块）</td>
</tr>
<tr>
<td align="left">cheap-eval-source-map</td>
<td align="left">+</td>
<td align="left">++</td>
<td align="left">no</td>
<td align="left">经过loader转换后的代码（只能看到行）</td>
</tr>
<tr>
<td align="left">cheap-module-eval-source-map</td>
<td align="left">o</td>
<td align="left">++</td>
<td align="left">no</td>
<td align="left">源代码（只能看到行）</td>
</tr>
<tr>
<td align="left">eval-source-map</td>
<td align="left">–</td>
<td align="left">+</td>
<td align="left">no</td>
<td align="left">源代码</td>
</tr>
<tr>
<td align="left">cheap-source-map</td>
<td align="left">+</td>
<td align="left">o</td>
<td align="left">yes</td>
<td align="left">经过loader转换后的代码（只能看到行）</td>
</tr>
<tr>
<td align="left">cheap-module-source-map</td>
<td align="left">o</td>
<td align="left">-</td>
<td align="left">yes</td>
<td align="left">源代码（只能看到行）</td>
</tr>
<tr>
<td align="left">inline-cheap-source-map</td>
<td align="left">+</td>
<td align="left">o</td>
<td align="left">no</td>
<td align="left">经过loader转换后的代码（只能看到行）</td>
</tr>
<tr>
<td align="left">inline-cheap-module-source-map</td>
<td align="left">o</td>
<td align="left">-</td>
<td align="left">no</td>
<td align="left">源代码（只能看到行）</td>
</tr>
<tr>
<td align="left">source-map</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">yes</td>
<td align="left">源代码</td>
</tr>
<tr>
<td align="left">inline-source-map</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">no</td>
<td align="left">源代码</td>
</tr>
<tr>
<td align="left">hidden-source-map</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">yes</td>
<td align="left">源代码</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.expors = &#123;</span><br><span class="line">  <span class="comment">// 开发,因为eval的rebuild速度快，因此我们可以在本地环境中增加eval属性</span></span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span></span><br><span class="line">  <span class="comment">// 生产</span></span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4代码拆分</title>
    <url>/2020/12/15/webpack4%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h4 id="基础库分离"><a href="#基础库分离" class="headerlink" title="基础库分离"></a>基础库分离</h4><p><strong>将react、react-dom基础包通过cdn引入，不打入到bundle中</strong></p>
<ul>
<li><p><code>externals</code></p>
<ul>
<li>配置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        react: <span class="string">'React'</span>,</span><br><span class="line">        <span class="string">'react-dom'</span>: <span class="string">'ReactDOM'</span>,</span><br><span class="line">        <span class="string">'react-router-dom'</span>: <span class="string">'ReactRouterDOM'</span>,</span><br><span class="line">        mobx: <span class="string">'mobx'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在html模版中 script标签引入对应的cdn地址</li>
</ul>
</li>
<li><p><code>html-webpack-externals-plugin</code><strong>（推荐使用）</strong></p>
<ul>
<li>在html模版中 script标签引入对应的cdn地址</li>
<li>在<code>plugins</code>中配置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> htmlWebpackExternalsPlugin(&#123;</span><br><span class="line">        externals: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">            entry: react的cdn地址,</span><br><span class="line">            global: <span class="string">'React'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">            entry: react-dom的cdn地址,</span><br><span class="line">            global: <span class="string">'ReactDOM'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react-router-dom'</span>,</span><br><span class="line">            entry: react-router-dom的cdn地址,</span><br><span class="line">            global: <span class="string">'ReactRouterDOM'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webpack4 替代 CommonsChunckPlugin插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        runtimeChunk: &#123;</span><br><span class="line">            name: <span class="string">'manifest'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'async'</span>, <span class="comment">// async异步引入库进行分离(默认),initial同步引入库分离，all所有引入库分离</span></span><br><span class="line">            minSize: <span class="number">30000</span>, <span class="comment">// 抽离公共包最小的大小</span></span><br><span class="line">            maxSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>, <span class="comment">// 最小使用的次数 </span></span><br><span class="line">            maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">            name: <span class="literal">true</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                <span class="comment">// 提取基础库，不使用CDN的方式</span></span><br><span class="line">                <span class="comment">//commons: &#123;</span></span><br><span class="line">                <span class="comment">//  test: /(react|react-dom|react-router-dom)/,</span></span><br><span class="line">                <span class="comment">//  name: "vendors",</span></span><br><span class="line">                <span class="comment">//  chunks: 'all'</span></span><br><span class="line">                <span class="comment">//&#125;,</span></span><br><span class="line">                <span class="comment">// 提取公共js</span></span><br><span class="line">                commons: &#123;</span><br><span class="line">                chunks: <span class="string">"all"</span>, <span class="comment">// initial</span></span><br><span class="line">                minChunks: <span class="number">2</span>,</span><br><span class="line">                maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">                minSize: <span class="number">0</span>,</span><br><span class="line">                name: <span class="string">"commons"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// vendors: &#123;</span></span><br><span class="line">                <span class="comment">//   test: /[\\/]node_modules[\\/]/,</span></span><br><span class="line">                <span class="comment">//   priority: -10</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// 合并所有css</span></span><br><span class="line">                <span class="comment">// styles: &#123;</span></span><br><span class="line">                <span class="comment">//   name: 'style',</span></span><br><span class="line">                <span class="comment">//   test: /\.(css|scss)$/,</span></span><br><span class="line">                <span class="comment">//   chunks: 'all',</span></span><br><span class="line">                <span class="comment">//   minChunks: 1,</span></span><br><span class="line">                <span class="comment">//   enforce: true</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4多页面应用MPA</title>
    <url>/2020/12/15/webpack4%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8MPA/</url>
    <content><![CDATA[<h4 id="多页面应用MPA"><a href="#多页面应用MPA" class="headerlink" title="多页面应用MPA"></a>多页面应用MPA</h4><ul>
<li>每一次页面跳转，后台都会返回一个新的html，多页应用</li>
<li>属于后端渲染，有明显的优势：SEO友好、每个页面是解耦的</li>
<li>缺点：每个页面对应一个entry，一个html-webpack-plugin，（这种太麻烦了，每次新增都需要再配置一次）</li>
</ul>
<h4 id="针对上述缺点的解决方案"><a href="#针对上述缺点的解决方案" class="headerlink" title="针对上述缺点的解决方案"></a>针对上述缺点的解决方案</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 例如 ./src/index/index.js 与 ./src/search/index.js</span></span><br><span class="line"><span class="comment">// path: './src/*/index.js'</span></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">filenames</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;, htmlWebpackPlugins = [];</span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, filenames))</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> entryFiles)&#123;</span><br><span class="line">    <span class="comment">// (/\/([a-z\_\$]+)\/index.js$/)</span></span><br><span class="line">    <span class="keyword">const</span> match = item.match(<span class="regexp">/src\(.*)/i</span>ndex\.js$/)</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = item</span><br><span class="line"></span><br><span class="line">    htmlWebpackPlugins.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>,</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>,</span><br><span class="line">        chunks: [<span class="string">"runtime"</span>, <span class="string">"common"</span>, pageName],</span><br><span class="line">        minify: &#123;</span><br><span class="line">          <span class="comment">// ..</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry,</span><br><span class="line">    htmlWebpackPlugins</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">entry: entry</span><br><span class="line">plugin: [<span class="comment">//.....].concat(htmlWebpackPlugins)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4资源内联</title>
    <url>/2020/12/15/webpack4%E8%B5%84%E6%BA%90%E5%86%85%E8%81%94/</url>
    <content><![CDATA[<h4 id="资源内联是干什么"><a href="#资源内联是干什么" class="headerlink" title="资源内联是干什么"></a>资源内联是干什么</h4><p>资源内联：就是把打包好的css等文件，在html中注入这些文件路径，实现内联</p>
<ul>
<li>页面框架的初始化，比如flexible</li>
<li>上报相关打点</li>
<li>css内联避免页面闪动（直接将css内联到html文件）</li>
</ul>
<h4 id="内联html"><a href="#内联html" class="headerlink" title="内联html"></a>内联html</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raw-loader@0.5.1 内联html片段，在template中弄</span></span><br><span class="line"><span class="comment">// 内联html</span></span><br><span class="line">&lt;%= <span class="built_in">require</span>(<span class="string">'raw-loader!./meta.html'</span>) %&gt;</span><br></pre></td></tr></table></figure>

<h4 id="内联javascript"><a href="#内联javascript" class="headerlink" title="内联javascript"></a>内联javascript</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raw-loader内联js</span></span><br><span class="line"><span class="comment">// 初始化脚本，例如flexible</span></span><br><span class="line">&lt;script&gt;&lt;%= <span class="built_in">require</span>(<span class="string">'raw-loader!babel-loader!../node_modules/lib-flexible/flexible.js'</span>) %&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="内联css"><a href="#内联css" class="headerlink" title="内联css"></a>内联css</h4><ul>
<li>方式一：style-loader</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.s?css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'style-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    injectType: <span class="string">'singletonStyleTag'</span>, <span class="comment">// 将所有style标签合并成一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">'css-loader'</span></span><br><span class="line">            <span class="string">'postcss-loader'</span>,</span><br><span class="line">            <span class="string">'sass-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二： html-inline-css-webpack-plugin<br>首先使用 mini-css-extract-plugin（而非 style-loader）将 css 提取打包成一个独立的 css chunk 文件 然后使用html-webpack-plugin 生成 html 页面 最后使用 html-inline-css-webpack-plugin 读取打包好的 css chunk 内容注入到页面，原本 html-webpack-plugin 只会引入 css 资源地址，现在实现了 css 内联</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLInlineCSSWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-inline-css-webpack-plugin"</span>).default;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">"css-loader"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">"[name].css"</span>,</span><br><span class="line">            chunkFilename: <span class="string">"[id].css"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLInlineCSSWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式一<code>style-loader</code> <strong>VS</strong> 方式二<code>html-inline-css-webpack-plugin</code> <ul>
<li><code>style-loader</code>是css-in-js，需要加载js后才能写入到style中，有一定的延迟性</li>
<li><code>html-inline-css-webpack-plugin</code>是将css提取出来，再写入到html中，html网页源代码中已经内联好css了，没有延迟性了</li>
<li>请求层面：减少HTTP网络请求数</li>
</ul>
</li>
</ul>
<h4 id="小图片或者字体内联"><a href="#小图片或者字体内联" class="headerlink" title="小图片或者字体内联"></a>小图片或者字体内联</h4><pre><code>url-loader</code></pre><blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack热更新原理</title>
    <url>/2020/12/15/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="webpack热更新plugins配置"><a href="#webpack热更新plugins配置" class="headerlink" title="webpack热更新plugins配置"></a>webpack热更新plugins配置</h4><ul>
<li><strong>webpack-dev-server</strong></li>
</ul>
<blockquote>
<p>开启本地服务器，监听文件变化后，热更新页面;不刷新浏览器而是热更新，不输出文件，而是放在内存中;配合 new.webpack.HotModuleReplacementPlugin() 或 react-hot-loader 插件使用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">webpack-dev-server mode=development -open</span><br><span class="line"><span class="comment">// config</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">        compress: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="string">'3000'</span>,</span><br><span class="line">        contentBase: join(__dirname, <span class="string">'../dist'</span>),<span class="comment">//监听的目录，用于刷新浏览器</span></span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        overlay: &#123;</span><br><span class="line">            errors: <span class="literal">true</span>,</span><br><span class="line">            warnings: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>, <span class="comment">// 设置时，要与output.publicPath保持一致</span></span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// historyApiFallback: &#123;</span></span><br><span class="line">        <span class="comment">//   rewrites: [from: /.*/, to: path.posix.join('/',     // 'index.html')],</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: <span class="string">'http://localhost:8081'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//proxy: &#123;</span></span><br><span class="line">        <span class="comment">//  '/api/*': &#123;</span></span><br><span class="line">        <span class="comment">//     target: 'https://xxx.com',</span></span><br><span class="line">        <span class="comment">//     changeOrigin: true,</span></span><br><span class="line">        <span class="comment">//     secure: false,</span></span><br><span class="line">        <span class="comment">//     headers: &#123;&#125;,</span></span><br><span class="line">        <span class="comment">//     onProxyReq: function(proxyReq, req, res) &#123;</span></span><br><span class="line">        <span class="comment">//       proxyReq.setHeader('origin', 'xxx.com');</span></span><br><span class="line">        <span class="comment">//       proxyReq.setHeader('referer', 'xxx.com');</span></span><br><span class="line">        <span class="comment">//       proxyReq.setHeader('cookie', 'xxxxx');</span></span><br><span class="line">        <span class="comment">//     &#125;,</span></span><br><span class="line">        <span class="comment">//     onProxyRes: function(proxyRes, req, res) &#123;</span></span><br><span class="line">        <span class="comment">//       const cookies = proxyRes.header['set-cookie'];</span></span><br><span class="line">        <span class="comment">//       cookies &amp;&amp; buildCookie(cookies)</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>原理</strong></p>
<ul>
<li><p><code>Webpack Compile</code>: 将JS编译为Bundle</p>
</li>
<li><p><code>HMR Server</code>: 将热更新的文件输出给 HMR Runtime</p>
</li>
<li><p><code>Bundle server</code>: 提供文件在浏览器的访问</p>
</li>
<li><p><code>HMR Runtime</code>: 会被注入到浏览器，更新文件的变化</p>
</li>
<li><p><code>bundle.js</code>: 构建输出的文件</p>
<blockquote>
<p>HMR: Hot Module Replacement </p>
</blockquote>
<p><img src="http://i.feidom.com/hmr.jpg" alt="webpack热更新原理图"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>react知识Q&amp;A</title>
    <url>/2020/12/04/react%E7%9F%A5%E8%AF%86Q&amp;A/</url>
    <content><![CDATA[<p><strong>qa的关键在于回答时注意知识可扩展的深度和广度，基本从“</strong>是什么<strong>”，“为什么”，“怎么做”三个方面来回答</strong></p>
<h4 id="Q-说说什么是react？"><a href="#Q-说说什么是react？" class="headerlink" title="Q:说说什么是react？"></a>Q:说说什么是react？</h4><blockquote>
<p>题解：react的诞生背景<br>  2005年 jquery诞生，浏览器兼容是当时最大的问题。不算框架，只算是工具函数合集。仍不能解决代码复用问题和工程化问题。<br>  2009年 angularJs带着后台java开发的思想横空出世，前端项目工程化双向绑定给当时的中台系统带来了巨大的便利，但是angular臃肿，需要学习很多angular概念，成本高。<br>  2010年 backbonejs出现，既兼容jquery，又有很好的mvc工程化管理，在前端风靡一时。<br>  2013年 reactjs诞生，react的虚拟dom，组件式开发，完美的实现了视图开发中组合优于继承的思想，很大程度上解决了开发复用的问题<br>  2014年 vue诞生</p>
</blockquote>
<p><font color=red size=5>A: </font><br>   <strong>是什么</strong>：react是一个用于构建用户界面的javascript库；<br>   <strong>优点</strong>: 声明式、组件化、通用性<br>         声明式：编写代码更直观更简洁<br>         组件化：提高代码复用率，实现高内聚，低耦合的设计原则<br>         通用性：一次学习，随处编写。react实现了虚拟dom层，程序不会直接操作dom，依据domdiff处理视图改变。支持虚拟dom层的技术栈，都能用react进行前端处理。<br>   <strong>缺点</strong>：react并没有支持前端全部解决方案，而是交给社区来实现，所以react的社区很活跃。但是带来了学习东西多的高学习成本。</p>
<h4 id="Q-说说react为什么选择了jsx语法"><a href="#Q-说说react为什么选择了jsx语法" class="headerlink" title="Q:说说react为什么选择了jsx语法"></a>Q:说说react为什么选择了jsx语法</h4><blockquote>
<p>题解：也就是在问，为什么没有选择其他方案<br>        其他方案有：vue在用的模板语法，模板字符串，jxon语法</p>
</blockquote>
<p><font color=red size=5>A: </font><br>   <strong>是什么</strong>：jsx语法是javacsript的扩展。jsx会被babel编译为React.createElement(),是React.createElement()的语法糖，通过类似XML的描述方式，描写函数对象。<br>   <strong>优点</strong>：更简洁更直观，更贴近原生html。贴近reac“关注点分离”的思想。<br>   对比其他方案：<br>      模板语法：分离了技术栈，引入了不该称为关注点的模板概念：模板指令，模板语法等。不符合react的设计思想<br>      模板字符串：使代码变得更复杂，字符串编写，不利于语法提示<br>      jxon：类似jsx语法，但是因为大括号的语法提示问题<br>  所以react选择了jsx，因为jsx与其设计理念贴合，不需要引入过多的概念，对代码提示也很友好，最适合react。</p>
<h4 id="Q-React-的请求应该放在哪里，为什么"><a href="#Q-React-的请求应该放在哪里，为什么" class="headerlink" title="Q:React 的请求应该放在哪里，为什么?"></a>Q:React 的请求应该放在哪里，为什么?</h4><ul>
<li>对于异步请求，应该放在 componentDidMount 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择：</li>
<li>constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了。</li>
<li>componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。</li>
</ul>
<p><font color=red size=5>A: </font>所以React 的请求放在 componentDidMount 里是最好的选择。</p>
<h4 id="Q：社区中去除类组件constructor的原因"><a href="#Q：社区中去除类组件constructor的原因" class="headerlink" title="Q：社区中去除类组件constructor的原因"></a>Q：社区中去除类组件<code>constructor</code>的原因</h4><blockquote>
<p>constructor之前主要用于初始化组件的一些state状态，现在直接将状态写在顶部<br><code>state = {count: 0}</code>不再写在constructor中</p>
</blockquote>
<p><font color=red size=5>A:</font></p>
<ul>
<li>constructor 中不推荐处理处理初始化以外的逻辑</li>
<li>constructor 本身只是class的初始化函数，并不属于react生命周期</li>
<li>移除 constructor 后，代码更简洁</li>
</ul>
<h4 id="Q-setState是同步更新还是异步更新"><a href="#Q-setState是同步更新还是异步更新" class="headerlink" title="Q:setState是同步更新还是异步更新"></a>Q:setState是同步更新还是异步更新</h4><blockquote>
<p>题解：是A还是B这种问题，不要想当然的回答，这种问题可能在不同场景中有不同的选择</p>
</blockquote>
<ul>
<li>可能是A</li>
<li>可能是B</li>
<li>A和B同时存在</li>
</ul>
<p>setState用于更新组件状态，触发组件重新渲染，更新视图UI</p>
<ul>
<li><p>先了解下<strong>合成事件</strong><br> 基于 事件委托 思想, 在React @17.0前</p>
<ol>
<li>React给<code>document(HTML)</code>挂上事件监听</li>
<li>Dom事件触发后冒泡到<code>document(HTML)</code></li>
<li>React找到对应的组件，造出一个<strong>合成事件</strong></li>
<li>按组件树模拟一遍事件冒泡<br>所以一个页面中只能有一个版本的React，多个版本的话，事件就乱套了<br><a class="link"   href="mailto:React@17.0" >React@17.0<i class="fas fa-external-link-alt"></i></a>后，事件委托对象由<code>document(HTML)</code>更改为<code>Dom容器(ReactDOM.render()所调用的节点)</code>上</li>
</ol>
</li>
<li><p>异步场景</p>
<ul>
<li>一般情况下，setState是异步的。<br>React的<em>setState执行更像一个队列，执行时根据队列一一执行，合并state数据。完成后执行回调</em>，根据结果更新虚拟Dom触发渲染</li>
<li>为什么是异步的？<br> 官方回复看<a class="link"   href="https://github.com/facebook/react/issues/11527#issuecomment-360199710"  target="_blank" rel="noopener">这里<i class="fas fa-external-link-alt"></i></a><ol>
<li>保持内部的一致性</li>
<li>为后续的架构升级启用并发更新</li>
</ol>
</li>
</ul>
</li>
<li><p>同步场景<br> 在 addEventListener、 setTimeout、 setInterval这些原生事件中会同步更新</p>
</li>
<li><p>setState的工作原理<br> <img src="https://s0.lgstatic.com/i/image2/M01/01/47/Cip5yF_YYfCAXIxiAAEJsQbj_hs785.png" alt="setState"><br> <img src="https://s0.lgstatic.com/i/image2/M01/01/3E/CgpVE1_YU2KAStLdAAFVKxh7Dyg317.png" alt="setState"><br><font color=red size=5>A：</font><br> setState 并非真异步，只是看上去像异步。在源码中，通过 isBatchingUpdates 来判断<br> setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p>
<p> 那么什么情况下 isBatchingUpdates 会为 true 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p>
<p> 但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p>
<p> 一般认为，做异步设计是为了性能优化、减少渲染次数，React 团队还补充了两点。</p>
<p> 保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</p>
<p> 启用并发更新，完成异步渲染。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4基础</title>
    <url>/2020/11/25/webpack4%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>yarn add webpack webpack-cli</code></p>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><ul>
<li><strong>entry</strong>  依赖入口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">'&#123;path&#125;/app.js'</span> <span class="comment">//单入口 SPA</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">'&#123;path&#125;/app.js'</span>,</span><br><span class="line">    otherapp: <span class="string">'&#123;path&#125;/otherapp.js'</span></span><br><span class="line">&#125; <span class="comment">//多入口 MPA</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>output</strong>  指定打包后的输出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__diranme,<span class="string">'dist'</span>)</span><br><span class="line">    filename: <span class="string">'[name].js'</span> <span class="comment">// 单入口可以写死文件名，多入口一定要使用占位符[name]，来自动生成多个文件</span></span><br><span class="line">    <span class="comment">// filename: '[name].[chunkhash:5]]js'</span></span><br><span class="line">    <span class="comment">// filename: '[name].[hash]js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Loaders</strong> 解析器</p>
<ul>
<li><p>webpack本身只支持js和json两种文件类型，其他类型的文件需要各种<code>Loaders</code>支持，转化为有效的模块。</p>
</li>
<li><p>本身是一个函数，接受源文件作为参数，返回转换的结果</p>
</li>
<li><p>常用loaders</p>
<table>
<thead>
<tr>
<th align="left">loader</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ts-loader</td>
<td align="left">加载解析ts文件</td>
</tr>
<tr>
<td align="left">babel-loader</td>
<td align="left">在webpack中使用babel解析ES6</td>
</tr>
<tr>
<td align="left">css-loader/less-loader/scss-loader</td>
<td align="left">css/less/sass解析器</td>
</tr>
<tr>
<td align="left">cstyle-loader</td>
<td align="left">将样式通过 style 标签，插入到 head 中</td>
</tr>
<tr>
<td align="left">url-loader/file-loader</td>
<td align="left">处理文件，图片、字体、多媒体 url-loader 实现较小的图片转成base64，插入到代码中，当超过限制的limit后，会自动降级到file-loader</td>
</tr>
<tr>
<td align="left">raw-loader</td>
<td align="left">将.txt文件以字符串的形式导入</td>
</tr>
<tr>
<td align="left">thread-loader</td>
<td align="left">多进程打包js和css</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">// 解析ES6,app根目录要配置.babelrc，如下面的.babelrc</span></span><br><span class="line">        &#123;<span class="attr">test</span>: <span class="regexp">/.js?x$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125; <span class="comment">// exclude 除去node_modules里的文件</span></span><br><span class="line">        <span class="comment">// 将.txt文件以字符串的形式导入</span></span><br><span class="line">        &#123;<span class="attr">test</span>: <span class="regexp">/.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span>&#125;,</span><br><span class="line">        <span class="comment">// 匹配sass/css文件，用对应的loader处理文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.s?css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">            isDev ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    importLoaders: <span class="number">1</span>,</span><br><span class="line">                    <span class="comment">// css模块化使用</span></span><br><span class="line">                    modules: &#123;</span><br><span class="line">                        localIdentName: <span class="string">'[path][name]__[local]--[hash:base64:5]'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 预处理器, autoprefixer(需要安装)</span></span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    plugins: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                            browsers: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios7'</span>]</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'sass-loader'</span>,</span><br><span class="line">            <span class="comment">// px自动转rem</span></span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    remUnit: <span class="number">75</span>, <span class="comment">// 一个rem等于多少px</span></span><br><span class="line">                    remPrecision: <span class="number">8</span> <span class="comment">// px转换成rem的小数位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ],</span><br><span class="line">            include: [],</span><br><span class="line">            exclude: [</span><br><span class="line">                Root(<span class="string">'src/components'</span>)</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|jpeg|gif|eot|woff|woff2|ttf|svg|otf)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 10k</span></span><br><span class="line">                        name: isDev ? <span class="string">'images/[name].[ext]'</span> : <span class="string">'images/[name].[hash.[ext]'</span>,</span><br><span class="line">                        publicPath: idDev ? <span class="string">'/'</span> : <span class="string">'cdn地址'</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// prduction，用于图片压缩</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        bypassOnDebug: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">        <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="comment">// 各种插件</span></span><br><span class="line">        <span class="string">"@babel/propsoal-class-properties"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>plugins</strong> 插件<br>  插件用于bundle文件的优化，资源管理和环境变量注入，作用于整个构建过程</p>
<ul>
<li>webpack-dev-server 热更新<br>  详情请关注<a href="/2020/12/15/webpack热更新原理/">webpack热更新原理</a></li>
<li>webpack-dev-middleware <blockquote>
<p>将webpack输出文件传输给服务器，适用于灵活的定制场景</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = requrie(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = requrie(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">    publicPath: config.output.publicPath</span><br><span class="line">&#125;))</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure></li>
<li>mini-css-extract-plugin和optimize-css-assets-webpack-plugin<blockquote>
<p>提取css，建议使用contenthash</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.s?css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">            isDev ? <span class="string">'style-loader'</span> : iniCssExtractPlugin.loader</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                importLoaders: <span class="number">1</span>,</span><br><span class="line">                <span class="comment">// css模块化使用</span></span><br><span class="line">                modules: &#123;</span><br><span class="line">                    localIdentName: <span class="string">'[path][name]__[local]--[hash:base64:5]'</span></span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'postcss-loader'</span>,</span><br><span class="line">            <span class="string">'sass-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 提取css</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'styles/[name].[contenthash:5].css'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// 压缩css</span></span><br><span class="line">        <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">            assetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">            cssProcessor: <span class="built_in">require</span>(<span class="string">"cssnano"</span>),<span class="comment">//需要安装cssnano</span></span><br><span class="line">            cssProcessorPluginOptions: &#123;</span><br><span class="line">            preset: [</span><br><span class="line">                <span class="string">'default'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                discardComments: &#123;</span><br><span class="line">                    removeAll: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">            &#125;,</span><br><span class="line">            canPrint: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li>
<li>html-webpack-plugin <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 自定义参数title传递到html中</span></span><br><span class="line">        <span class="comment">// html中使用&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">        <span class="comment">// &lt;script&gt;let number = &lt;%= htmlWebpackPlugin.options.number %&gt;&lt;script&gt;</span></span><br><span class="line">        number: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'京程一灯'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>,</span><br><span class="line">        <span class="comment">// chunks: ['index'] //用于多页面，使用哪些chunk</span></span><br><span class="line">        template: resolve(__dirname, <span class="string">'/src/index.html'</span>),</span><br><span class="line">        minify: &#123;</span><br><span class="line">        minifyJS: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>,</span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">        preserveLineBreak: <span class="literal">false</span>,</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">        removeComments: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>clean-webpack-plugin 或者使用 rimraf dist<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>mode</strong> </p>
<ul>
<li><p>用来指定当前构建环境 development、production 和 none</p>
</li>
<li><p>设置 mode 可以使用 wepack内置函数，内部自动开启一些配置项，默认值为 production</p>
<p>内置功能<br>development：process.env.NODE_ENV为development,开启NamedChunksPlugin 和 NameModulesPlugin<br>这两个插件用于热更新，控制台打印路径<br>prodution：process.env.NODE_ENV为prodution.开启 FlagDependencyUsagePlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin，OccurrentceOrderPlugin、SideEffectsFlagPlugin等<br>none：不开启任何优化选项</p>
</li>
</ul>
</li>
<li><p><strong>watch</strong> </p>
<ul>
<li>文件监听可以在webpack命令后加上 –watch 参数，或在webpack.config中设置watch:true。 </li>
<li>原理：轮询判断文件的最后编辑时间是否变化<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 默认false，不开启</span></span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 只有开启时，watchOptions才有意义</span></span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        <span class="comment">// 忽略，支持正则</span></span><br><span class="line">        ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// 监听到变化后等300ms再执行，默认300ms</span></span><br><span class="line">        aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">        <span class="comment">// 怕乱文件是否变化是通过不停询问系统指定文件有没变化实现的，默认每秒1000次</span></span><br><span class="line">        poll: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>文件指纹</p>
<ul>
<li>打包后输出文件名后缀，也就是hash值</li>
<li>hash：和整个项目构建相关，只要项目中有一个文件修改，整个项目中的文件hash都会修改成统一的一个</li>
<li>chunkhash：和webpck打包的chunk有关，不同的entry会生成不同的chunkhash值（适用于js文件）</li>
<li>contenthash：根据文件内容定义hash，文件内容不变，则contenthash不变，用于批量更新（适用于css文件）</li>
</ul>
</li>
<li><p>优化命令行日志</p>
<ul>
<li>统计信息 stats，webpack属性，这种方式不好<br>  error-only：值发生错误时输出<br>  minimal：只在发生错误或有新的编译时输出<br>  none：没有输出<br>  normal：标准输出，默认<br>  verbose：全部输出<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// development</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    stats: <span class="string">'errors-only'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    stats: <span class="string">'errors-only'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>stats结合friendly-errors-webpack-plugin（推荐）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsPlugin()</span><br><span class="line">],</span><br><span class="line">stats: <span class="string">'errors-only'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构建异常和中断处理</p>
<ul>
<li><p>wepback4之前的版本构建失败不会跑出错误码</p>
</li>
<li><p>node中的process.exit规范<br>  0 表示成功完成，回调函数中，err 为 null<br>  非0 表示执行失败，回调函数中，err 不为空，err.code就是传给exit的数字</p>
</li>
<li><p>主动捕获错误，并处理构建错误</p>
<ul>
<li>写个插件，compiler 在每次构建结束后会出发done这个hook</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// webpack3 this.plugin('done', (stats) =&gt; &#123;&#125;)</span></span><br><span class="line">        <span class="comment">// webpack4</span></span><br><span class="line">        <span class="keyword">this</span>.hooks.done.tap(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf(<span class="string">'--watch'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'build error'</span>);</span><br><span class="line">            <span class="comment">// dosomething</span></span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;    </span><br><span class="line">]</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<blockquote>
<p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue定义全局方法</title>
    <url>/2020/11/05/vue%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、将方法挂在到vue原型-Vue-prototype-上"><a href="#一、将方法挂在到vue原型-Vue-prototype-上" class="headerlink" title="一、将方法挂在到vue原型(Vue.prototype)上"></a>一、将方法挂在到vue原型(Vue.prototype)上</h3><ul>
<li><p>定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global.js</span></span><br><span class="line"><span class="keyword">const</span> Func = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    Func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js中配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> global <span class="keyword">from</span> <span class="string">'@/global'</span></span><br><span class="line">object.keys(global).forEach(<span class="function">(<span class="params">key</span>)=&gt;</span>&#123;</span><br><span class="line">    Vue.prototype[<span class="string">'$global'</span> + key] = global[key]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="keyword">this</span>.$globalFunc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点，调用的时候，没有方法提示</p>
</blockquote>
</li>
</ul>
<h3 id="二、全局混入mixin"><a href="#二、全局混入mixin" class="headerlink" title="二、全局混入mixin"></a>二、全局混入mixin</h3><ul>
<li>定义：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixin.js</span></span><br><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        func()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin</span><br></pre></td></tr></table></figure></li>
<li>在main.js中配置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">'@/mixin'</span></span><br><span class="line">Vue.mixin(mixin)</span><br></pre></td></tr></table></figure></li>
<li>在vue文件中使用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="keyword">this</span>.func()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mixin里的methods会和创建的每个单文件组件合并，调用方法时有提示</p>
</blockquote>
</li>
</ul>
<h3 id="三、使用Plugin"><a href="#三、使用Plugin" class="headerlink" title="三、使用Plugin"></a>三、使用Plugin</h3><blockquote>
<p>Vue.use的实现本身没有挂载功能，只是触发了插件的install方法，本质上还是使用了<code>Vue.prototype</code></p>
</blockquote>
<ul>
<li><p>定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugin.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> plugin = &#123;</span><br><span class="line">    <span class="comment">// install是plugin中默认的方法</span></span><br><span class="line">    <span class="comment">// 当外界在use这个组件或函数的时候，就会调用本身的install方法，同时传入一个Vue这个类的参数</span></span><br><span class="line">    install: <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">        Vue.prototype.$pluginGlobalFunc = func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js中配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> plugin <span class="keyword">from</span> <span class="string">'@/plugin'</span></span><br><span class="line">Vue.use(plugin)</span><br></pre></td></tr></table></figure></li>
<li><p>在vue文件中使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="keyword">this</span>.$pluginGlobalFunc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mixin里的methods会和创建的每个单文件组件合并，调用方法时有提示</p>
</blockquote>
</li>
</ul>
<h3 id="四任意vue文件中写全局函数"><a href="#四任意vue文件中写全局函数" class="headerlink" title="四任意vue文件中写全局函数"></a>四任意vue文件中写全局函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$on(<span class="string">'func'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'global'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 销毁全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$off(<span class="string">'func'</span>);</span><br><span class="line"><span class="comment">// 调用全局方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.$emit(<span class="string">'func'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本章内容主要来自京城一灯</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用svg图标</title>
    <url>/2020/11/03/vue%E4%B8%AD%E4%BD%BF%E7%94%A8svg%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<h3 id="对svg图标的简单实用和认识"><a href="#对svg图标的简单实用和认识" class="headerlink" title="对svg图标的简单实用和认识"></a>对svg图标的简单实用和认识</h3><p><a href="/2020/07/04/svg图标的使用/">svg图标的使用</a></p>
<h3 id="在Vue项目中写一个svg组件"><a href="#在Vue项目中写一个svg组件" class="headerlink" title="在Vue项目中写一个svg组件"></a>在Vue项目中写一个svg组件</h3><ul>
<li>安装<a class="link"   href="https://www.npmjs.com/package/svg-sprite-loader"  target="_blank" rel="noopener">svg-sprite-loader<i class="fas fa-external-link-alt"></i></a>插件对svg文件进行编译解析<br>  <code>yarn add svg-sprite-loader</code></li>
<li>在<code>src/assets/</code>目录下新建<code>icons</code>目录，存放需要用到的svg图标</li>
<li>在vue-cli4中，对<code>vue.config.js</code>进行配置  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// set svg-sprite-loader</span></span><br><span class="line">    <span class="comment">// 第一步：让其他svg loader不要对svg进行操作</span></span><br><span class="line">    config.module</span><br><span class="line">    .rule(<span class="string">'svg'</span>)</span><br><span class="line">    .exclude.add(path.join(__dirname, <span class="string">'src/assets/icons'</span>))</span><br><span class="line">    .end()</span><br><span class="line">    <span class="comment">// 第二步：使用svg-sprite-loader 对svg进行操作</span></span><br><span class="line">    config.module</span><br><span class="line">    .rule(<span class="string">'icons'</span>)</span><br><span class="line">    .test(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">    .include.add(path.join(__dirname, <span class="string">'src/assets/icons'</span>))</span><br><span class="line">    .end()</span><br><span class="line">    .use(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">    .loader(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">    <span class="comment">//定义规则 使用时 &lt;svg class="icon"&gt; &lt;use xlink:href="#icon-svg文件名"&gt;&lt;/use&gt;&lt;/svg&gt;</span></span><br><span class="line">    .options(&#123;</span><br><span class="line">        symbolId: <span class="string">'icon-[name]'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是vue-cli2中，配置<code>build/webpack.base.conf.js</code>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">                loader: <span class="string">"svg-sprite-loader"</span>,</span><br><span class="line">                include: [resolve(<span class="string">"src/assets/icons"</span>)],</span><br><span class="line">                options: &#123;</span><br><span class="line">                symbolId: <span class="string">"icon-[name]"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">                loader: <span class="string">"url-loader"</span>,</span><br><span class="line">                exclude: [resolve(<span class="string">"src/assets/icons"</span>)],</span><br><span class="line">                options: &#123;</span><br><span class="line">                limit: <span class="number">10000</span>,</span><br><span class="line">                name: utils.assetsPath(<span class="string">"img/[name].[hash:7].[ext]"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在icons目录下，新建<code>index.js</code>文件  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> SvgIcon <span class="keyword">from</span> <span class="string">'@/components/common/svgIcon'</span></span><br><span class="line"><span class="comment">// 全局注册组件</span></span><br><span class="line">Vue.component(<span class="string">'svg-icon'</span>, SvgIcon)</span><br><span class="line"><span class="comment">// 定义一个加载目录的函数</span></span><br><span class="line"><span class="keyword">const</span> requireAll = <span class="function"><span class="params">requireContext</span> =&gt;</span> &#123;</span><br><span class="line">    requireContext.keys().map(requireContext)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">'@/assets/icons'</span>, <span class="literal">false</span>, /\.svg$/)</span><br><span class="line"><span class="comment">// 加载目录下的所有 svg 文件</span></span><br><span class="line">requireAll(req)</span><br></pre></td></tr></table></figure></li>
<li>上述<code>index.js</code>中，引用了<code>svgIcon</code>组件，在对应的引用路径下新建<code>svgIcon.vue</code>文件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;svg :class&#x3D;&quot;svgClass&quot; aria-hidden&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;use :xlink:href&#x3D;&quot;iconName&quot;&gt;&lt;&#x2F;use&gt;</span><br><span class="line">    &lt;&#x2F;svg&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;svg-icon&#39;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            &#x2F;&#x2F; 组件样式，可以控制svg图标</span><br><span class="line">            iconClass: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                required: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F; 使用svg文件名的方式使用对应svg图标</span><br><span class="line">            className: &#123;</span><br><span class="line">                type: String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            iconName() &#123;</span><br><span class="line">                return &#96;#icon-$&#123;this.iconClass&#125;&#96;</span><br><span class="line">            &#125;,</span><br><span class="line">            svgClass() &#123;</span><br><span class="line">                if (this.className) &#123;</span><br><span class="line">                    return &#39;svg-icon &#39; + this.className</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#39;svg-icon&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.svg-icon &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin: 4px 6px 0 0;</span><br><span class="line">    width: 13px;</span><br><span class="line">    height: 13px;</span><br><span class="line">    vertical-align: 1px;</span><br><span class="line">    fill: #e1e1e1;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li>在<code>main.js</code>中引入<br>  <code>import &#39;./assets/icons&#39;</code></li>
<li>使用svg-icon  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg-icon</span><br><span class="line">    :iconClass&#x3D;&quot;&#39;download&#39;&quot;   &#x2F;&#x2F;覆盖样式类名</span><br><span class="line">    className&#x3D;&quot;downloadIcon&quot;  &#x2F;&#x2F;文件名</span><br><span class="line">&gt;&lt;&#x2F;svg-icon&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端如何防范xss攻击</title>
    <url>/2020/09/10/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83xss%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h5 id="xss是什么"><a href="#xss是什么" class="headerlink" title="xss是什么"></a>xss是什么</h5><p>  Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p>
<p>  XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>
<h5 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h5><ul>
<li><p>输入过滤</p>
<p>​    输入过滤就在后台接口处理数据时合适，做个数据转义</p>
</li>
<li><p>渲染时处理</p>
<p>​    传统前端，拼接 HTML及使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code>将数据渲染到页面上时，很容易将不可信的问题数据插到页面上。</p>
<p>​    Sdk前端项目，使用Vue框架。Vue框架在渲染前，会将template模板编译为虚拟Dom树，减少了 encode 操作，减少了 XSS 隐患。</p>
</li>
</ul>
<pre><code>但是，使用`v-html`时会有问题，这一点在vue官方文档中有提到：![v-html](http://i.feidom.com/Vhtml.jpg)

解决方案：

  * 尽量使用插值表达式`{{}}`，它会把要显示的内容转为字符串。

  * 如果使用v-html，要保证来自服务端的渲染数据都是安全的。

  * 在使用第三方UI组件库的的时候，要检查一下它们渲染页面的方式，是否使用了 v-html。

  * 有的时候实在绕不开，必须用。那就用[lodash的_.template](https://www.lodashjs.com/docs/lodash.template)做一层字符串逃逸操作，再塞给 v-html 就行。

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var template &#x3D; _.template(&quot;&lt;%- value %&gt;&quot;);</span><br><span class="line">template(&#123;value: &#39;&lt;script&gt;&#39;&#125;);</span><br><span class="line">输出 &#x3D;&#x3D;&gt; &lt;script&gt;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li>在项目中使用第三方库<a class="link"   href="https://www.npmjs.com/package/xss"  target="_blank" rel="noopener">xss<i class="fas fa-external-link-alt"></i></a>,<a class="link"   href="https://github.com/leizongmin/js-xss/blob/master/README.zh.md"  target="_blank" rel="noopener">中文文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用jest问题解决</title>
    <url>/2020/09/03/vue%E4%BD%BF%E7%94%A8jest%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>vue项目中用jest测试时，遇到几个问题，在这记录以下踩的坑，以后爬得快。</p>
<h4 id="SecurityError-localStorage-is-not-available-for-opaque-origins"><a href="#SecurityError-localStorage-is-not-available-for-opaque-origins" class="headerlink" title="SecurityError: localStorage is not available for opaque origins"></a>SecurityError: localStorage is not available for opaque origins</h4><p>详细报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test suite failed to run</span><br><span class="line"></span><br><span class="line">SecurityError: localStorage is not available for opaque origins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">at Window.get localStorage [as localStorage] (node_modules&#x2F;jsdom&#x2F;lib&#x2F;jsdom&#x2F;browser&#x2F;Window.js:257:15)</span><br><span class="line">          at Array.forEach (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>

<p>解决方法：<br>在<code>jest.conf.js</code>文件中，增加配置<code>testURL: &quot;http://localhost/&quot;</code>，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...,</span><br><span class="line">    testURL: &quot;http:&#x2F;&#x2F;localhost&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Handlebars报错"><a href="#Handlebars报错" class="headerlink" title="Handlebars报错"></a>Handlebars报错</h4><p>导致测试报告没有数据展示，详细报错如下：<br><img src="http://i.feidom.com/handlebars_error.png" alt="handlebars报错"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handlebars: Access has been denied to resolve the property &quot;statements&quot; because it is not an &quot;own property&quot; of its parent.</span><br><span class="line">You can add a runtime option to disable the check or this warning:</span><br><span class="line">See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for details</span><br><span class="line">Handlebars: Access has been denied to resolve the property &quot;branches&quot; because it is not an &quot;own property&quot; of its parent.</span><br><span class="line">You can add a runtime option to disable the check or this warning:</span><br><span class="line">See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for details</span><br><span class="line">Handlebars: Access has been denied to resolve the property &quot;functions&quot; because it is not an &quot;own property&quot; of its parent.</span><br><span class="line">You can add a runtime option to disable the check or this warning:</span><br><span class="line">See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for details</span><br><span class="line">Handlebars: Access has been denied to resolve the property &quot;lines&quot; because it is not an &quot;own property&quot; of its parent.</span><br><span class="line">You can add a runtime option to disable the check or this warning:</span><br><span class="line">See https:&#x2F;&#x2F;handlebarsjs.com&#x2F;api-reference&#x2F;runtime-options.html#options-to-control-prototype-access for details</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access"  target="_blank" rel="noopener">报错原因<i class="fas fa-external-link-alt"></i></a>说的很清楚，是Handlebars版本的问题。<br>解决方法：</p>
<ol>
<li>移除node_moudules包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_moudules</span><br></pre></td></tr></table></figure></li>
<li>在package.json文件中，新增<code>&quot;handlebars&quot;: &quot;4.5.0&quot;,</code>这个包,相当于手动添加这个包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">"handlebars"</span>: <span class="string">"4.5.0"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>yarn.lock</code>这个文件中，修改handlebars的包配置和所有依赖handlebars包的包配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlebars@^4.0.3:</span><br><span class="line">    version &quot;4.7.6&quot;</span><br></pre></td></tr></table></figure>
改为==》<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlebars@4.5.0:</span><br><span class="line">  version &quot;4.5.0&quot;</span><br></pre></td></tr></table></figure>
修改依赖handlebars的包的配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istanbul-reports@^1.5.1:</span><br><span class="line">  version &quot;1.5.1&quot;</span><br><span class="line">  resolved &quot;https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;istanbul-reports&#x2F;-&#x2F;istanbul-reports-1.5.1.tgz#97e4dbf3b515e8c484caea15d6524eebd3ff4e1a&quot;</span><br><span class="line">  integrity sha512-+cfoZ0UXzWjhAdzosCPP3AN8vvef8XDkWtTfgaN+7L3YTpNYITnCaEkceo5SEYy644VkHka&#x2F;P1FvkWvrG&#x2F;rrJw&#x3D;&#x3D;</span><br><span class="line">  dependencies:</span><br><span class="line">    handlebars &quot;^4.0.3&quot;</span><br></pre></td></tr></table></figure>
改为==》<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istanbul-reports@^1.5.1:</span><br><span class="line">  version &quot;1.5.1&quot;</span><br><span class="line">  resolved &quot;https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;istanbul-reports&#x2F;-&#x2F;istanbul-reports-1.5.1.tgz#97e4dbf3b515e8c484caea15d6524eebd3ff4e1a&quot;</span><br><span class="line">  integrity sha512-+cfoZ0UXzWjhAdzosCPP3AN8vvef8XDkWtTfgaN+7L3YTpNYITnCaEkceo5SEYy644VkHka&#x2F;P1FvkWvrG&#x2F;rrJw&#x3D;&#x3D;</span><br><span class="line">  dependencies:</span><br><span class="line">    handlebars &quot;4.5.0&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="警告：mapCoverage这个配置应该被移除，因为计算覆盖率的时间并不长"><a href="#警告：mapCoverage这个配置应该被移除，因为计算覆盖率的时间并不长" class="headerlink" title="警告：mapCoverage这个配置应该被移除，因为计算覆盖率的时间并不长"></a>警告：mapCoverage这个配置应该被移除，因为计算覆盖率的时间并不长</h4><ul>
<li><p>详细警告如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deprecation Warning:</span><br><span class="line"></span><br><span class="line">  Option &quot;mapCoverage&quot; has been removed, as it&#39;s no longer necessary.</span><br><span class="line"></span><br><span class="line">  Please update your configuration.</span><br><span class="line"></span><br><span class="line">  Configuration Documentation:</span><br><span class="line">  https:&#x2F;&#x2F;facebook.github.io&#x2F;jest&#x2F;docs&#x2F;configuration.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个配置在jest配置文档中的解释如下：</p>
</li>
</ul>
<p>If you have transformers configured that emit source maps, Jest will use them to try and map code coverage against the original source code when writing reports and checking thresholds. This is done on a best-effort basis as some compile-to-JavaScript languages may provide more accurate source maps than others. This can also be resource-intensive. If Jest is taking a long time to calculate coverage at the end of a test run, try setting this option to false.</p>
<p>Both inline source maps and source maps returned directly from a transformer are supported. Source map URLs are not supported because Jest may not be able to locate them. To return source maps from a transformer, the process function can return an object like the following. The map property may either be the source map object, or the source map object as a JSON string.</p>
<p>大致意思是：<br>*如果您配置了发出源映射的转换器，那么在编写报告和检查阈值时，Jest将使用它们来尝试将代码覆盖率映射到原始源代码上。这样做需要付出最大的努力，因为一些编译到javascript的语言可能比其他语言提供更准确的源映射。这也可以是资源密集型的。如果Jest在测试运行结束时花费很长时间来计算覆盖率，请尝试将此选项设置为false。</p>
<p>支持内联源映射和从转换器直接返回的源映射。不支持源映射url，因为Jest可能无法定位它们。要从转换器返回源映射，process函数可以返回如下所示的对象。map属性可以是源映射对象，也可以是JSON字符串形式的源映射对象。</p>
<ul>
<li>解决方法：<br>在<code>jest.conf.js</code>文件中，移除<code>mapCoverage:true</code>这个配置。</li>
</ul>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>ast抽象语法树</title>
    <url>/2020/08/31/ast%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
    <content><![CDATA[<p>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。— 《你不知道的js(上)》</p>
<h3 id="代码执行前的步骤-编译"><a href="#代码执行前的步骤-编译" class="headerlink" title="代码执行前的步骤-编译"></a>代码执行前的步骤-编译</h3><p>下图是简易的重点流程，实际js的编译要复杂的多</p>
<ul>
<li>词法分析（扫描scanner）<br>  这个过程将由字符组成的字符串分解为有意义的代码块，这些代码块叫“词法单元”。<br>  如： <code>let a = 2;</code> 将被分析为<code>[let, a, =, 2]</code>这些词法单元。空格算不算取决于空格在这门语言中是否有意义<blockquote>
<p><a class="link"   href="https://github.com/antlr/grammars-v4"  target="_blank" rel="noopener">grammars-v4<i class="fas fa-external-link-alt"></i></a>中有所有语言的语法规则，也包括js。</p>
</blockquote>
</li>
<li>语法分析（解析器）<br>  这个过程是将词法单元流（数组，通俗的讲，处理过程就是个for循环）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为<strong>“抽象语法树”</strong><code>Abstract Syntax Tree，AST</code>。</li>
<li>代码生成<br>  将生成的ast转化为可执行代码的过程。</li>
</ul>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p><a class="link"   href="https://astexplorer.net/"  target="_blank" rel="noopener">AST Explorer<i class="fas fa-external-link-alt"></i></a>提供了很多不同的ast生成规则可用来学习<br>例如: 编译javascript时的<code>var a = 1;</code>将生成如下抽象语法树</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: "Program",   // 程序</span><br><span class="line">    start: 0,</span><br><span class="line">    end: 10,</span><br><span class="line">    body: [</span><br><span class="line">        &#123;  <span class="comment">// VariableDeclaration</span></span><br><span class="line">            type: "VariableDeclaration",    // 变量声明</span><br><span class="line">            start: 0,</span><br><span class="line">            end: 10,</span><br><span class="line">            declarations: [</span><br><span class="line">                &#123; <span class="comment">// VariableDeclarator   // 变量声明者</span></span><br><span class="line">                    type: "VariableDeclarator",</span><br><span class="line">                    start: 4,</span><br><span class="line">                    end: 9,</span><br><span class="line">                    id: &#123; // Identifier     声明a</span><br><span class="line">                        type: "Identifier",</span><br><span class="line">                        start: 4,</span><br><span class="line">                        end: 5,</span><br><span class="line">                        name: "a"</span><br><span class="line">                    &#125;,</span><br><span class="line">                    init:&#123;          // 将a的值初始化为 1 </span><br><span class="line">                        type: "Literal",</span><br><span class="line">                        start: 8,</span><br><span class="line">                        end: 9,</span><br><span class="line">                        value: 1,</span><br><span class="line">                        raw: "1"</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            kind: "var"</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    sourceType: "module"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><ul>
<li>bable的编译使用了AST。</li>
<li>在vue3的模板语法编译，定义了自己的一套语法规则，使用AST大大提高了性能</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a class="link"   href="https://www.npmjs.com/package/recast"  target="_blank" rel="noopener">recast<i class="fas fa-external-link-alt"></i></a>是一个ast的工具，使用它可以查看ast，更换语法规则等。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用vueChartJs</title>
    <url>/2020/08/26/vue%E4%B8%AD%E4%BD%BF%E7%94%A8vueChartJs/</url>
    <content><![CDATA[<h3 id="vue-chartJs"><a href="#vue-chartJs" class="headerlink" title="vue-chartJs"></a>vue-chartJs</h3><p><a class="link"   href="https://vue-chartjs.org/zh-cn/"  target="_blank" rel="noopener">vue-chartJs<i class="fas fa-external-link-alt"></i></a>是vue对<a class="link"   href="http://chartjs.cn/"  target="_blank" rel="noopener">Chart.js<i class="fas fa-external-link-alt"></i></a>的封装,可以很简单的创建可复用的图表组件。由于是对底层的封装，所以许多图表的配置，还是需要看这个<a class="link"   href="http://chartjs.cn/docs/"  target="_blank" rel="noopener">Chart.js的文档<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="先简单封装个组件"><a href="#先简单封装个组件" class="headerlink" title="先简单封装个组件"></a>先简单封装个组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vBar.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">'vue-chartjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'vBar'</span>,</span><br><span class="line">  extends: Bar,</span><br><span class="line">  props: [<span class="string">'chartdata'</span>, <span class="string">'options'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.renderChart(<span class="keyword">this</span>.chartdata,<span class="keyword">this</span>.options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在需要的地方用这个组件"><a href="#在需要的地方用这个组件" class="headerlink" title="在需要的地方用这个组件"></a>在需要的地方用这个组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"example-3d"</span>&gt;</span><br><span class="line">	&lt;vBar :chartdata=<span class="string">"vBarData"</span> :options=<span class="string">"vOptions"</span> :styles=<span class="string">"myStyles"</span>&gt;&lt;<span class="regexp">/vBar&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123; vBar &#125; from '@/</span>components/vCharts/vBar<span class="string">'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">	name: '</span>barTest<span class="string">',</span></span><br><span class="line"><span class="string">	components: &#123;</span></span><br><span class="line"><span class="string">		vBar,</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">	data() &#123;</span></span><br><span class="line"><span class="string">		return &#123;</span></span><br><span class="line"><span class="string">			vBarData: &#123;</span></span><br><span class="line"><span class="string">				labels: ['</span><span class="number">1</span><span class="string">', '</span><span class="number">2</span><span class="string">', '</span><span class="number">3</span><span class="string">', '</span><span class="number">4</span><span class="string">', '</span><span class="number">5</span><span class="string">', '</span><span class="number">6</span><span class="string">'],</span></span><br><span class="line"><span class="string">				datasets: [</span></span><br><span class="line"><span class="string">					&#123;</span></span><br><span class="line"><span class="string">						data: [1,2,3,4,5,6],</span></span><br><span class="line">						backgroundColor: '#ffa200',</span><br><span class="line">						barPercentage: <span class="number">1</span>,</span><br><span class="line">						maxBarThickness: <span class="number">12</span>,</span><br><span class="line">					&#125;,</span><br><span class="line">				],</span><br><span class="line">			&#125;,</span><br><span class="line">			vOptions: &#123;</span><br><span class="line">                <span class="comment">// 自适应必须要加的下面两个配置</span></span><br><span class="line">                responsive: <span class="literal">true</span>,</span><br><span class="line">                maintainAspectRatio: <span class="literal">false</span>,</span><br><span class="line">				layout: &#123;</span><br><span class="line">					padding: &#123;</span><br><span class="line">						left: <span class="number">5</span>,</span><br><span class="line">						right: <span class="number">5</span>,</span><br><span class="line">						top: <span class="number">5</span>,</span><br><span class="line">						bottom: <span class="number">5</span>,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">				legend: &#123; <span class="attr">display</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">				scales: &#123;</span><br><span class="line">					grid: &#123;</span><br><span class="line">						x: <span class="number">10</span>,</span><br><span class="line">						x2: <span class="number">20</span>,</span><br><span class="line">						y: <span class="number">20</span>,</span><br><span class="line">						y2: <span class="number">10</span>,</span><br><span class="line">					&#125;,</span><br><span class="line">					xAxes: [</span><br><span class="line">						&#123;</span><br><span class="line">							gridLines: &#123;</span><br><span class="line">								display: <span class="literal">false</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">							ticks: &#123;</span><br><span class="line">								display: <span class="literal">false</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					],</span><br><span class="line">					yAxes: [</span><br><span class="line">						&#123;</span><br><span class="line">							gridLines: &#123;</span><br><span class="line">								display: <span class="literal">false</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">							ticks: &#123;</span><br><span class="line">								display: <span class="literal">false</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					],</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		myStyles() &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				height: <span class="string">'100px'</span>,</span><br><span class="line">                <span class="comment">// 自适应必须要加的position: 'relative',</span></span><br><span class="line">                position: <span class="string">'relative'</span>,</span><br><span class="line">                marginTop: <span class="string">'200px'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	mounted() &#123;&#125;,</span><br><span class="line">	created() &#123;&#125;,</span><br><span class="line">	methods: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="vue-chartJs的自适应resize"><a href="#vue-chartJs的自适应resize" class="headerlink" title="vue-chartJs的自适应resize"></a>vue-chartJs的自适应resize</h3><ul>
<li>v-chart配置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Options: &#123;</span><br><span class="line">    responsive: <span class="literal">true</span>,</span><br><span class="line">    maintainAspectRatio: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组件实例绑定styles属性<code>:styles=&quot;myStyles&quot;</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myStyles() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 自适应必须要加的position: 'relative',</span></span><br><span class="line">        position: <span class="string">'relative'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>图表</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用swiper</title>
    <url>/2020/08/25/vue%E4%BD%BF%E7%94%A8swiper/</url>
    <content><![CDATA[<h3 id="在vue项目中使用swiper-js"><a href="#在vue项目中使用swiper-js" class="headerlink" title="在vue项目中使用swiper.js"></a>在vue项目中使用swiper.js</h3><p>有一个专业vue封装库的<code>vue-awesome-swiper.js</code>,在vue项目中使用时，需要把这个包也装上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add swiper@5.3.6 vue-awesome-swiper@4.1.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面装包时指定版本，是因为在项目中踩坑了。装了新包不能用。于是查看vue-awesome-swiper<a class="link"   href="https://github.com/surmon-china/surmon-china.github.io"  target="_blank" rel="noopener">在github上的示例代码<i class="fas fa-external-link-alt"></i></a>，发现<code>swiper@5.3.6 vue-awesome-swiper@4.1.0</code>，装包后可以使用</p>
</blockquote>
<h3 id="使用demo"><a href="#使用demo" class="headerlink" title="使用demo"></a>使用demo</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"example-3d"</span>&gt;</span><br><span class="line">		&lt;swiper <span class="class"><span class="keyword">class</span></span>=<span class="string">"swiper"</span> :options=<span class="string">"swiperOption"</span>&gt;</span><br><span class="line">			&lt;swiper-slide v-<span class="keyword">for</span>=<span class="string">"(item, index) in colorList"</span> :key=<span class="string">"index"</span> :style=<span class="string">"'background: '+item"</span>&gt;Slide &#123;&#123;index&#125;&#125;&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>swiper&gt;</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; Swiper, SwiperSlide &#125; <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	name: <span class="string">'swiper-example-3d-coverflow'</span>,</span><br><span class="line">	title: <span class="string">'3D Coverflow effect'</span>,</span><br><span class="line">	components: &#123;</span><br><span class="line">		Swiper,</span><br><span class="line">		SwiperSlide,</span><br><span class="line">	&#125;,</span><br><span class="line">	data() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">            colorList:[<span class="string">'#c82829'</span>,<span class="string">'#f5871f'</span>,<span class="string">'#eab700'</span>,<span class="string">'#718c00'</span>,<span class="string">'#3e999f'</span>],</span><br><span class="line">			swiperOption: &#123;</span><br><span class="line">				initialSlide: <span class="number">1</span>,</span><br><span class="line">				virtualTranslate: <span class="literal">true</span>,</span><br><span class="line">				effect: <span class="string">'coverflow'</span>,</span><br><span class="line">				grabCursor: <span class="literal">false</span>,</span><br><span class="line">				centeredSlides: <span class="literal">true</span>,</span><br><span class="line">				slidesPerView: <span class="string">'auto'</span>,</span><br><span class="line">				coverflowEffect: &#123;</span><br><span class="line">					rotate: <span class="number">10</span>,</span><br><span class="line">					stretch: <span class="number">0</span>,</span><br><span class="line">					depth: <span class="number">10</span>,</span><br><span class="line">					modifier: <span class="number">1</span>,</span><br><span class="line">					slideShadows: <span class="literal">false</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				on: &#123;</span><br><span class="line">					click: <span class="function"><span class="keyword">function</span> (<span class="params">swiper, event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">				slideToClickedSlide: <span class="literal">true</span>,</span><br><span class="line">				slidesPerView: <span class="number">5</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss" scoped&gt;</span></span><br><span class="line"><span class="regexp">.example-3d &#123;</span></span><br><span class="line"><span class="regexp">	width: 100%;</span></span><br><span class="line"><span class="regexp">	height: 400px;</span></span><br><span class="line"><span class="regexp">	padding-top: 50px;</span></span><br><span class="line"><span class="regexp">	padding-bottom: 50px;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">.swiper &#123;</span></span><br><span class="line"><span class="regexp">	height: 100%;</span></span><br><span class="line"><span class="regexp">	width: 100%;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	.swiper-slide &#123;</span></span><br><span class="line"><span class="regexp">		display: flex;</span></span><br><span class="line"><span class="regexp">		justify-content: center;</span></span><br><span class="line"><span class="regexp">		align-items: center;</span></span><br><span class="line"><span class="regexp">		width: 300px;</span></span><br><span class="line"><span class="regexp">		height: 300px;</span></span><br><span class="line"><span class="regexp">		text-align: center;</span></span><br><span class="line"><span class="regexp">		font-weight: bold;</span></span><br><span class="line"><span class="regexp">		background-color: #2c8dfb;</span></span><br><span class="line"><span class="regexp">		background-position: center;</span></span><br><span class="line"><span class="regexp">		background-size: cover;</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vue</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用flow静态检查</title>
    <url>/2020/08/18/vue%E4%BD%BF%E7%94%A8flow%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="了解下flow"><a href="#了解下flow" class="headerlink" title="了解下flow"></a>了解下flow</h3><p>js是一门弱语言，灵活性强。这本来是它的优势。但是在程序运行中，数据类型变幻往往造成程序的不稳定。<br>flow.js是用来为js做静态类型检查的。在使用ts前，flow.js是一个不错的类型检查器。他和ts不是一回事。ts是js的超集，而flow只是一个工具</p>
<h3 id="在vue项目中使用flow"><a href="#在vue项目中使用flow" class="headerlink" title="在vue项目中使用flow"></a>在vue项目中使用flow</h3><ul>
<li>安装flow相关依赖包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yarn</span></span><br><span class="line">$ yarn add </span><br><span class="line">  babel-plugin-syntax-flow <span class="comment"># 添加对Babel中的流语法的支持。</span></span><br><span class="line">  babel-plugin-transform-class-properties <span class="comment">#  添加对类属性和静态方法的支持</span></span><br><span class="line">  babel-plugin-transform-flow-strip-types <span class="comment"># 在使用Babel转换前从源文件中删除类型注释。</span></span><br><span class="line">  eslint <span class="comment">#  Eslint。它实际上是JS的linter，集成了各种编辑器和ide。</span></span><br><span class="line">  babel-eslint <span class="comment"># 对Eslint进行补丁，以使用Babel的解析器解析源文件。</span></span><br><span class="line">  eslint-plugin-html <span class="comment"># 允许Eslint处理HTML文件 (ie. Only lints stuff inside script tags.)</span></span><br><span class="line">  eslint-plugin-flowtype-errors <span class="comment"># 通过Eslint传递流错误，并传递到编辑器的Eslint插件(如果有的话)。</span></span><br><span class="line">  eslint-plugin-vue <span class="comment"># 用于使用Vue的Eslint的插件。</span></span><br><span class="line">  eslint-config-vue <span class="comment"># 用于使用Vue的Eslint的配置.</span></span><br><span class="line">  flow-bin     <span class="comment"># flow 类型检查</span></span><br><span class="line">-D</span><br></pre></td></tr></table></figure></li>
<li>配置.babelrc<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"babel-plugin-transform-class-properties"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-syntax-flow"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-flow-strip-types"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置.eslintrc<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"html"</span>,</span><br><span class="line">    <span class="string">"flowtype-errors"</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="string">"extends"</span>: [</span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"flowtype-errors/show-errors"</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置.flowconfig<ul>
<li>在<code>package.json</code>的<code>scripts</code>标签中。添加<code>&quot;flow&quot;: &quot;flow&quot;</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">    <span class="string">"flow"</span>: <span class="string">"flow"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在项目的根目录，执行<code>flow init</code> 生成.flowconfig文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ignore]</span><br><span class="line">.*&#x2F;node_modules&#x2F;.*</span><br><span class="line">.*&#x2F;test&#x2F;.*</span><br><span class="line">.*&#x2F;build&#x2F;.*</span><br><span class="line">.*&#x2F;config&#x2F;.*</span><br><span class="line">[include]</span><br><span class="line"></span><br><span class="line">[libs]</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">module.file_ext&#x3D;.vue</span><br><span class="line">module.file_ext&#x3D;.js</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在js文件和.vue文件中加入<code>/* @flow */</code>,flow开始工作<br>test.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">const</span> doSomethingStupid(stringArg) &#123;</span><br><span class="line">  <span class="comment">// Flow should show an error here, "The operand of an arithmetic operation must be a number."</span></span><br><span class="line">  <span class="keyword">return</span> stringArg * <span class="number">3109</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doSomethingStupid(<span class="string">`I'm stringy`</span>))</span><br></pre></td></tr></table></figure>
test.vue<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm made with Flow!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">/* @flow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> randomThing: string = <span class="string">'Boop!'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  created() &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(randomThing)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="在webpack-中使用-flow-检查"><a href="#在webpack-中使用-flow-检查" class="headerlink" title="在webpack 中使用 flow 检查"></a>在webpack 中使用 flow 检查</h3><ul>
<li>安装一个 flow 的 webpack 插件 <code>flow-webpack-next-plugin</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add flow-webpack-next-plugin -D</span><br></pre></td></tr></table></figure></li>
<li>配置webpack  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FlowWebpackPlugin = <span class="built_in">require</span>(<span class="string">'flow-webpack-next-plugin'</span>);</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> FlowWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="记录一个flow报错-required-module-not-found"><a href="#记录一个flow报错-required-module-not-found" class="headerlink" title="记录一个flow报错 required module not found"></a>记录一个flow报错 required module not found</h3><p>原因： 因为webpack配置了别名(alias)，所以在 js 文件内直接 import 别名会导致 flow 无法正确找到对应的 module<br>解决： 在 .flowconfig 使用 name_mapper 将对应的别名做一个映射，问题解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">module.file_ext&#x3D;.vue</span><br><span class="line">module.file_ext&#x3D;.js</span><br><span class="line">module.name_mapper&#x3D;&#39;\(@\)&#39; -&gt; &#39;&lt;PROJECT_ROOT&gt;&#x2F;src&#x2F;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h3><p><a class="link"   href="https://www.jianshu.com/p/95854085ec40"  target="_blank" rel="noopener">https://www.jianshu.com/p/95854085ec40<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.digitalocean.com/community/tutorials/vuejs-components-flow"  target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/vuejs-components-flow<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>flow</tag>
      </tags>
  </entry>
  <entry>
    <title>node-sass装包报错</title>
    <url>/2020/08/17/node-sass%E8%A3%85%E5%8C%85%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="node-sass安装依赖error-node-sass-Command-failed报错解决"><a href="#node-sass安装依赖error-node-sass-Command-failed报错解决" class="headerlink" title="node-sass安装依赖error: node-sass: Command failed报错解决"></a>node-sass安装依赖error: node-sass: Command failed报错解决</h3><p>好好的yarn install。 报一个下图的错。<br><img src="http://i.feidom.com/nodeSassError.jpg" alt="nodeSassError"></p>
<p><strong>问题原因</strong>：查看报错信息，再查找资料。可能是被墙了。<br><strong>解决办法</strong>：将 sass-binary-site 添加至 yarn/npm config 中,指定node-sass在淘宝源中下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn config set sass-binary-site https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass</span><br><span class="line">npm config set sass-binary-site https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass</span><br></pre></td></tr></table></figure>

<blockquote>
<p>爬坑记录一下</p>
</blockquote>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>安装依赖问题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码解读之html与vNode间的转换</title>
    <url>/2020/08/13/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bhtml%E4%B8%8EvNode%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p><code>&lt;template&gt;</code>被compiler处理。compiler使用<code>generate(ast, options)</code>方法，将template转换为指定结构的对象。</p>
<h3 id="compiler编译"><a href="#compiler编译" class="headerlink" title="compiler编译"></a>compiler编译</h3><p>阅读源码逻辑可得，在实际上compiler的主要处理点是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compiled = baseCompile(template.trim(), finalOptions);</span><br></pre></td></tr></table></figure>
<p>即调用baseCompile函数，而baseCompile则是核心，这边主要代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码 将template处理为ast(抽象语法树)，且 根据ast树结构构建render函数主体部分。</p>
<h3 id="compiler中调用parse-解析"><a href="#compiler中调用parse-解析" class="headerlink" title="compiler中调用parse()解析"></a>compiler中调用parse()解析</h3><p>核心中用到的parse()方法的处理过程为：</p>
<ul>
<li>在new Vue实例化时，parseHTML解析html标签等html内容。parseHTML处理实际上会调用parseStartTag和handleStartTag来解析出开始标签，解析时，用到的方法是<strong>正则匹配</strong>。</li>
<li>parseText处理类似文本节点。实际上会将使用到响应式数据的文本变成：_s(text)，并且设置了@binding属性表示引用了哪个响应式变量。<br>还有一点就是对于换行的处理也会保留，即文本区域原样，该有换行就有换行只是响应式变量的特殊处理而已。</li>
</ul>
<p>示例总结：<br>将<code>&lt;div id=&quot;app&quot;&gt;  &lt;/div&gt;</code>,经过<code>parseHTML + parseText</code>的解析，得到如下的主要ast结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type: <span class="number">1</span>,</span><br><span class="line">tag: <span class="string">'div'</span>,</span><br><span class="line">attrs: [&#123; <span class="attr">name</span>: <span class="string">'id'</span>, <span class="attr">value</span>: <span class="string">'app'</span>&#125;],</span><br><span class="line">attrList: [&#123;<span class="attr">name</span>: <span class="string">'id'</span>, <span class="attr">value</span>: <span class="string">'app'</span>&#125;],</span><br><span class="line">attrMap: &#123;<span class="attr">id</span>: <span class="string">'app'</span>&#125;</span><br><span class="line">children: [</span><br><span class="line">    expression: <span class="string">""</span>\n    <span class="string">"+_s(text)+"</span>\n  <span class="string">""</span></span><br><span class="line">    text: <span class="string">"↵    &#123;&#123; text &#125;&#125;↵  "</span></span><br><span class="line">    tokens: (<span class="number">3</span>) [<span class="string">"↵    "</span>, &#123;…&#125;, <span class="string">"↵  "</span>]</span><br><span class="line">    type: <span class="number">2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="generate通过解析出来的ast构建render"><a href="#generate通过解析出来的ast构建render" class="headerlink" title="generate通过解析出来的ast构建render"></a>generate通过解析出来的ast构建render</h3><p>在构建render的过程中，用到了罪恶的<code>with()</code><br>先看一下generate的部分源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line"><span class="keyword">const</span> code = ast ? genElement(ast, state) : <span class="string">'_c("div")'</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    staticRenderFns: state.staticRenderFns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例的ast结构实际上构建成了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            attrs:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [</span><br><span class="line">            _v(<span class="string">"\n    "</span>+_s(text)+<span class="string">"\n  "</span>)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用函数形式表示的，实际上Vue源码此处是字符串，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"with(this)&#123;return _c("</span>div<span class="string">",&#123;attrs:&#123;"</span>id<span class="string">":"</span>app<span class="string">"&#125;&#125;,[_v("</span>\n <span class="string">"+_s(text)+"</span>\n <span class="string">")])&#125;"</span></span><br></pre></td></tr></table></figure>
<p>其中用到的_c(),_v(),_s的意思分别为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _c()就是$createElement，即h函数。该方法是vnode创建的实际出发点，Vue核心方法之一。具体源码如下：</span></span><br><span class="line">vm._c = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(vm, a, b, c, d, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// -v()实际上是createTextVNode，即创建虚拟文本节点（文本类型的虚拟DOM），实例方法如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -s()实际上是toString，处理对象和其他形式文本输出。处理null、对象以及数组形式的数据等将其转换为字符串。实例方法如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === <span class="literal">null</span> </span><br><span class="line">        ? <span class="string">' '</span> </span><br><span class="line">        : <span class="keyword">typeof</span> val === <span class="string">'object'</span> </span><br><span class="line">        <span class="comment">// 格式化对象，并指定缩进为2个空格</span></span><br><span class="line">        ? <span class="built_in">JSON</span>.stringify(val, <span class="literal">null</span>, <span class="number">2</span>) </span><br><span class="line">        : <span class="built_in">String</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明下_c中createElement中a、b、c、d参数表示的含义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a：tag，表示标签名</span></span><br><span class="line"><span class="comment">// b：data，表示属性、事件、class、props等的配置对象</span></span><br><span class="line"><span class="comment">// c: children，表示子节点</span></span><br><span class="line"><span class="comment">// d：normalizationType，表示类型，即要如何处理children中的数据</span></span><br></pre></td></tr></table></figure>

<p>至此，我们得到了render函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br></pre></td></tr></table></figure>

<h3 id="VNode的创建是在render执行过程中触发的"><a href="#VNode的创建是在render执行过程中触发的" class="headerlink" title="VNode的创建是在render执行过程中触发的"></a>VNode的创建是在render执行过程中触发的</h3><p>render中用<code>with()</code>执行了_c(),_v()等方法。<br>_c()就是$createElement,在createElement的处理逻辑中，最为核心的就是调用VNode构造函数创建虚拟DOM:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> VNode(tag, data, children, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context)</span><br></pre></td></tr></table></figure>
<p>然后再说一下VNode构造函数<br>VNode构造函数实际上就是定义相关属性，VNode中重要的属性有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tag：当前标签名</span></span><br><span class="line"><span class="comment">// data：标签属性、props、事件等对象集合</span></span><br><span class="line"><span class="comment">// text：当前标签文本内容</span></span><br><span class="line"><span class="comment">// context：上下文对象，即Vue实例对象</span></span><br><span class="line"><span class="keyword">var</span> VNode = <span class="function"><span class="keyword">function</span>(<span class="params">tag, data, children, text, elm, context, componentOptions, asyncFactory</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.tag = tag;</span><br><span class="line">	<span class="keyword">this</span>.data = data;</span><br><span class="line">	<span class="keyword">this</span>.children = children;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="render中创建了VNode，那什么时候调用render呢"><a href="#render中创建了VNode，那什么时候调用render呢" class="headerlink" title="render中创建了VNode，那什么时候调用render呢??"></a>render中创建了VNode，那什么时候调用render呢??</h3><p>这里说明下之前render生成时的过程及时间点</p>
<ul>
<li>初始化时renderMixin<br>这部分是加载Vue.js文件过程中的处理，涉及到render的是renderMixin函数，实际上该函数主要定义Vue原型方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.prototype.$nextTick方法定义</span></span><br><span class="line"><span class="comment">// Vue.prototype._render方法定义</span></span><br></pre></td></tr></table></figure></li>
<li>new Vue时initRender<br>创建Vue实例时会调用initRender进行初始化，实际上就是相关属性的定义</li>
<li>$mount挂载render处理<br>在这个时候将template处理成render函数。</li>
<li>$mount中构建出了render函数，那再来看看render函数的调用<br><img src="http://i.feidom.com/vue-render%28%29%E5%87%BD%E6%95%B0%E5%95%A5%E6%97%B6%E5%80%99%E7%94%A8.png" alt="看下这张图"><br>上图是mountComponent主要的处理逻辑，实际上render函数的执行是在_render中处理的。_render函数的结果作为vm._update函数的参数。<br>这里有一个非常需要注意的点，实际上是在构建Watcher实例触发的：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	vm._update(vm._render());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop)</span><br></pre></td></tr></table></figure>
updateComponent会作为getter函数，并且会在Watcher.prototype.get中被调用，而这个步骤就是重新生成html的过程。</li>
<li>再说下_render方法<br>实际上_render中主要的处理也就是render函数的调用，核心代码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line"><span class="keyword">return</span> vnode;</span><br></pre></td></tr></table></figure></li>
<li>再说下_update实例方法<br>_update中处理实际上有两个主要点：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* vm._vnode相关处理，两点：prevNode &#x3D; vm._vnode，vm._vnode &#x3D; vnode</span><br><span class="line">* vm.__patch__的调用</span><br></pre></td></tr></table></figure>
prevNode记录更新前的vnode，如果是初始化，那么prevNode就是空，调用<strong>patch</strong>实现vnode -&gt; html的过程，也是<strong>diff算法</strong>的实现过程，是整个Vue中核心点之一。<br>_update核心源码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prevNode = vm._vnode;</span><br><span class="line">vm._vnode = vnode;</span><br><span class="line"><span class="keyword">if</span> (!prevNode) &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	vm.$el = vm.__patch__(vm.$el，vnode, hydrating, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 更新</span></span><br><span class="line">	vm.$el = vm.__patch__(prevNode, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
_update负责比较dom节点并替换。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>通过上面主要分析了处理html、处理文本情况，对于指令相关等部分直接略过，满足了分析这边的目的：探寻下Vue是如何解析template的。<br>整个处理流程如下：<br>构建code：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$mount -&gt; compileToFunctions -&gt; compile -&gt; baseCompile -&gt; parse -&gt; generate -&gt; render</span><br><span class="line">其中parse中主要的处理：</span><br><span class="line">parse -&gt; parseHTML、parseText（循环处理startTag、text等）</span><br></pre></td></tr></table></figure>
而vnode的创建实际上是在render调用阶段发生的，即执行render函数，函数体中_c、_v等函数触发的VNode创建。<br>render函数调用:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生成render函数 -&gt; mountComponent -&gt; new Watcher -&gt; Vue.prototype._render调用</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>在查看源码的过程中，搜索了各种资料帮助自己理解，其中来自<a class="link"   href="https://blog.csdn.net/s1879046/category_7294206.html"  target="_blank" rel="noopener">玉案轩窗老哥的Vue系列<i class="fas fa-external-link-alt"></i></a>条理清晰，对自己帮助很大。以上笔记也借鉴了他的内容，方便之后学习理解。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码解读</title>
    <url>/2020/08/13/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="看完这张图"><a href="#看完这张图" class="headerlink" title="看完这张图"></a>看完这张图</h3><p><img src="http://i.feidom.com/vue%E6%A0%B8%E5%BF%83%E5%9B%BE.png" alt="vue的工作流程图"></p>
<h3 id="各阶段间详细解读"><a href="#各阶段间详细解读" class="headerlink" title="各阶段间详细解读"></a>各阶段间详细解读</h3><ul>
<li><a href="/2020/08/13/vue源码解读之html与vNode间的转换/">html 《==转换==》 vNode</a></li>
<li><a href="/2020/08/12/vue源码解析之observer重写array监听/">Observer重写array监听</a></li>
<li><a href="">keep-alive的实现</a></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2.x源码解读之observer重写array监听</title>
    <url>/2020/08/12/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bobserver%E9%87%8D%E5%86%99array%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>vue的核心功能之一就是双向绑定，在vue2.x中，双向绑定的原理，是依赖<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"  target="_blank" rel="noopener">Object.defineProperty<i class="fas fa-external-link-alt"></i></a>这个方法。由于这个方法的一些弊端，导致Observer的实现，需要兼容这些弊端。以下内容详细说明了来龙去脉</p>
<h3 id="先自己实现一个Observer"><a href="#先自己实现一个Observer" class="headerlink" title="先自己实现一个Observer"></a>先自己实现一个Observer</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function defineGet()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`get key: <span class="subst">$&#123;key&#125;</span> vaule:<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function defineSet(newVal)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`set key: <span class="subst">$&#123;key&#125;</span> vaule: vaule:<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">            value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        defineReactive(data,key,data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let arr = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// observe(arr)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先对数组(arr)的监听<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">observe(arr)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>代码运行后，在控制台直接给arr增加一个元素。代码及输出如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键入</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
===&gt; <strong>新增的数组元素无法监听</strong><br>原因： 在监听数组arr时，监听了它的key:0,1,2(数组下标)。并没有监听下标3，所以监听失败。</li>
<li>代码运行后，在控制台直接给arr最前面unshift一个元素。代码及输出如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键入</span></span><br><span class="line">arr.unshift(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// get key: 2 vaule:3</span></span><br><span class="line"><span class="comment">// get key: 1 vaule:2</span></span><br><span class="line"><span class="comment">// set key: 2 vaule: vaule:2</span></span><br><span class="line"><span class="comment">// get key: 0 vaule:1</span></span><br><span class="line"><span class="comment">// set key: 1 vaule: vaule:1</span></span><br><span class="line"><span class="comment">// set key: 0 vaule: vaule:4</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
===&gt; <strong>在进行部分数组操作时，会造成监听多次</strong>（数组移位）<br>原因： 在监听数组arr时，监听了它的key:0,1,2(数组下标)。当在数组arr的前面插入一个数据，造成数组移位（splice也会这样），所有的元素向后移动一个位置。造成多次get/set。<br>如下图所示：<br><img src="http://i.feidom.com/%E6%95%B0%E7%BB%84%E7%A7%BB%E4%BD%8D.png" alt="数组移位"></li>
</ol>
<ul>
<li>对对象(obj)的监听<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">"key1"</span>:<span class="string">"vaule1"</span>&#125;</span><br><span class="line">observe(obj)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>代码运行后，在控制台直接给obj增加一个元素<code>obj[&quot;key2&quot;] = &quot;value2&quot;</code>。代码及输出如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键入</span></span><br><span class="line">obj[<span class="string">"key2"</span>] = <span class="string">"value2"</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// "value2"</span></span><br></pre></td></tr></table></figure>
===&gt; <strong>新增的对象元素无法监听</strong><br>原因类同监听数组时的情况1</li>
</ol>
<h3 id="Observer的Object-defineProperty这些问题，vue如何解决"><a href="#Observer的Object-defineProperty这些问题，vue如何解决" class="headerlink" title="Observer的Object.defineProperty这些问题，vue如何解决"></a>Observer的Object.defineProperty这些问题，vue如何解决</h3><p>在vue的core中，observe下专门对array的监听进行了重写，以下内容为源码中的代码片段，来说明如何重写实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype  <span class="comment">// 获取Array原型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)  <span class="comment">// 用新的原型对象创建一个arrayMethods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个要重写的方法的数组，其中的方法，都是会发生数组移位的</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截变化方法并发出事件,遍历重写的方法的数组methodsToPatch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// def是一个Object.defineProperty</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change </span></span><br><span class="line">    <span class="comment">// 手动发布变更信息</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/2020/08/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简单介绍一下"><a href="#简单介绍一下" class="headerlink" title="简单介绍一下"></a>简单介绍一下</h3><p>观察者模式，又称<strong>发布/订阅模式</strong>，它定义了一种<strong>一对多</strong>的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<h3 id="使用观察者模式的好处："><a href="#使用观察者模式的好处：" class="headerlink" title="使用观察者模式的好处："></a>使用观察者模式的好处：</h3><ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li>
<li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li>
</ul>
<h3 id="用javaScript实现一般简单的观察者模式"><a href="#用javaScript实现一般简单的观察者模式" class="headerlink" title="用javaScript实现一般简单的观察者模式"></a>用javaScript实现一般简单的观察者模式</h3><p><em>pub(Publish) 发布</em><br><em>sub(Subscribe) 订阅</em><br><em>dep 发布订阅中心-电话本</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dep = &#123;&#125;;  <span class="comment">// dep相当于电话本，所有订阅者都注册在这里</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topics = &#123;&#125;, <span class="comment">// 回调函数存放的数组</span></span><br><span class="line">        subUid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 发布方法</span></span><br><span class="line">    q.publish = <span class="function"><span class="keyword">function</span> (<span class="params">topic, args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> subscribers = topics[topic],</span><br><span class="line">                len = subscribers ? subscribers.length : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                <span class="comment">// 遍历所有订阅的方法，全部执行</span></span><br><span class="line">                subscribers[len].func(topic, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="comment">// @param  topic  订阅者名称</span></span><br><span class="line">    <span class="comment">// @param  func   订阅方法，通知时，调用这个方法实现通知</span></span><br><span class="line">    q.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">topic, func</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">            <span class="comment">// 注册观察对象</span></span><br><span class="line">            topics[topic] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> token = (++subUid).toString();   <span class="comment">// 方法的唯一口令标识，退订时可用</span></span><br><span class="line">        <span class="comment">// 注册观察方法</span></span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            func: func</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//退订方法</span></span><br><span class="line">    q.unsubscribe = <span class="function"><span class="keyword">function</span> (<span class="params">token</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> m <span class="keyword">in</span> topics) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topics[m]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = topics[m].length; i &lt; j; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (topics[m][i].token === token) &#123;</span><br><span class="line">                        <span class="comment">// 根据唯一口令标识 移除观察方法，实现退订</span></span><br><span class="line">                        topics[m].splice(i, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> token;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; (dep));</span><br></pre></td></tr></table></figure>

<p>使用上面这个观察者模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来，订阅一个</span></span><br><span class="line">pubsub.subscribe(<span class="string">'example1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">topics, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通知时，这个方法收到通知执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(topics + <span class="string">": "</span> + data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 再加一个订阅方法</span></span><br><span class="line">pubsub.subscribe(<span class="string">'example1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">topics, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法也收到通知执行</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(data))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'接到通知2'</span>,topics,  data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//发布通知</span></span><br><span class="line">pubsub.publish(<span class="string">'example1'</span>, <span class="string">'hello world!'</span>);</span><br><span class="line">pubsub.publish(<span class="string">'example1'</span>, [<span class="string">'test'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">pubsub.publish(<span class="string">'example1'</span>, [&#123; <span class="string">'color'</span>: <span class="string">'blue'</span> &#125;, &#123; <span class="string">'text'</span>: <span class="string">'hello'</span>&#125;]);</span><br></pre></td></tr></table></figure>
<h3 id="一张图说清楚观察者模式"><a href="#一张图说清楚观察者模式" class="headerlink" title="一张图说清楚观察者模式"></a>一张图说清楚观察者模式</h3><p><img src="http://i.feidom.com/sub_pub%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p>
<h3 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h3><p>此篇笔记是看了<a class="link"   href="https://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html"  target="_blank" rel="noopener">汤姆大叔的博客-深入理解JavaScript系列（32）：设计模式之观察者模式<i class="fas fa-external-link-alt"></i></a>,笔记内容大多来自该篇博客。大叔的博客中还有其他观察者模式的实现方式，如需更深的理解，请移步。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用gsap的动画插件</title>
    <url>/2020/08/07/vue%E4%B8%AD%E4%BD%BF%E7%94%A8tweenmax%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="gsap-动画"><a href="#gsap-动画" class="headerlink" title="gsap 动画"></a>gsap 动画</h3><p><a class="link"   href="https://www.tweenmax.com.cn/demo/"  target="_blank" rel="noopener">TweenMax基础案例<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><p>npm install / yarn add 二选一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gsap --save</span><br><span class="line">yarn add gsap</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>component.vue</code>局部引入，哪里需要哪里搬</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>以下例子每个动画的开始时间按0.5s 错开。TweenLite没有stagger。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box grey"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box grey"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box grey"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"showTest()"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; TweenLite, TweenMax &#125; <span class="keyword">from</span> <span class="string">'gsap'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            showTest: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//TweenMax、TimelineLite、TimelineMax可以使用stagger（错开动画），TweenLite则没有。</span></span></span><br><span class="line"><span class="actionscript">                TweenMax.staggerTo(<span class="string">".box"</span>, <span class="number">1</span>, &#123;rotation:<span class="number">360</span>, y:<span class="number">100</span>&#125;, <span class="number">0.5</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>动画</tag>
        <tag>tweenmax</tag>
        <tag>gsap</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用animate.css</title>
    <url>/2020/08/07/vue%E4%B8%AD%E4%BD%BF%E7%94%A8animateCss/</url>
    <content><![CDATA[<h3 id="在vue项目中使用animate-css"><a href="#在vue项目中使用animate-css" class="headerlink" title="在vue项目中使用animate.css"></a>在vue项目中使用animate.css</h3><p>配合vue中的transition标签来结合animate.css中的效果</p>
<ul>
<li><p>npm install / yarn add 二选一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add animate.css@3.5.1</span><br><span class="line"><span class="comment"># 在这要装3.5.1的版本，装了4.0之后的版本，会不生效。是版本兼容问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>main.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> animate <span class="keyword">from</span> <span class="string">'animate.css'</span></span><br><span class="line">Vue.use(animate);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>component.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">enter-active-class</span>=<span class="string">"animated bounceIn"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOut"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:duration</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>这个元素存在动画效果<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span>  @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>开始表演<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vue</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Css从边角走向中心</title>
    <url>/2020/08/04/postcss/</url>
    <content><![CDATA[<h3 id="被轻视的CSS"><a href="#被轻视的CSS" class="headerlink" title="被轻视的CSS"></a>被轻视的CSS</h3><p>CSS是Cascading Style Sheets（层叠样式表单）的简称。这种样式脚本一直和其他编程语言有差距。导致了css被轻视。近几年所有的前端技术都在疯狂的迭代更新，css也不例外。从sass，less，stylus这些预处理器之后，到CSS Module，CSS-in-JS（典型的代表，react的styled-components）。再聊聊<a class="link"   href="https://www.postcss.com.cn/"  target="_blank" rel="noopener">PostCss<i class="fas fa-external-link-alt"></i></a>这种插件系统。</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><h5 id="在css发展的过程中，出现了一些痛点："><a href="#在css发展的过程中，出现了一些痛点：" class="headerlink" title="在css发展的过程中，出现了一些痛点："></a>在css发展的过程中，出现了一些痛点：</h5><ul>
<li>语法不够强大，不能够嵌套书写，不利于模块开发</li>
<li>没有变量和逻辑上的复用机制，导致在css的属性值中只能使用字面量形式，以及不断重复的样式，导致难以维护。</li>
</ul>
<h5 id="然后css预处理器的出现，弥补了这些遗憾："><a href="#然后css预处理器的出现，弥补了这些遗憾：" class="headerlink" title="然后css预处理器的出现，弥补了这些遗憾："></a>然后css预处理器的出现，弥补了这些遗憾：</h5><ul>
<li><strong>变量</strong>：对变量进行声明，在需要的地方引用。</li>
<li><strong>作用域</strong>：对变量进行管理，像js一样，从局部作用域开始向上查找变量。</li>
<li><strong>嵌套</strong>：由于dom的树状结构，css有嵌套的写法，更直接的表现了父子层级之间的明确关系。</li>
<li><strong>混合(Mixin) Extend</strong>：</li>
<li><strong>运算</strong>：</li>
<li><strong>函数</strong>：</li>
<li><strong>Namespaces&amp;Accessors</strong>：</li>
<li><strong>scope</strong>：</li>
<li><strong>注释</strong>：</li>
</ul>
<p>css预处理器提供的这些方案，是我们开发人员在写css时更加灵活，维护性强。<br>但是，项目越来越大，缺乏模块的概念，全局变量的问题困扰着你。每次定义选择器时，总要顾及到其他文件中是否使用了同样的命名。</p>
<h5 id="有问题就有解决，各种方案出现（css分层）"><a href="#有问题就有解决，各种方案出现（css分层）" class="headerlink" title="有问题就有解决，各种方案出现（css分层）"></a>有问题就有解决，各种方案出现（css分层）</h5><h6 id="Q：为什么要分层？"><a href="#Q：为什么要分层？" class="headerlink" title="Q：为什么要分层？"></a>Q：为什么要分层？</h6><p>A:原因： </p>
<ul>
<li>CSS有语义化的命名约定和CSS层的分离，将有助于它的可扩展性，性能的提⾼<br>和代码的组织管理。</li>
<li>⼤量的样式，覆盖、权重和很多!important，分好层可以让团队命名统⼀规范，<br>⽅便维护。</li>
<li>有责任感地去命名你的选择器。</li>
</ul>
<h6 id="分层的设计规范有很多，以下具体介绍BEM规范"><a href="#分层的设计规范有很多，以下具体介绍BEM规范" class="headerlink" title="分层的设计规范有很多，以下具体介绍BEM规范"></a>分层的设计规范有很多，以下具体介绍BEM规范</h6><ul>
<li>BEM规范<br>和SMACCS⾮常类似，主要⽤来如何给项⽬命名。⼀个简单命名更容易让别<br>⼈⼀起⼯作。⽐如选项卡导航是⼀个块(Block)，这个块⾥的元素的是其中标签之⼀<br>(Element)，⽽当前选项卡是⼀个修饰状态(Modifier)：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bookList模块   </span></span><br><span class="line">&lt;form <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-from"</span>&gt;</span><br><span class="line">    &lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-from__input"</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button class="list-from__button"&gt;&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 其中归类为以下约定</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ BEM：块（block）、元素（element）、修饰符（modifier）</span></span><br><span class="line"><span class="regexp">.block&#123;&#125;  /</span><span class="regexp">/ 代表了更⾼级别的抽象或组件</span></span><br><span class="line"><span class="regexp">.block__element&#123;&#125;  /</span><span class="regexp">/ 代表.block的后代，⽤于形成⼀个完整的.block的整体</span></span><br><span class="line"><span class="regexp">.block--modifier&#123;&#125;  /</span><span class="regexp">/ 代表.block的不同状态或不同版本</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 其中块可以用单个连字符来界定：如</span></span><br><span class="line"><span class="regexp">.site-search&#123;&#125; /</span><span class="regexp">/块</span></span><br><span class="line"><span class="regexp">.site-search__field&#123;&#125; /</span><span class="regexp">/元素</span></span><br><span class="line"><span class="regexp">.site-search--full&#123;&#125; /</span><span class="regexp">/修饰符</span></span><br></pre></td></tr></table></figure>
……<br>好麻烦。</li>
</ul>
<hr>
<p>还有<a class="link"   href="https://smacss.com/"  target="_blank" rel="noopener">SMACSS(Scalable and Modular Architecture for CSS 可扩展的模块化架构的CSS)<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://suitcss.github.io/"  target="_blank" rel="noopener">SUIT：衍生自BEM<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://patternlab.io/"  target="_blank" rel="noopener">ACSS：原子css规范<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://csswizardry.net/talks/2014/11/itcss-dated.pdf"  target="_blank" rel="noopener">ITCSS<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h3><ul>
<li>CSS压缩 ClEAN_CSS</li>
<li>自动添加浏览器前缀 Autoprefixer</li>
<li>CSS更加美观排序 CSScomb</li>
<li>Rework取代styles，后处理器发热</li>
</ul>
<h3 id="近几年火爆的CSS-Module，CSS-in-JS（典型的代表，react的styled-components）。"><a href="#近几年火爆的CSS-Module，CSS-in-JS（典型的代表，react的styled-components）。" class="headerlink" title="近几年火爆的CSS Module，CSS-in-JS（典型的代表，react的styled-components）。"></a>近几年火爆的CSS Module，CSS-in-JS（典型的代表，react的styled-components）。</h3><p>可以参考<a class="link"   href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html"  target="_blank" rel="noopener">阮一峰写的CSS Module<i class="fas fa-external-link-alt"></i></a><br>看8月3老袁的课，写一下。</p>
<h3 id="PostCSS是什么？"><a href="#PostCSS是什么？" class="headerlink" title="PostCSS是什么？"></a>PostCSS是什么？</h3><p><a class="link"   href="https://www.postcss.com.cn/"  target="_blank" rel="noopener">PostCSS<i class="fas fa-external-link-alt"></i></a><br>是一个用 JavaScript 工具和插件转换 CSS 代码的工具。—-官方简介</p>
<p>PostCSS同时支持预处理和后处理，也可以在原生的css中使用它。通俗来说，PostCSS是一个“壳壳”，可以加载各种生态中的插件来实现对css的处理，可以结合兼容sass，less等</p>
<h5 id="下面介绍几种插件（plugins）："><a href="#下面介绍几种插件（plugins）：" class="headerlink" title="下面介绍几种插件（plugins）："></a>下面介绍几种插件（plugins）：</h5><ul>
<li>postcss-cssnext plugin —  使用下个版本的css语法，语法见cssnext (css4)语法</li>
<li>postcss-custom-properties — 运行时变量</li>
<li>postcss-simple-vars — 与SCSS一致的变量实现</li>
<li>postcss-mixins — 实现类似sass的@mixin的功能</li>
<li>postcss-extend — 实现类似sass的继承功能</li>
<li>postcss-import — 实现类似sass的import<h5 id="使用gulp和webpack处理postcss代码："><a href="#使用gulp和webpack处理postcss代码：" class="headerlink" title="使用gulp和webpack处理postcss代码："></a>使用gulp和webpack处理postcss代码：</h5>// gulpfile.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>); </span><br><span class="line"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>); </span><br><span class="line"><span class="keyword">var</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>); </span><br><span class="line"><span class="keyword">var</span> cssgrace = <span class="built_in">require</span>(<span class="string">'cssgrace'</span>); </span><br><span class="line"><span class="keyword">var</span> cssnext = <span class="built_in">require</span>(<span class="string">'cssnext'</span>); </span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> processors = [ </span><br><span class="line">        autoprefixer(&#123;<span class="attr">browsers</span>: [<span class="string">'last 3 version'</span>], </span><br><span class="line">        cascade: <span class="literal">false</span>, </span><br><span class="line">        remove: <span class="literal">false</span> </span><br><span class="line">        &#125;), </span><br><span class="line">        cssnext(), </span><br><span class="line">        cssgrace </span><br><span class="line">    ]; </span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./src/css/*.css'</span>) </span><br><span class="line">        .pipe(postcss(processors)) </span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>)); </span><br><span class="line">&#125;); </span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    gulp.watch(<span class="string">'./src/css/*.css'</span>, [<span class="string">'css'</span>]); </span><br><span class="line">&#125;); </span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watch'</span>, <span class="string">'css'</span>]);</span><br></pre></td></tr></table></figure>
// webpack.conf.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    output:&#123;<span class="attr">publicPath</span>: <span class="string">'../dist/'</span>&#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// loaders...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    postcss: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            ima4dpr(dpr: <span class="number">3</span>,<span class="attr">q</span>: <span class="string">'q50'</span>,<span class="attr">s</span>: <span class="string">'s150'</span>&#125;),</span><br><span class="line">            px2rem(&#123;<span class="attr">remUnit</span>: remUnit, <span class="attr">baseDpr</span>: baseDpr &#125;),</span><br><span class="line">            autoprefixer(&#123;<span class="attr">browers</span>: [<span class="string">"ios_saf &gt;= 7"</span>,<span class="string">"android &gt;= 4"</span>]&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
打包处理逻辑如下图所示：</li>
</ul>
<p><img src="http://i.feidom.com/%E6%89%93%E5%8C%85%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84postcss.jpg" alt="打包处理逻辑"></p>
<hr>
<p><em>以上内容借鉴<a class="link"   href="https://segmentfault.com/a/1190000011595620"  target="_blank" rel="noopener">zimo的《谈谈PostCSS》<i class="fas fa-external-link-alt"></i></a></em></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>postcss</tag>
      </tags>
  </entry>
  <entry>
    <title>npm/yarn及其他包管理工具常用总结</title>
    <url>/2020/08/02/npm%E5%B8%B8%E7%94%A8%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li><p>安装</p>
<ul>
<li><p>npm<br>装了<code>nodeJs</code>会装好npm</p>
</li>
<li><p>yarn<br><a class="link"   href="https://yarn.bootcss.com/docs/install/"  target="_blank" rel="noopener">安装yarn<i class="fas fa-external-link-alt"></i></a></p>
<p><code>npm install -g yarn</code></p>
</li>
</ul>
</li>
<li><p>修改源</p>
<ul>
<li><p>npm (淘宝源 ｜ 本源)<br><code>npm config set registry http://registry.npm.taobao.org/</code></p>
<p><code>npm config set registry https://registry.npmjs.org/</code></p>
</li>
<li><p>yarn (淘宝源 ｜ 本源)<br><code>yarn config set registry http://registry.npm.taobao.org/</code></p>
<p><code>yarn config set registry https://registry.npmjs.org/</code></p>
</li>
</ul>
</li>
<li><p>设置代理</p>
<ul>
<li><p>npm<br><code>npm config set proxy http://127.0.0.1:8080</code></p>
<p><code>npm config set https-proxy http://127.0.0.1:8080</code></p>
</li>
<li><p>yarn<br><code>yarn config set proxy http://127.0.0.1:8080</code></p>
<p><code>yarn config set https-proxy http://127.0.0.1:8080</code></p>
</li>
</ul>
</li>
<li><p>删除代理</p>
<ul>
<li><p>npm<br><code>npm config delete proxy</code> </p>
<p><code>npm config delete https-proxy</code></p>
</li>
<li><p>yarn<br><code>yarn config delete proxy</code> </p>
<p><code>yarn config delete https-proxy</code></p>
</li>
</ul>
</li>
<li><p>查看安装包</p>
<ul>
<li>npm<br><code>npm list -g --depth 0</code></li>
<li>yarn<br><code>yarn global list --depth=0</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><font color=red size=5>npx</font><br>    npx 是 npm 5.2+ 版本之后自带的工具，能够帮助我们更高效的执行 npm 软件仓库里的安装包。对于那些不常使用、或者只想一次性尝试的工具，推荐使用 npx 的方式代替 npm install -g、yarn global 全局安装<br>    $ npx create-react-app my-app<br>    # 执行以上这条命令 npx 会按以下顺序工作：<br>    # 1. 先查看当前项目有没 create-react-app<br>    # 2. 如果当前项目找不到，会去全局查找 create-react-app<br>    # 3. 如果全局还找不到，会帮我们临时从 npm 包仓库安装 create-react-app，不会污染到当前项目，也不会装到全局</p>
</blockquote>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>yarn</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json了解多少</title>
    <url>/2020/08/02/package%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li><strong>scripts属性</strong><br>生命周期</li>
</ul>
<ol>
<li>pre钩子<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"predev"</span>: <span class="string">"echo 111"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"echo 222"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
上述代码执行<code>yarn run dev</code>,会先执行pre钩子，结果如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn run dev</span><br><span class="line">// 以下为结果</span><br><span class="line">111</span><br><span class="line">222</span><br></pre></td></tr></table></figure></li>
<li>&amp;(同步串行) 和 &amp;&amp;(异步并行)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"echo 111"</span>,</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"echo 222"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev &amp; npm run server"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
上述代码执行<code>yarn start</code>,会先执行dev,再执行server，dev有报错，server不会被执行。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"echo 111"</span>,</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"echo 222"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev &amp;&amp; npm run server"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
上述代码执行<code>yarn start</code>,会同步行dev和server，dev有报错，server仍会被执行。</li>
</ol>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 403 Forbidden</title>
    <url>/2020/07/31/nginx403/</url>
    <content><![CDATA[<ul>
<li><p>检查目录权限。权限不足的就加个权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod -R 755 /root/feidom_blog/</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nginx.conf</code>中的user问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"><span class="comment"># user  nobody;</span></span><br><span class="line"><span class="comment"># 把 user 用户名 改为 user root 或 其它有高权限的用户名称即可</span></span><br><span class="line">user root;</span><br></pre></td></tr></table></figure></li>
<li><p>centos中的selinux是否为关闭状态<br>查看SELinux状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;sbin&#x2F;sestatus -v</span><br><span class="line">SELinux status:                 disabled</span><br><span class="line">##  disabled&#x2F;enabled  (关闭&#x2F;开启)</span><br></pre></td></tr></table></figure>
<p>关闭SELinux：</p>
</li>
</ul>
<ol>
<li>临时关闭，不用重启机器。<br><code>$ setenforce 0</code>  #设置SELinux 成为permissive模式;<br><code>$ setenforce 1</code>      #设置SELinux 成为enforcing模式</li>
<li>修改/etc/selinux/config 文件后，重启机器使其生效。<br><code>SELINUX=enforcing</code>  改为 <code>SELINUX=disabled</code></li>
</ol>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析</title>
    <url>/2020/07/28/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>DNS: domain name system  </p>
<p><em>作用：将域名解析到对应的ip地址</em><br><em>解析原理：分级解析</em></p>
<ul>
<li><p>域名分级(一级，二级，三级)<br>  <code>www.baidu.com</code><br>  <code>com</code>是根域名，<code>baidu.com</code>是一级域名（顶级域名），<code>www.baidu.com</code>是二级域名</p>
</li>
<li><p>ip<br>  分为ipv4，ipv6</p>
</li>
<li><p>解析详解<br>  <img src="http://i.feidom.com/dns%E8%A7%A3%E6%9E%90.png" alt="解析图解"></p>
<ol>
<li><a class="link"   href="http://www.baidu.com"  target="_blank" rel="noopener">www.baidu.com<i class="fas fa-external-link-alt"></i></a>?</li>
<li>com = 1.1.1.1 （TLD服务器地址）</li>
<li><a class="link"   href="http://www.baidu.com"  target="_blank" rel="noopener">www.baidu.com<i class="fas fa-external-link-alt"></i></a>?</li>
<li>baidu.com = 2.2.2.2 （名称服务器地址 name server）</li>
<li><a class="link"   href="http://www.baidu.com"  target="_blank" rel="noopener">www.baidu.com<i class="fas fa-external-link-alt"></i></a>?</li>
<li><a class="link"   href="http://www.baidu.com"  target="_blank" rel="noopener">www.baidu.com<i class="fas fa-external-link-alt"></i></a> = 3.3.3.3 （目标ip地址）</li>
</ol>
</li>
</ul>
<p>dns缓存可以使解析更快响应。</p>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Navigation Timing &amp; Navigation Timing API</title>
    <url>/2020/07/24/navigationTiming/</url>
    <content><![CDATA[<h3 id="Navigation-Timing"><a href="#Navigation-Timing" class="headerlink" title="Navigation Timing"></a>Navigation Timing</h3><p><img src="http://i.feidom.com/performance_timing_api.jpg" alt="实际情况"></p>
<p>图解：</p>
<ul>
<li><p>Prompt for unload                   // 激起卸载</p>
<ul>
<li>navigationStart                 // 导航开始</li>
</ul>
</li>
<li><p>redirect                            // 本地重定向</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
</ul>
</li>
<li><p>unload                              // 本地重定向的同时 卸载</p>
<ul>
<li>unloadStart</li>
<li>unloadEnd</li>
</ul>
</li>
<li><p>App cache                           // 有缓存拿缓存</p>
<ul>
<li>fetchStart</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>DNS                                 // <a href="/2020/07/28/DNS域名解析/">DNS域名解析</a><ul>
<li>domainLookipStart</li>
<li>domainLookupEnd</li>
</ul>
</li>
<li>TCP                                 // 建立tcp连接<ul>
<li>connectStart                    // 开始三次握手，四次挥手</li>
<li>(secureConnectionStart)         // 建立https安全协议的加密链接</li>
<li>connectEnd</li>
</ul>
</li>
<li>Request                             // 请求<ul>
<li>requestStart</li>
</ul>
</li>
<li>Response                            // 响应<ul>
<li>responseStart</li>
<li>responseEnd</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Processing                          // 前端HTML处理<ul>
<li>domLoading                      </li>
<li>domInteractive                  </li>
<li>domContentLoaded                </li>
<li>domComplate</li>
</ul>
</li>
<li>onload                              // onload<ul>
<li>loadEventStart</li>
<li>loadEventEnd</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML、CSS、JS互相阻塞？咋回事</title>
    <url>/2020/07/23/HTMLCSSJS%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>js是同步的，为了操作dom。在html执行中，也由于这个原因，有同步阻塞的情况。</p>
<h3 id="js的执行会影响Dom渲染吗"><a href="#js的执行会影响Dom渲染吗" class="headerlink" title="js的执行会影响Dom渲染吗?"></a>js的执行会影响Dom渲染吗?</h3><pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 这个script放在dom上边，影响dom解析，也影响dom渲染。</span></span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'1'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 这个script放在dom下边，影响dom渲染，不影响dom解析</span></span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'1'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="css的执行会影响Dom渲染吗"><a href="#css的执行会影响Dom渲染吗" class="headerlink" title="css的执行会影响Dom渲染吗?"></a>css的执行会影响Dom渲染吗?</h3><pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1&#123;</span><br><span class="line">            color: red !important;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelectorAll(<span class="string">'h1'</span>))</span></span><br><span class="line">        &#125;,0)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- animate.css没回来之前，script中打印了h1，但是h1并没有在页面中展示。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- css不影响dom解析，影响dom渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="css的执行会影响js执行吗"><a href="#css的执行会影响js执行吗" class="headerlink" title="css的执行会影响js执行吗?"></a>css的执行会影响js执行吗?</h3><pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1&#123;</span><br><span class="line">            color: red !important;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- animate.css没回来之前，script中没有打印h1。h1并没有在页面中展示。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- css加载阻塞js执行。原因：js中可能存在对dom元素的操作或者取值，同步解决这个问题。所以阻塞。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="css的执行会影响domReady吗"><a href="#css的执行会影响domReady吗" class="headerlink" title="css的执行会影响domReady吗?"></a>css的执行会影响domReady吗?</h3><p>domReady时，js可以操作dom。<br>    <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="built_in">console</span>.log(<span class="string">'DOMContentLoaded'</span>)</span></span><br><span class="line">       &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/animate.css/4.1.0/animate.compat.css"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在animate.css没回来之前，打印了DOMContentLoaded。说明css不影响domReady --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'111'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加了上面这个script脚本时，在animate.css没回来之前，不打印111，也不打印DOMContentLoaded。</span></span><br><span class="line"><span class="comment">    也是因为js中可能存在对dom元素的操作或者取值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染过程及优化</title>
    <url>/2020/07/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="熟练使用Chrome开发工具"><a href="#熟练使用Chrome开发工具" class="headerlink" title="熟练使用Chrome开发工具"></a>熟练使用Chrome开发工具</h3><p><img src="http://i.feidom.com/chrome_performance.png" alt="ChromePerformance"></p>
<h3 id="浏览器渲染基础"><a href="#浏览器渲染基础" class="headerlink" title="浏览器渲染基础"></a>浏览器渲染基础</h3><p>cpu主要负责操作系统和程序  gpu负责显式  数据处理效率更高  gpu.js</p>
<ul>
<li>Dom是分层的<br>  firefox的3d插件（已废弃）很好的展现了这个点。<br>  <strong>Q:</strong>什么元素会分层？<br>  <strong>A:</strong>根元素，position层，transform、半透明、css滤镜、canvas、video、overflow等</li>
<li>对DOM元素节点计算样式结果。（Recalculate Style）</li>
<li>为每个节点生成图形位置。（Layout 回流/重排）</li>
<li>将每个节点绘制填充到图层位图中。（Paint）</li>
<li>把图层作为纹理，上传到GPU</li>
<li>把符合的图层生成到页面上。（Composite Layers 合成层）<br>  <strong>Q:</strong>Composite Layers做了啥？<br>  <strong>A:</strong><pre><code>图层的绘制列表，准备好，commit给（合成线程）主线程
合成线程 viewport 划分图块
生成位图的过程  光栅化 Raster
所有图块 合成DarwQuad提交给浏览器渲染进程
viz组件接收到DarwQuad 后，绘制到屏幕上</code></pre></li>
</ul>
<p><strong>总结上面过程的主要过程</strong><br>Layout ==&gt; Paint ==&gt; Composite Layers</p>
<h3 id="渲染引擎结构与工作流程"><a href="#渲染引擎结构与工作流程" class="headerlink" title="渲染引擎结构与工作流程"></a>渲染引擎结构与工作流程</h3><p>以HTML、JS、CSS等文件作为输入，以可视化内容作为输出<br>经过下面步骤：</p>
<ol>
<li>Parsing HTML to construct DOM tree<br> 根据html文件生成dom树，框架</li>
<li>Render Tree Construction<br> 根据css，js文件，<strong>在dom树的基础上</strong>生成渲染树</li>
<li>Layout of Render Tree<br> 渲染树布局排版（重排）</li>
<li>Painting Render Tree<br> 排版之后。绘制（重绘）</li>
<li>Display<br> （Composite Layers 合成层，布局树）后，把符合的图层上传到GPU生成到页面上展示。<ul>
<li>把文档的结构、元素的样式、几何形状和绘制顺序转换在屏幕上的像素。这个过程称为光栅化</li>
<li>合成是一种将页面的各个部分分层，分别栅格化，并在一个被称为合成器线程的独立线程中合成页面的技术</li>
<li>上传到GPU生成到页面上展示。</li>
</ul>
</li>
</ol>
<h3 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h3><ul>
<li><p>跳过重排重绘 直接触发了GPU执行  这就是硬件加速<br>  <strong>Q:</strong>什么会触发硬件加速，让GPU加入进来？<br>  <strong>A:</strong>CSS3D、video、webgl、transform、css滤镜、will-change:transform</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> ball-running &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* transform: translate(0,0); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    25% &#123;</span><br><span class="line">        <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="comment">/* transform: translate(200px,0); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">top</span>:<span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="comment">/* transform: translate(200px,200px); */</span></span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">        <span class="attribute">top</span>:<span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* transform: translate(0,200px); */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <em>上面的动画代码会一直触发重排重绘，性能差</em><br>  <em>下面的动画代码将处理交给GPU放在一个layer层中去处理，跳过重排重绘,性能大大提升</em></p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> ball-running &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    25% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">200px</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">200px</span>,<span class="number">200px</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">200px</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>Q:</strong>什么属性会造成重排重绘，导致性能下降？<br>  <strong>A:</strong></p>
<pre><code>可以参考这个网站：[csstriggers](https://csstriggers.com/)
盒子模型的盒子变了
读属性时：offset、scroll、client、width会造成重排（下面为解决方案:requestAnimationFrame）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方式: 读写分离（读写读写读写&#x3D;&#x3D;&#x3D;&gt;读读读写写写）</span><br><span class="line">const width &#x3D; document.getElementById(&quot;xx&quot;).width;</span><br><span class="line">requestAnimationFrame(function()&#123;</span><br><span class="line">    &#x2F;&#x2F; 写逻辑</span><br><span class="line">    &#x2F;&#x2F; React Fiber？</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
<h3 id="大量Dom如何优化"><a href="#大量Dom如何优化" class="headerlink" title="大量Dom如何优化"></a>大量Dom如何优化</h3><p>以下内容来自<strong>京城一灯</strong>小程序Day102题</p>
<ul>
<li>缓存Dom对象<br>  操作Dom时，如果有访问Dom的操作。尤其像循环遍历这种时间复杂度较高的操作。<br>  在循环前将父（主）节点先获取到，在循环中就可以直接饮用，不必要循环查询  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rootElem = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>);</span><br><span class="line"><span class="keyword">let</span> childList = rootElem.child; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;childList.length;j++)&#123;</span><br><span class="line">    <span class="comment">//对应操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>文档片段<br>  利用<code>document.createDocumentFragment()</code>方法创建文档碎片节点，创建的是一个虚拟Dom对象。向这个节点添加Dom节点，修改Dom节点并不会影响到真是的Dom结构。<br>  我们可以利用这一点先将需要修改的Dom一并修改完，保存至文档碎片中，然后用文档碎片一次性的替换真实的Dom节点。与虚拟Dom类似，也达到了不频繁修改Dom而导致的重排和重绘的过程  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">const</span> operationDomHandler = <span class="function">(<span class="params">fragment</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line">operationDomHandler(fragment);</span><br><span class="line">rootElem.replaceChild(fragment, oldDom)</span><br></pre></td></tr></table></figure>
  这样只触发一次回流（重排），效率会打打提升。如果需要对元素进行复杂的操作（删减，添加加点），那么我们应当先将元素从页面中移除，然后再对其进行操作。或者将其复制一个（cloneNode()）,在内存中进行操作后再替换原来的节点  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneNode = old.cloneNode(<span class="literal">true</span>);</span><br><span class="line">operationDomHandler(cloneNode);</span><br><span class="line"> rootElem.replaceChild(cloneNode, oldDom);</span><br></pre></td></tr></table></figure></li>
<li>用<code>innerHtml</code>代替高频的<code>appendChild</code></li>
<li>最优的layout方案<br>  批量读，一次性写。<br>  先对一个不在render tree上的节点进行操作，在把这个节点添加回render tree。这样只处罚一次Dom操作。使用<code>requestAnimationFrame()</code>，把任何导致重绘的操作放入<code>requestAnimationFrame</code>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="built_in">document</span>.getElementById(<span class="string">"xx"</span>).width;</span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 写逻辑</span></span><br><span class="line">    <span class="comment">// React Fiber？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>虚拟Dom<br>  js模拟Dom树并对Dom树操作的一种技术。Virtual Dom是一个纯js对象（字符串对象），所以对它操作是高效的。<br>  利用Virtual Dom，将dom抽象为虚拟Dom，在Dom发生改变的时候先将虚拟Dom进行操作，通过Dom diff算法将虚拟Dom和原虚拟Dom的结构对比，最终批量的去修改真是的Dom结构，尽可能的避免了频繁修改Dom而导致的频繁的重排和重绘。</li>
</ul>
<blockquote>
<p><a class="link"   href="https://www.npmjs.com/package/fastdom"  target="_blank" rel="noopener">fastdom<i class="fas fa-external-link-alt"></i></a>，处理dom的插件</p>
</blockquote>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Http请求的代价是昂贵的"><a href="#Http请求的代价是昂贵的" class="headerlink" title="Http请求的代价是昂贵的"></a>Http请求的代价是昂贵的</h1><p><a href="/2020/07/24/navigationTiming/">Navigation Timing</a>从输入网址敲击回车开始到页面完全加载完成展示。其中的过程是优化的要点。</p>
<h3 id="性能优化方向"><a href="#性能优化方向" class="headerlink" title="性能优化方向"></a>性能优化方向</h3><p><a href="/2020/07/21/前端性能优化（一）雅虎军规/">前端性能优化（一）雅虎军规</a><br><a href="/2020/07/21/前端性能优化（二）缓存为王/">前端性能优化（二）缓存为王</a><br><a href="/2020/07/21/前端性能优化（三）协议处理/">前端性能优化（三）协议处理</a><br><a href="/2020/07/22/浏览器渲染过程/">前端性能优化（四）渲染优化</a><br><a href="/2020/07/23/HTMLCSSJS渲染执行/">前端性能优化（五）HTML中css,js标签位置的影响</a></p>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps"  target="_blank" rel="noopener">渐进式 Web 应用（PWA）<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="站点测速"><a href="#站点测速" class="headerlink" title="站点测速"></a>站点测速</h3><p>根据用户的网速进行适配的资源加载</p>
<ul>
<li><strong>navigator.connection</strong><br>  Navigator.connection 是只读的，提供一个NetworkInformation 对象来获取设备的网络连接信息。例如用户设备的当前带宽或连接是否被计量， 这可以用于基于用户的连接来选择高清晰度内容或低清晰度内容。(不太准确)<br>  <code>connectionInfo = navigator.connection</code></li>
<li>纯图片请求，速度 = 文件大小 / 时间<br>  算出的速度包含dns解析等时间，不纯粹不准<br>  <code>speed = size/time</code></li>
<li>多普勒测速<br>  <img src="http://i.feidom.com/%E5%A4%9A%E6%99%AE%E5%8B%92%E6%B5%8B%E9%80%9F.jpg" alt="多普勒测速"><br>  <code>speed = (40k-10k)/(t5-t4)</code></li>
</ul>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化（三）协议处理</title>
    <url>/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="http请求的代价是昂贵的"><a href="#http请求的代价是昂贵的" class="headerlink" title="http请求的代价是昂贵的"></a>http请求的代价是昂贵的</h3><p>HTTP 缓存，对于前端的性能优化方面来讲，是非常关键的，从缓存中读取数据和直接向服务器请求数据。</p>
<h3 id="协议缓存规则"><a href="#协议缓存规则" class="headerlink" title="协议缓存规则"></a>协议缓存规则</h3><p>浏览器发起请求，服务器响应请求。在这个过程中，双方协商了两种方式来规定缓存规则。</p>
<ul>
<li>强缓存：<br>  浏览器在加载资源时，根据请求头的 <code>Expires</code> 和 <code>Cache-control</code> 判断，是则直接从缓存读取资源，不会发请求到服务器。<br>  优先级高于<strong>协商缓存</strong><br>  <img src="http://i.feidom.com/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD.gif" alt="强缓存命中"><br>  <img src="http://i.feidom.com/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88.gif" alt="强缓存未命中"></li>
<li>协商缓存<br>  如果没有命中<strong>强缓存</strong>，加载资源的请求会发送到服务器，通过 <code>Last-Modified</code> 和 <code>Etag</code> 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回<strong>304</strong>（Not Modified），但是不会返回这个资源的数据，依然是从缓存中读取资源。<br>  <img src="http://i.feidom.com/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD.gif" alt="协商缓存命中"><br>  <img src="http://i.feidom.com/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E6%9C%AA%E5%91%BD%E4%B8%AD.gif" alt="协商缓存未命中"><br>如果前面两者都没有命中，直接从服务器加载资源。</li>
</ul>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化（二）缓存为王</title>
    <url>/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%93%E5%AD%98%E4%B8%BA%E7%8E%8B/</url>
    <content><![CDATA[<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>常用的库(jquery等)，不经常变得这些库，版本要求不是很严格，用HTTP强缓存。<br><a href="/2020/07/21/前端性能优化（三）协议处理/">前端性能优化（三）协议处理</a></p>
<h3 id="前端离线缓存"><a href="#前端离线缓存" class="headerlink" title="前端离线缓存"></a>前端离线缓存</h3><p>业务代码，md5变化频繁，使用本地缓存。</p>
<ul>
<li><p>cookie</p>
<ul>
<li>存储最大数据量为4K</li>
<li>同一个域名下存放 Cookie 的个数是有限制的，不同浏览器的个数不一样，一般为 20 个；</li>
<li>Cookie 支持设置过期时间，当过期时自动销毁；</li>
<li>每次发起同域下的请求都会发送回服务器</li>
</ul>
</li>
<li><p>Local Storage</p>
<ul>
<li>用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。（和Session Storage的区别）</li>
<li>相当于一个 5M左右的针对于前端页面的数据库</li>
<li>键值对存储，存储的Value限定为string类型</li>
<li>在浏览器的隐私模式下不可读取</li>
<li>本质上是对字符串的读取,且<strong>操作是同步的</strong>，建议存储量在2.5M以下，否则会变卡</li>
<li>不能被爬虫抓取到</li>
<li>受到同源限制，不能跨域。但是,可以借助postMessage和iframe来实现跨域的数据读取</li>
<li>在同源的所有标签页和窗口之间共享数据</li>
</ul>
</li>
<li><p>Session Storage</p>
<ul>
<li>与 localStorage 拥有统一的 API 接口；</li>
<li>用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。（和Local Storage的区别）</li>
<li>数据在页面刷新后依然存在，但在关闭浏览器标签页之后数据就会被清除；</li>
</ul>
</li>
<li><p>IndexedDB（NoSQL 数据库）</p>
<ul>
<li>允许储存大量数据（一般来说不少于 250M，甚至没有上限），提供查找接口，还能建立索引。</li>
<li>键值对储存。所有类型的数据都可以直接存入，包括 JavaScript 对象。同时支持二进制储存（ArrayBuffer 对象和 Blob 对象）。</li>
<li><strong>操作是异步的</strong></li>
<li>支持事务。</li>
<li>受到同源限制，每一个数据库对应创建它的域名。访问不能跨域。<blockquote>
<p>来自 <a class="link"   href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html"  target="_blank" rel="noopener">阮一峰的网络日志<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Web SQl</p>
<ul>
<li>Web SQL 能方便进行对象存储</li>
<li>Web SQL 支持事务，能方便地进行数据查询和数据处理操作</li>
<li><strong>HTML5放弃了Web SQL Database</strong><br>放弃的原因是：<br>This document was on the W3C Recommendation track but specification work has stopped. The specification reached an impasse: all interested implementors have used the same SQL backend (Sqlite), but we need multiple independent implementations to proceed along a standardisation path.<br>大概意思是：这个文档是W3C推荐的，但是规范工作已经停止了。规范陷入了僵局:所有感兴趣的实现者都使用相同的SQL后端(Sqlite)，但是我们需要多个独立的实现来沿着标准化的道路前进。</li>
</ul>
</li>
</ul>
<h3 id="本地缓存方案"><a href="#本地缓存方案" class="headerlink" title="本地缓存方案"></a>本地缓存方案</h3><ul>
<li>主流的数据 开源库<ul>
<li>localForage<br>localForage 是一个快速简单的 JavaScript 存储库。它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。</li>
<li>Dexie.js<br>Dexie.js 是 IndexedDB 的包装库，它提供了一套经过精心设计的 API，强大的错误处理，较强的可扩展性，此外它能够跟踪数据变化，支持 KeyRange (搜索不区分大小写，可设置匹方式和 OR 操作)。<br>Dexie.js 主要为了解决原生 IndexedDB API 中存在的三个主要问题：异常错误处理。较弱的查询功能。代码复杂性。</li>
</ul>
</li>
<li>local Storage缓存js方案管理版本</li>
</ul>
<ol>
<li>存储文件的js完整路径及名称，名称中包含文件版本信息（md5等）。<br><code>localStorage.setItem(&quot;common:widget/a.js&quot;, &quot;/static/common/widget/a_[md5旧].js&quot;)</code></li>
<li>根据js完整路径及名称，存储js代码<br><code>localStorage.setItem(&quot;/static/common/widget/a_[md5旧].js&quot;, &quot;代码code...&quot;)</code></li>
<li>init时，启动的js脚本加载manifest这种清单<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const manifest = &#123;</span><br><span class="line">    "common:widget/a.js":"/static/common/widget/a_[md5新].js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>逻辑判断，加载js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aJs = localStorage.getItem(<span class="string">"common:widget/a.js"</span>) <span class="comment">// "/static/common/widget/a_[md5旧].js"</span></span><br><span class="line"><span class="keyword">const</span> md5 = <span class="string">"md5新"</span> <span class="comment">// 文件版本</span></span><br><span class="line">&lt;!-- 然后判断这个文件是否存在 --&gt;</span><br><span class="line"><span class="keyword">if</span>(aJs)&#123;</span><br><span class="line">    <span class="comment">// 存在，有缓存</span></span><br><span class="line">    <span class="keyword">if</span>(md5 === <span class="string">"md5旧"</span>)&#123;</span><br><span class="line">        <span class="comment">// 缓存没过期，直接去缓存里的</span></span><br><span class="line">        <span class="keyword">const</span> aJsCode =  localStorage.getItem(aJs)</span><br><span class="line">        <span class="comment">// 执行缓存的js代码,evel只是例子，不建议使用.可以addScript</span></span><br><span class="line">        evel(aJsCode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 缓存过期</span></span><br><span class="line">        localStorage.removeItem(aJs)</span><br><span class="line">        <span class="comment">// 拉取新的</span></span><br><span class="line">        <span class="keyword">const</span> aJsCodeNew = fetch(<span class="string">"/static/common/widget/a_[md5新].js"</span>)</span><br><span class="line">        <span class="comment">// 存缓存</span></span><br><span class="line">        localStorage.setItem(<span class="string">"common:widget/a.js"</span>, <span class="string">"/static/common/widget/a_[md5新].js"</span>)</span><br><span class="line">        localStorage.setItem( <span class="string">"/static/common/widget/a_[md5新].js"</span>, aJsNew)</span><br><span class="line">        <span class="comment">// 执行新的js代码</span></span><br><span class="line">        evel(aJsCodeNew)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 不存在，没有缓存。拉取新的文件，执行</span></span><br><span class="line">    fetch(<span class="string">"/static/common/widget/a_[md5新].js"</span>)</span><br><span class="line">    <span class="comment">// 做缓存</span></span><br><span class="line">    localStorage.setItem(<span class="string">"common:widget/a.js"</span>, <span class="string">"/static/common/widget/a_[md5新].js"</span>)</span><br><span class="line">    localStorage.setItem(<span class="string">"/static/common/widget/a_[md5新].js"</span>, <span class="string">"代码code..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化（一）雅虎军规</title>
    <url>/2020/07/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84/</url>
    <content><![CDATA[<h3 id="雅虎军规"><a href="#雅虎军规" class="headerlink" title="雅虎军规"></a>雅虎军规</h3><ul>
<li>内容主体：</li>
</ul>
<ol>
<li>尽量减少HTTP请求数</li>
<li>减少DNS查找</li>
<li>避免重定向</li>
<li>让Ajax可缓存</li>
<li>延迟加载组件</li>
<li>预加载组件</li>
<li>减少DOM元素的数量<br> 善用css伪类<br> 按需加载，减少不必要的渲染<br> 结构合理，语义化标签</li>
<li>跨域分离组件<br> 分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。</li>
<li>尽量少用iframe</li>
<li>杜绝404</li>
</ol>
<ul>
<li>css部分：</li>
</ul>
<ol>
<li>把样式表放在顶部</li>
<li>避免使用CSS表达式</li>
<li>选择<code>&lt;link&gt;</code>舍弃<code>@import</code></li>
<li>避免使用滤镜</li>
</ol>
<ul>
<li>js部分：</li>
</ul>
<ol>
<li>去除重复脚本</li>
<li>尽量减少DOM访问</li>
<li>用智能的事件处理器<br> 事件委托</li>
<li>把脚本放在底部<blockquote>
<p>5-6个script请求，每个文件大小gzip后30kb左右</p>
</blockquote>
</li>
</ol>
<ul>
<li>javascript, css部分:</li>
</ul>
<ol>
<li>把JavaScript和CSS放到外面</li>
<li>压缩JavaScript和CSS</li>
</ol>
<ul>
<li>图片</li>
</ul>
<ol>
<li>优化图片</li>
<li>优化CSS Sprite</li>
<li>不要用HTML缩放图片</li>
<li>用小的可缓存的favicon.ico（P.S. 收藏夹图标）<blockquote>
<p>svg图片的使用；CSS Sprites（雪碧图/精灵图）；tinypngjs（图片压缩工具）</p>
</blockquote>
</li>
</ol>
<ul>
<li>cookie</li>
</ul>
<ol>
<li>给cookie减肥</li>
<li>把组件放在不含cookie的域下</li>
</ol>
<ul>
<li>移动端 </li>
</ul>
<ol>
<li>保证所有组件都小于25K<br> 这个限制是因为iPhone不能缓存大于25K的组件</li>
<li>把组件打包到一个复合文档里</li>
</ol>
<ul>
<li>服务器</li>
</ul>
<ol>
<li>Gzip组件</li>
<li>避免图片src属性为空</li>
<li>配置ETags</li>
<li>对Ajax用GET请求</li>
<li>尽早清空缓冲区</li>
<li>使用CDN（内容分发网络）</li>
<li>添上Expires或者Cache-Control HTTP头</li>
</ol>
]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>node的websockets监听unix_domain_socket</title>
    <url>/2020/07/20/node%E7%9A%84websockets%E7%9B%91%E5%90%ACunix-domain-socket/</url>
    <content><![CDATA[<h3 id="WebSockets-listening-on-UNIX-domain-socket"><a href="#WebSockets-listening-on-UNIX-domain-socket" class="headerlink" title="WebSockets listening on UNIX domain socket?"></a>WebSockets listening on UNIX domain socket?</h3><ul>
<li><p>Server side:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server;</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">server</span> : server&#125;);</span><br><span class="line">server.listen(<span class="string">'/tmp/server.sock'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client side:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> ws(<span class="string">"ws+unix:///tmp/server.sock"</span>)</span><br><span class="line">client.send(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><a class="link"   href="https://stackoverflow.com/questions/23930293/websockets-listening-on-unix-domain-socket?answertab=active#tab-top"  target="_blank" rel="noopener">原文地址<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下常用命令查看端口占用</title>
    <url>/2020/07/11/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>查看当前所有tcp端口<br><code>$ netstat -ntlp</code></li>
<li>查看所有9000端口使用情况<br><code>netstat -ntulp | grep 3306</code></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sonarqube配置及使用</title>
    <url>/2020/07/11/sonarqube%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a class="link"   href="https://docs.sonarqube.org/latest/"  target="_blank" rel="noopener">sonarqube官网文档<i class="fas fa-external-link-alt"></i></a>：代码质量的检测及管理</p>
<h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><ul>
<li>安装java环境（本地和服务器都需要）<br>sonarqube依赖高版本的java环境，以下内容使用jdk14<br>在<a class="link"   href="https://www.oracle.com/"  target="_blank" rel="noopener">oracle官网<i class="fas fa-external-link-alt"></i></a>下载<a class="link"   href="https://www.oracle.com/java/technologies/javase-jdk14-downloads.html"  target="_blank" rel="noopener">java<i class="fas fa-external-link-alt"></i></a>mac版（macOS Installer）和服务器Linux版（Linux RPM Package）。这种的不需要配环境变量，自动配好。<blockquote>
<p>注意：不要装openjdk</p>
</blockquote>
</li>
<li>将服务器Linux版的jdk上传到服务器并安装(pwd命令查看文件绝对路径)<br><code>$ scp /Users/yingying/Downloads/jdk-14.0.1_linux-x64_bin.rpm root@8.129.182.113:/opt/</code><br>rpm安装jdk<br><code>$ rpm -i jdk-14.0.1_linux-x64_bin.rpm</code><br>rpm查询包信息<br><code>$ rpm -qa</code>  找到=&gt; <code>jdk-14.0.1-14.0.1-ga.x86_64</code><br>rpm卸载jsk<br><code>$ rpm -e jdk-14.0.1-14.0.1-ga.x86_64</code></li>
</ul>
<h3 id="安装sonarqube"><a href="#安装sonarqube" class="headerlink" title="安装sonarqube"></a>安装sonarqube</h3><ul>
<li>在服务器端安装Community版本<br><code>wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-8.4.0.35506.zip</code></li>
<li>sonarqube不能使用root身份启动，所以建一个sonar用户，将sonarqube-developer-8.4.0.35506.zip文件给到sonar用户。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root$ useradd sonar</span><br><span class="line">root$ passwd sonar</span><br><span class="line">root$ chown -R sonar sonarqube-developer-8.4.0.35506.zip</span><br></pre></td></tr></table></figure></li>
<li>切换用户身份到sonar进行接下来的操作<code>su sonar</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar$ unzip sonarqube-developer-8.4.0.35506.zip</span><br></pre></td></tr></table></figure>
提示没有权限。<blockquote>
<p>注意：在opt文件夹下解压 文件.zip。会创建一个新的文件夹存放解压文件。此时sonar用户没有opt文件夹的读写执行权限。所以报错<code>Permission denied</code><br>解决：使用root身份修改文件权限。给sonar权限。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root$ chmod 754 opt</span><br><span class="line">root$ chmod 777 /opt/sonarqube-developer-8.4.0.35506.zip</span><br></pre></td></tr></table></figure>
然后执行unzip，解压成功。之后进入解压文件夹下的bin目录的linux-x86-64目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar$ <span class="built_in">cd</span> /opt/sonarqube-8.4.0.35506/bin/linux-x86-64/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="运行sonarqube"><a href="#运行sonarqube" class="headerlink" title="运行sonarqube"></a>运行sonarqube</h3><p>在这有sonar.sh启动脚本，先不着急./sonar.sh start。先使用console查看启动日志,再start</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar$ <span class="built_in">cd</span> /opt/sonarqube-8.4.0.35506/bin/linux-x86-64/</span><br><span class="line">sonar$ ./sonar.sh console</span><br><span class="line">sonar$ ./sonar.sh start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>意外：在启动成功后，使用公网ip:端口号 访问失败。发现是阿里云安全组的问题。配置好了以后访问成功<br>意外：在装了汉化包之后，重启sonarqube，启动成功。但是访问一直pending。过一会就好了。应该是汉化包太大，在加载的原因</p>
</blockquote>
<h3 id="初始化一个项目（test）"><a href="#初始化一个项目（test）" class="headerlink" title="初始化一个项目（test）"></a>初始化一个项目（test）</h3><p>以下操作都可以在公网ip:9000项目中可视化操作</p>
<ol>
<li>使用公网ip:9000访问到sonarqube</li>
<li>使用默认账号/密码：admin/admin登陆</li>
<li>手工设置一个项目：test</li>
<li>设置一个token（客户端会用到的口令）</li>
<li>开始分析项目</li>
<li>选择项目的主要语言：其他（js）</li>
<li>选择客户端的操作系统（macOS）</li>
<li><a class="link"   href="https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/"  target="_blank" rel="noopener">下载并解压macOS平台的解析器SonarScanner<i class="fas fa-external-link-alt"></i></a>，是一个zip文件</li>
<li>为SonarScanner配置环境变量<br>配置～/.bash_profile<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sonar-scanner 环境变量  pwd找到sonar-scanner目录下的bin文件夹路径</span></span><br><span class="line"><span class="built_in">export</span> SCANNER_HOME=<span class="string">"/Users/yingying/Documents/qwf/libs/sonar-scanner-4.4.0.2170-macosx"</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SCANNER_HOME</span>/bin</span><br></pre></td></tr></table></figure>
使环境变量生效<br><code>$ source .bash_profile</code><br>可以执行<code>$ sonar-scanner -v</code>来查看是否配置安装成功</li>
<li>在项目（例：nodejs-demo）中配置SonarScanner<br>在项目根目录新建<code>sonar-project.properties</code>文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar-scanner \</span><br><span class="line">  <span class="comment"># 项目名</span></span><br><span class="line">  -Dsonar.projectKey=<span class="built_in">test</span> \</span><br><span class="line">  <span class="comment"># 要扫描的代码目录</span></span><br><span class="line">  -Dsonar.sources=. \</span><br><span class="line">  <span class="comment"># 要上报报告的服务器链接</span></span><br><span class="line">  -Dsonar.host.url=http://8.129.182.113:9000 \</span><br><span class="line">  <span class="comment"># token</span></span><br><span class="line">  -Dsonar.login=a258647adea0e982df705ac3512cbbe47154cfd3</span><br></pre></td></tr></table></figure></li>
<li>在终端 shell 执行你的这个 sonar-project.properties 文件<code>bash sonar-project.properties</code>。静静等待10分钟左右…</li>
<li>结果报表会在公网ip:9000中可视化展示</li>
</ol>
<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><ul>
<li>自带的内嵌数据库比较小。处理大项目需要配一下</li>
<li>sonarQube默认不支持mysql。需要安装<a class="link"   href="https://dev.mysql.com/downloads/connector/j/"  target="_blank" rel="noopener">mysql Connector(驱动)<i class="fas fa-external-link-alt"></i></a>后才能使用<br>安装方式：将驱动放在<code>extensions/jdbc-driver/mysql/</code>（这个路径不确定）下</li>
<li>配置文件：/opt/sonarqube-8.4.0.35506/conf/sonar.properties<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sonar.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.1.222:3306&#x2F;sonar?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;rewriteBatchedStatements&#x3D;true</span><br></pre></td></tr></table></figure></li>
<li>在使用库使，要提前建立好sonar库，命令参照如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE sonar;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">CREATE USER &#39;sonar&#39; IDENTIFIED BY &#39;sonar&#39;;</span><br><span class="line"></span><br><span class="line">GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;;</span><br><span class="line"></span><br><span class="line">GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;sonar&#39;;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p><a class="link"   href="https://hondrytravis.github.io/blog/engineering/sonar.html#sonar"  target="_blank" rel="noopener">详细操作链接<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>sonarqube</tag>
      </tags>
  </entry>
  <entry>
    <title>进程&amp;线程&amp;协程</title>
    <url>/2020/07/08/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>进程是cpu调度的基本单位</li>
<li>线程是cpu调度的最小单位，一个进程至少有一个线程（主线程）</li>
<li>协程不被操作系统内核所管理，完全由程序控制。</li>
</ul>
<h3 id="多种进程"><a href="#多种进程" class="headerlink" title="多种进程"></a>多种进程</h3><p><img src="http://i.feidom.com/%E5%A4%9A%E7%A7%8D%E8%BF%9B%E7%A8%8Ba.png" alt="实际情况"></p>
<ul>
<li>单线程进程的fork过程，将主线程的代码、数据、文件、寄存器状态、栈都复制多份。</li>
<li>多线程进程中，各个线程拥有自己的寄存器状态和栈。共享进程中的代码、数据、文件。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现PM2多进程原理（简版）</title>
    <url>/2020/07/07/js%E5%AE%9E%E7%8E%B0PM2%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>了解<a href="/2020/07/08/进程线程协程/">进程&amp;线程&amp;协程</a></p>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><blockquote>
<p>前端实现的node项目</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="pm2-js"><a href="#pm2-js" class="headerlink" title="pm2.js"></a>pm2.js</h3><blockquote>
<p>模拟PM2多进程</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// master</span></span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">var</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;   <span class="comment">// 多核cpu的核数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// cluster.isMaster为true，表示是主进程</span></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(numCPUs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> worker = cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"./app.js"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pm2.js运行后，会创建一个主进程（父进程master）。</li>
<li>然后创建numCPUs个node进程，这些进程相当于子进程。受到主进程master的管理，调度分配<br>共创建了numCPUs+1个进程<blockquote>
<p>重点在<code>cluster.fork()</code>来fork子进程。然后cluster.isMaster为false时，创建的子进程去<code>require(&quot;./app.js&quot;)</code>，实现多进程管理。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>PM2</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux免密远程登录</title>
    <url>/2020/07/07/Linux%E5%85%8D%E5%AF%86%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>前端在部署项目时，使用Linux免密远程登录可以实现自动化中的一环。</p>
<h3 id="免密登录的原理"><a href="#免密登录的原理" class="headerlink" title="免密登录的原理"></a>免密登录的原理</h3><p>ssh，密码学，公钥，私钥</p>
<h3 id="免密登录的步骤"><a href="#免密登录的步骤" class="headerlink" title="免密登录的步骤"></a>免密登录的步骤</h3><blockquote>
<p>下文中：[你自己的名字]是私钥，[你自己的名字_rsa]是公钥</p>
</blockquote>
<ul>
<li><p>生成密匙对</p>
<p>  <code>$ ssh-keygen -t rsa -C [你自己的名字] -f [你自己的名字_rsa]</code></p>
</li>
<li><p>上传配置公钥</p>
<ul>
<li>上传公钥到服务器对应账号的home路径下的.ssh/中<br><code>$ ssh-copy-id -i [你自己的名字_rsa] [用户名@服务器ip或域名]</code></li>
<li>配置公钥文件访问权限为 600  (设置拥有者可读写，其他人不可读写执行 -rw——-)<br><code>$ chmod 600 [你自己的名字_rsa]</code></li>
</ul>
</li>
<li><p>配置本地私钥</p>
<ul>
<li>把第一步生成的私钥复制到你的home目录下的.ssh/ 路径下</li>
<li>配置你的私钥文件访问权限为 600  (-rw——-,不是600系统会认为不安全拒绝访问)<br><code>$ chmod 600 [你自己的名字]</code><blockquote>
<p>这一步之后已经可以免密登录<code>ssh -i [你自己的名字] root@[ip]</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>免密登陆功能的本地配置文件(更方便的免密登录方式)</p>
<ul>
<li>编辑自己home目录的.ssh/ 路径下的config文件<code>vi config</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多主机配置</span></span><br><span class="line">Host gateway-produce</span><br><span class="line">HostName IP或绑定的域名</span><br><span class="line">Port 22</span><br><span class="line">Host node-produce</span><br><span class="line">HostName IP或绑定的域名</span><br><span class="line">Port 22</span><br><span class="line">Host java-produce</span><br><span class="line">HostName IP或绑定的域名</span><br><span class="line">Port 22</span><br><span class="line"></span><br><span class="line">Host *-produce (多主机别名，免密登录时可以使用这个别名登录)</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/你自己的名字_rsa</span><br><span class="line">Protocol 2</span><br><span class="line">Compression yes</span><br><span class="line">ServerAliveInterval 60</span><br><span class="line">ServerAliveCountMax 20</span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">#单主机配置</span></span><br><span class="line">Host feidom-cloud (别名，免密登录时可以使用这个别名登录)</span><br><span class="line">User root</span><br><span class="line">HostName IP或绑定的域名</span><br><span class="line">IdentityFile ~/.ssh/你自己的名字_rsa</span><br><span class="line">Protocol 2</span><br><span class="line">Compression yes</span><br><span class="line">ServerAliveInterval 60</span><br><span class="line">ServerAliveCountMax 20</span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">#单主机配置</span></span><br><span class="line">Host feidom2-site</span><br><span class="line">User git</span><br><span class="line">HostName IP或绑定的域名</span><br><span class="line">IdentityFile ~/.ssh/你自己的名字_rsa</span><br><span class="line">Protocol 2</span><br><span class="line">Compression yes</span><br><span class="line">ServerAliveInterval 60</span><br><span class="line">ServerAliveCountMax 20</span><br><span class="line">LogLevel INFO</span><br></pre></td></tr></table></figure></li>
<li>配置config文件的访问权限为 644<blockquote>
<p>使用<code>ssh [别名]</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>categories和tags页面不自动收录的问题</title>
    <url>/2020/07/06/hexo%E7%9A%84categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E8%87%AA%E5%8A%A8%E6%94%B6%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用hexo的过程中，发现分类(categories)页面和标签(tags)页面不自动收录文章(其实收录了，只是没显示)的categories和tags。<br>解决方案：</p>
<ul>
<li>编辑categories/index.md<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2020-07-01 08:56:35</span><br><span class="line">type: categories</span><br><span class="line"></span><br><span class="line">增加下面这一行</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure></li>
<li>tags/index.md<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2020-07-01 09:03:55</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">增加下面这一行</span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令(个人总结)</title>
    <url>/2020/07/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="git概念"><a href="#git概念" class="headerlink" title="git概念"></a>git概念</h3><ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：本地仓库</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>查看git config配置<br><code>git config --list</code></p>
</li>
<li><p>git config全局配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"feidom"</span></span><br><span class="line">git config --global user.email <span class="string">"qiaoxiansen@hotmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git config针对单个项目配置用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd 项目目录,作用于当前项目下的.git目录下的config</span></span><br><span class="line">git config user.name <span class="string">"feidom"</span></span><br><span class="line">git config user.email <span class="string">"qiaoxiansen@hotmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><p>克隆一个项目和它的整个代码历史<br><code>$ git clone [url]</code></p>
</li>
<li><p>查看本地仓库分支<br><code>$ git branch</code></p>
</li>
<li><p>查看所有本地分支和远程分支<br><code>$ git branch -a</code></p>
</li>
<li><p>查看所有所有远程分支<br><code>$ git branch -r</code></p>
</li>
<li><p>查看分支关联关系<br><code>$ git branch -vv</code></p>
</li>
</ul>
<hr>
<ul>
<li><p>查看不同<br><code>$ git diff</code></p>
</li>
<li><p>显示有变更的文件<br><code>$ git status</code></p>
</li>
<li><p>添加当前目录的所有文件到暂存区<br><code>$ git add .</code></p>
</li>
<li><p>提交暂存区到本地仓库<br><code>$ git commit -m [提交信息]</code></p>
</li>
<li><p>拉取远程仓库带代码到本地仓库并合并<br><code>$ git pull [remote] [branch]</code><br><code>$ git pull</code>(分支有关联关系时)</p>
</li>
<li><p>上传本地指定分支到远程仓库<br><code>$ git push [remote] [branch]</code><br><code>$ git push</code>(分支有关联关系时)</p>
</li>
</ul>
<hr>
<ul>
<li>创建一个新的空分支（内容来自互联网）<br><code>$ git checkout --orphan [新的分支名]</code> (建一个没有父节点的分支，但是会复制当前分支的内容到新的分支上。)</li>
</ul>
<blockquote>
<p>&emsp; 这个命令创建了新的分支并切换到新的分支下，并且里边有上个分支的内容<br>&emsp; <strong>注意</strong> ：其实这个时候新的分支还不能说是一个分支，你查看分支的话，是没有这个分支的，你必须要提交一次，这个分支才算是真的创建出来了<br>&emsp; 因为这个分支没有父节点，所以没有任何的历史，只需要调用<br>&emsp; <code>$ git rm -rf .</code><br>&emsp; 删除所有的文件（只会删除加入版本管理的文件），然后你可以随便创建一个文件，提交之后，这个新的空分支就算是创建完成了。</p>
</blockquote>
<ul>
<li><p>新建一个本地分支，并切换到该分支<br><code>$ git checkout -b [本地分支] [remote]</code>(-b会建立本地分支和远程分支的关联关系)</p>
</li>
<li><p>从某个提交记录(2b5c3292)拉一个新分支出来<br><code>$ git checkout 2b5c3292 -b [branch]</code></p>
</li>
<li><p>提交当前分支到远程仓库的对应的新分支<br><code>$ git push -u origin [branch]</code>(-u会建立本地分支和远程分支的关联关系)</p>
</li>
<li><p>新建本地分支与远程分支关联关系<br><code>git branch --set-upstream-to [远程分支] [本地分支]</code></p>
</li>
<li><p>删除本地分支<br>切到其他分支，然后<code>git branch -d [本地分支]</code></p>
</li>
<li><p>从远程获取其他用户push上来的新分支<br><code>git fetch</code></p>
</li>
</ul>
<hr>
<ul>
<li><p>查看远程仓库信息<br><code>git remote -v</code></p>
</li>
<li><p>移除远程仓库<br><code>git remote remove origin</code></p>
</li>
<li><p>添加远程仓库<br><code>git remote add origin [远程仓库地址]</code></p>
</li>
<li><p>查看该分支的远程仓库<br><code>git remote show</code><br>upstream：被fork的仓库/origin：自己fork的仓库</p>
</li>
<li><p>从自己本地切一个分支出来<br><code>git checkout -b [本地分支名]</code></p>
</li>
<li><p>从远程仓库地址pull代码<br><code>git pull origin master --rebase</code> 先拉自己fork仓库的最新代码<br><code>git pull upstream master --rebase</code> 再拉被fork仓库的最新代码</p>
</li>
<li><p>推送代码到自己fork仓库分支<br><code>git push origin [自己远程仓库的分支]</code></p>
</li>
<li><p>合并多个commit记录为一个<br><code>git rebase -i HEAD~</code></p>
</li>
<li><p>自己的远端提pull request到upstream的远端，github上操作</p>
</li>
</ul>
<hr>
<ul>
<li>vscode合并分支<br>在vscode界面，输入：<code>ctrl(win)/command(mac)+shift+p</code>,然后输入<code>git merge</code>，然后选一个要合并到当前分支的分支，回车确定即可。<br><img src="https://image-static.segmentfault.com/800/712/800712115-59e96580eae4c_articlex" alt="git merge"><br><img src="https://image-static.segmentfault.com/236/385/2363856556-59e965b2e3674_articlex" alt="选择分支"></li>
</ul>
<h3 id="git问题解决："><a href="#git问题解决：" class="headerlink" title="git问题解决："></a>git问题解决：</h3><ul>
<li>git clone 时出错： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: RPC failed; result&#x3D;35, HTTP code &#x3D; 0</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br></pre></td></tr></table></figure>
解决：<ul>
<li>查看全局的postBuffer配置 <code>git config http.postBuffer</code></li>
<li>把这个配置改大一点： <code>git config http.postBuffer 24288000</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>svg图标的使用</title>
    <url>/2020/07/04/svg%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="svg图标在前端应用的优点"><a href="#svg图标在前端应用的优点" class="headerlink" title="svg图标在前端应用的优点"></a>svg图标在前端应用的优点</h3><ul>
<li>和传统的图像比起来，尺寸更小，且可压缩性更强</li>
<li>可伸缩</li>
<li>任何分辨率之下都可以被完美的打印</li>
<li>svg中图像中的文本是可选的，同时也是可搜索的，很适合做地图。</li>
</ul>
<h3 id="svg必须知道的标签知识"><a href="#svg必须知道的标签知识" class="headerlink" title="svg必须知道的标签知识"></a>svg必须知道的标签知识</h3><ul>
<li><p><code>&lt;defs&gt;</code><br>SVG 允许我们定义以后需要重复使用的图形元素。 建议把所有需要再次使用的引用元素定义在defs元素里面。这样做可以增加SVG内容的易读性和可访问性。 在defs元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用<code>&lt;use&gt;</code>元素呈现这些元素。</p>
</li>
<li><p><code>&lt;use&gt;</code><br>官方说法：使用URI引用一个<G>,<svg>或其他具有一个唯一的ID属性和重复的图形元素。复制的是原始的元素，因此文件中的原始存在只是一个参考。原始影响到所有副本的任何改变。<br>理解：作用是能从SVG文档内部取出一个节点，通过唯一的ID属性克隆它，并把它输出到别处。跟‘引用’很相似，但它是深度克隆。</p>
</li>
<li><p><code>&lt;path&gt;</code><br>SVG路径，path元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。</p>
<h3 id="svg常用修改"><a href="#svg常用修改" class="headerlink" title="svg常用修改"></a>svg常用修改</h3></li>
<li><p>修改宽(width)高(height)<br>  修改svg标签内的width、height来修改图标的大小宽(width)高(height)</p>
</li>
<li><p>修改颜色</p>
<ol>
<li>在style标签中定义类，使用fill关键字定义颜色，如.st7。</li>
<li>在path标签中增加类名：class=”st7”，用类名控制颜色。</li>
</ol>
</li>
</ul>
<p>如下例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!--  修改svg标签内的width、height来修改图标的大小宽(width)高(height)  --&gt;</span><br><span class="line">&lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;图层_1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot;</span><br><span class="line">  width&#x3D;&quot;17px&quot; height&#x3D;&quot;16px&quot; viewBox&#x3D;&quot;0 0 11 11&quot; style&#x3D;&quot;enable-background:new 0 0 11 11;&quot; xml:space&#x3D;&quot;preserve&quot;&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line"> .st0&#123;fill:#08A6F1;&#125;</span><br><span class="line"> .st1&#123;fill:#18C27B;&#125;</span><br><span class="line"> .st2&#123;fill:#FFA200;&#125;</span><br><span class="line"> .st3&#123;fill-rule:evenodd;clip-rule:evenodd;fill:#18C27B;&#125;</span><br><span class="line"> .st4&#123;fill-rule:evenodd;clip-rule:evenodd;fill:#FFA200;&#125;</span><br><span class="line"> .st5&#123;fill:#F44436;&#125;</span><br><span class="line"> .st6&#123;clip-path:url(#SVGID_2_);&#125;</span><br><span class="line"> .st7&#123;fill:#00CDD9;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;!--  1.在style标签中定义类，使用fill关键字定义颜色，如.st7。  --&gt;</span><br><span class="line">&lt;!--  2.在path标签中增加类名：class&#x3D;&quot;st7&quot;，用类名控制颜色。  --&gt;</span><br><span class="line">&lt;path class&#x3D;&quot;st7&quot; d&#x3D;&quot;M11,10.7c0,0.2-0.2,0.3-0.3,0.3H0.3C0.2,11,0,10.8,0,10.7V10c0-0.2,0.2-0.3,0.3-0.3h10.3c0.2,0,0.3,0.2,0.3,0.3L11,10.7</span><br><span class="line"> L11,10.7z M1.9,4.8l3.3,3.4c0.1,0.1,0.4,0.1,0.5,0l0,0l3.3-3.4c0.1-0.1,0.1-0.2,0.1-0.4C9.1,4.3,9,4.2,8.8,4.2h-2V0.3</span><br><span class="line"> C6.9,0.2,6.7,0,6.5,0H4.5C4.3,0,4.1,0.2,4.1,0.3v3.9h-2C2,4.2,1.8,4.4,1.8,4.6C1.8,4.7,1.8,4.8,1.9,4.8L1.9,4.8z&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs前端话事人</title>
    <url>/2020/07/01/NodeJs%E5%89%8D%E7%AB%AF%E8%AF%9D%E4%BA%8B%E4%BA%BA/</url>
    <content><![CDATA[<h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。 <a class="link"   href="http://nodejs.cn/"  target="_blank" rel="noopener">Node.js 中文网<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="NodeJs应用场景"><a href="#NodeJs应用场景" class="headerlink" title="NodeJs应用场景"></a>NodeJs应用场景</h4><ul>
<li><p>我要的只是一个香蕉，得到的确是整个森林<br><img src="http://i.feidom.com/node_a.jpg" alt="实际情况"></p>
</li>
<li><p>SSR(服务器端渲染)</p>
<ul>
<li>SEO友好</li>
<li>优化单页应用的首屏加载时间</li>
</ul>
</li>
</ul>
<h4 id="NodeJs闪亮登场"><a href="#NodeJs闪亮登场" class="headerlink" title="NodeJs闪亮登场"></a>NodeJs闪亮登场</h4><p>SPA(single page web application) + NodeJs<br>方案：NodeJs做Proxy(代理)层，加载web页，连接后台服务。</p>
<p>实现了:</p>
<ul>
<li>消减接口返回的response。经过NodeJs层处理返回的数据，前端拿到的只有她该拿到的东西，数据小了，传输快了，性能更好。</li>
<li>真假路由混用。Node可以独立控制路由，并不受后端限制，可以独立部署上线。前端拥有更强的主动性。<br>  Node可以独立控制路由，可以做<strong>同构</strong>。</li>
</ul>
<p>Q&amp;A：<br>    &emsp;Q:为什么用NodeJs做代理层，而不用其他语言？<br>    &emsp;A:NodeJs是基于JavaScript语言的，前端框架Vue等只提供Js的API(Nuxt.js)。</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/"  target="_blank" rel="noopener">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/"  target="_blank" rel="noopener">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html"  target="_blank" rel="noopener">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues"  target="_blank" rel="noopener">GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html"  target="_blank" rel="noopener">Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html"  target="_blank" rel="noopener">Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html"  target="_blank" rel="noopener">Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html"  target="_blank" rel="noopener">Deployment<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<h3 id="New-categories"><a href="#New-categories" class="headerlink" title="New categories"></a>New categories</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<h3 id="New-tags"><a href="#New-tags" class="headerlink" title="New tags"></a>New tags</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
